pexpect_lic='Pexpect Copyright (c) 2008 Noah Spurrier\nhttp://pexpect.sourceforge.net/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the "Software"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n'
desktop_data='[Desktop Entry]\nComment=\nComment[de]=\nEncoding=UTF-8\nExec="\xc2\xa7/collectNWDataGUI.sh"\nIcon=\xc2\xa7/collectNWDataGUI.jpg\nPath=\xc2\xa7\nName=collectNWDataGUI\nName[de]=collectNWDataGUI\nStartupNotify=true\nTerminal=false\nTerminalOptions=\nType=Application\n'
script_data='#!/bin/bash\n#    Copyright (C) 2006-2016 framp at linux-tips-and-tricks dot de\n#\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#    (at your option) any later version.\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n#\n#    You should have received a copy of the GNU General Public License\n#    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n# Summary:\n#   Script which analyzes network problems and collects network information on Linux systems\n#   Useful for everybody who has networking issues on his distribution. The script\n#   analyzes the system for most common networking config issues and writes meaningful\n#   error messages which are explained in detail (see link below). That way it\'s possible\n#   to fix most common config issues without any help. \n#\n#   The script collects a lot of networking information from the system and creates an \n#   output file. This provides valuable information about the network and helps\n#   people to help to fix the issue quickly if it\'s not a common networking config issue. \n#\n# Change history:\n#   See http://www.linux-tips-and-tricks.de/CND_history\n#\n# Latest version for download:\n#   See http://www.linux-tips-and-tricks.de/CND_download\n#\n# List of messages with detailed help information:\n#   See http://www.linux-tips-and-tricks.de/CND\n#\n# List of contributors: \n#   See http://www.linux-tips-and-tricks.de/CND_contributors\n#\n# Volunteers to translate messages in other languages: \n#   See http://www.linux-tips-and-tricks.de/CND_nls\n\n#################################################################################\n#################################################################################\n#################################################################################\n#\n# --- various constants\n#\n#################################################################################\n#################################################################################\n#################################################################################\n\nCVS_VERSION="V0.7.5.3"\nCVS_REVISION="$Revision: 1.385 $"\nCVS_DATE="$Date: 2016/03/27 10:49:01 $"\nCVS_DATE_ONLY=${CVS_DATE/: /}\nCVS_DATE_ONLY=${CVS_DATE_ONLY/ \\$/}\nCVS_REVISION_ONLY=${CVS_REVISION/: /}\nCVS_REVISION_ONLY=${CVS_REVISION_ONLY/ \\$}\n\nAUTHOR="framp at linux-tips-and-tricks dot de"\nCOPYRIGHT="Copyright (C) 2006-2016 ${AUTHOR}"\n#VERSION="$CVS_VERSION (Rev: ${CVS_REVISION_ONLY}, Build: ${CVS_DATE_ONLY} UTC)"\nVERSION="$CVS_VERSION"\nLICENSE="This program comes with ABSOLUTELY NO WARRANTY; \nThis is free software, and you are welcome to redistribute it\nunder certain conditions"\n\nBASEURL="www.linux-tips-and-tricks.de"\nCONTACT="framp@linux-tips-and-tricks.de"\nHTTP_ROOT_ACCESS="http://$BASEURL/CND_ROOT"\nHTTP_UPLOAD_URL="http://$BASEURL/CND_UPL"\nHTTP_HELP_URL="http://$BASEURL/CND"\nHTTP_XLATE_URL="http://$BASEURL/CND_NLS"\nVAR_LOG_MESSAGE_FILE="/var/log/messages"\n\nif [[ ! -e $VAR_LOG_MESSAGE_FILE ]]; then\n\tVAR_LOG_MESSAGE_FILE="/var/log/syslog"\nfi\n\ncase $LANG in\n\tde_*)\n\t\t;;\n    *)\n        HTTP_HELP_URL="${HTTP_HELP_URL}#English"\n        HTTP_ROOT_ACCESS="${HTTP_ROOT_ACCESS}#English"\n        HTTP_UPLOAD_URL="${HTTP_UPLOAD_URL}#English"\n        ;;\nesac;\n\nMYSELF="${0##*/}"\nCODE_BEGIN="[code]"\nCODE_END="[/code]"\nDEBUG="off"\n\nESSID_MASK="\xc2\xa7\xc2\xa7\xc2\xa7\xc2\xa7\xc2\xa7\xc2\xa7\xc2\xa7\xc2\xa7";\n\nSEPARATOR="=================================================================================================================="\nCMD_PREFIX="====="\nPROCESS_CHARS="|/-\\\\|/-"\nprocess_chars_cnt=0\nMINOR_SEPARATOR="------------------------------------------------------------------------------------------------------------------"\nVERSION_STRING="$MYSELF $VERSION $COPYRIGHT"\nNUMBER_OF_LINES_TO_CHECK_IN_VAR_LOG_MESSAGES=300\nMAX_ERROR_PERCENT=5                   # acceptable error rate on interfaces (xmit and rcv)\n\n# --- get the absolute path of script such that the output file can be written in the same directory\n\nPRG_DIR=`dirname "$0"`\nOLD_PWD=`pwd`\ncd "$PRG_DIR"\nexport CND_DIR=`pwd`\ncd "$OLD_PWD"\n\nif [[ $UID -eq 0 || $USE_ROOT != "1" ]]; then\n   CONSOLE_RESULT="${CND_DIR}/${MYSELF/.sh/}.con"\n   ELIZA_RESULT="${CND_DIR}/${MYSELF/.sh/}.eza"\n   COLLECT_RESULT="${CND_DIR}/${MYSELF/.sh/}.col"\n   FINAL_RESULT="${CND_DIR}/${MYSELF/.sh/}.txt"\n   FINAL_RESULT_SHORT_NAME="${MYSELF/.sh/}.txt"\n   STATE="/tmp/${MYSELF}_S.$$"\n   LOG=$COLLECT_RESULT\nelse\n   chmod +x $CND_DIR/$MYSELF\nfi\n\n# check if predicatable interface names are used on system\n\nfunction PNINused() {\n\tlocal rc\n    debug ">>PNINused"\n\n\tif $IFCONFIG | $GREP "^(en|wl)"; then\n\t\trc=0\n\telse\n\t\trc=1\n\tfi\t\n  \tPNIUSED=$rc\n    debug "<<PNINused $rc"\n    state "PNIN:$rc"\n\treturn $rc\n}\n\n\n# check if openSuse config files are readable\n\nfunction configReadable() { \n\n\tlocal mask\n\tlocal rc\n\trc=1\n\tmask="[arwe]"\n    for f in `ls /etc/sysconfig/network/ifcfg-${mask}* 2>/dev/null`; do      # process all configs\n\t\tdebug "$f"\n\t\tif [[ ! -r $f ]]; then\t# file readable \n\t\t\trc=0\n\t\t\tbreak\t\t\n\t\tfi\n\tdone\n\n\tCONFIG_READABLE=$rc\n\tstate "CFR:$rc"\n\n\treturn $rc\n}\n\nfunction queryDistro () {\n\nlocal distro\nlocal detectedDistro="Unknown"\nlocal regExpLsbFile="/etc/(.*)[-_]"\nlocal skipFiles="lsb|os|upstream"\n\n#################################################################################\n# Query distro the script runs on\n#################################################################################\n#\n# Returned distro       Distribution the script was tested on\n# ---------------------------------------------------------\n# suse                  openSuSE 11.0 (no lsb_release) and 11.2 (lsb_release)\n# redhat                Fedora 12\n# redhat                CentOS 5.4\n# debian                Kubuntu 9.10\n# debian                Debian 5.0.3\n# arch                  Arch\n# slackware             Slackware 13.0.0.0.0\n# redhat                Mandriva 2009.1\n# debian                Knoppix 6.2\n# debian                Mint 8\n#\n#################################################################################\n\nUNKNOWN_DISTRO=-1\nSUSE=0\nREDHAT=1\nDEBIAN=2\nARCH=3\nSLACKWARE=4\n\netcFiles=`ls /etc/*[-_]{release,version} 2>/dev/null`\nfor file in $etcFiles; do\n   if [[ $file =~ $regExpLsbFile ]]; then\n      nextDetectedDistro=${BASH_REMATCH[1]}\n      if [[ $nextDetectedDistro =~ $skipFiles ]]; then\n         continue\n      fi\n      detectedDistro=$nextDetectedDistro\n      if [[ $nextDetectedDistro == "redhat"|| $nextDetectedDistro == "debian" ]]; then\n         break\n      fi\n   else\n      echo "??? Should not occur: Don\'t find any etcFiles ???"\n      exit 255\n   fi\ndone\n\nDISTRO_NAME=$detectedDistro\n\ndistro=`echo $detectedDistro | tr "[:lower:]" "[:upper:]"`\nDISTRO="DISTRO=\\$$distro"\neval $DISTRO\n\n}\n\n#################################################################################\n# --- tools needed by the script\n#\n# LSUSB checked at runtime - not beforehand - because it\'s not installed all the time\n#################################################################################\n\nMODS_OPT="HWINFO DHCPCD LSUSB RFKILL LSHW"\t# optional commands\nMODS_ALL="EGREP AWK SED IFCONFIG IWCONFIG IWLIST IPTABLES LSPCI GREP PERL ARP ROUTE LSMOD SORT PING TAIL"  # required commands\n\n#################################################################################\n# --- cleanup files in case of failure\n#################################################################################\n\nfunction cleanupTempFiles {\n   rm -f "$LOG" 2>/dev/null\n   rm -f "$ELIZA_RESULT" 2>/dev/null\n   rm -f "$CONSOLE_RESULT" 2>/dev/null\n   rm -f "$COLLECT_RESULT" 2>/dev/null\n   rm -f $STATE 2>/dev/null\n}\n\nfunction cleanupFiles {\n   rm -f "$FINAL_RESULT" 2>/dev/null\n   cleanupTempFiles\n   exit\n}\n\ntrap \'cleanupFiles\' SIGHUP SIGINT SIGPIPE SIGTERM\n\n#################################################################################\n#\n# --- Messages in English and German\n#\n# (volunteers to translate the messages into other languages are welcome)\n#\n#################################################################################\n\n# supported languages\n\nMSG_EN=1      # english\nMSG_DE=1      # german\nMSG_PT=1      # portugiese\nMSG_PL=1      # polish\nMSG_CS=1      # czech\nMSG_FR=1      # french\n\nMSG_UNDEFINED=0\nMSG_EN[$MSG_UNDEFINED]="Undefined message. Pls inform the author $CONTACT"\nMSG_FR[$MSG_UNDEFINED]="Message inconnu. S\'il vous pla\xc3\xaet informer l\'auteur $CONTACT"\nMSG_CS[$MSG_UNDEFINED]="Nedefinov\xc3\xa1na spr\xc3\xa1va. Pros\xc3\xadm, informujte autora $CONTACT"\nMSG_DE[$MSG_UNDEFINED]="Unbekannte Meldung. Bitte den Author $CONTACT informieren"\nMSG_PT[$MSG_UNDEFINED]="Por favor informe o autor $CONTACT"\nMSG_PL[$MSG_UNDEFINED]="Niezdefiniowany komunikat. Prosz\xc4\x99 poinformuj autora $CONTACT"\nMSG_INTERNAL_ERROR=1\nMSG_EN[$MSG_INTERNAL_ERROR]="Internal error %1 occured. Pls inform the author $CONTACT"\nMSG_FR[$MSG_INTERNAL_ERROR]="L\'erreur interne %1 s\'est produite . Svp informer l\'auteur $CONTACT"\nMSG_CS[$MSG_INTERNAL_ERROR]="Objevile se %1 chyba. Kontaktujte pros\xc3\xadm autora $CONTACT"\nMSG_DE[$MSG_INTERNAL_ERROR]="Interner Fehler %1 aufgetreten. Bitte den Author $CONTACT informieren"\nMSG_PT[$MSG_INTERNAL_ERROR]="Erro interno %1. Por favor informe o autor $CONTACT"\nMSG_PL[$MSG_INTERNAL_ERROR]="Wyst\xc4\x85pi\xc5\x82 b\xc5\x82\xc4\x85d wewn\xc4\x99trzny %1. Prosz\xc4\x99 poinformuj autora $CONTACT"\nMSG_ELIZA_START_ANALYZE=2\nMSG_EN[$MSG_ELIZA_START_ANALYZE]="--- NWEliza is analyzing the system for common network configuration errors ..."\nMSG_FR[$MSG_ELIZA_START_ANALYZE]="--- NWEliza recherche dans le syst\xc3\xa8me les erreurs de configuration du r\xc3\xa9seau ..."\nMSG_CS[$MSG_ELIZA_START_ANALYZE]="--- NWEliza analyzuje syst\xc3\xa9m pro obecn\xc3\xa9 chyby s\xc3\xad\xc5\xa5ov\xc3\xa9 konfigurace..."\nMSG_DE[$MSG_ELIZA_START_ANALYZE]="--- NWEliza untersucht das System nach h\xc3\xa4ufigen Netzwerkkonfigurationsfehlern ..."\nMSG_PT[$MSG_ELIZA_START_ANALYZE]="--- NWEliza est\xc3\xa1 procurando por erros comuns de configura\xc3\xa7\xc3\xa3o de rede no sistema ..."\nMSG_PL[$MSG_ELIZA_START_ANALYZE]="--- NWEliza analizuje system pod k\xc4\x85tem najcz\xc4\x99stszych b\xc5\x82\xc4\x99d\xc3\xb3w konfiguracji sieci."\nMSG_START_COLLECTING=3\nMSG_EN[$MSG_START_COLLECTING]="--- NWCollect is collecting networkconfiguration information into file %1 ..."\nMSG_FR[$MSG_START_COLLECTING]="--- NWCollect recueille l\'information de configuration du r\xc3\xa9seau dans le fichier %1 ..."\nMSG_CS[$MSG_START_COLLECTING]="--- NWCollect shroma\xc5\xbe\xc4\x8fuje informaci o s\xc3\xad\xc5\xa5ov\xc3\xa9 konfiguraci  do souboru %1 ..."\nMSG_DE[$MSG_START_COLLECTING]="--- NWCollect sammelt Netzwerkkonfigurationsinformationen in Datei %1 ..."\nMSG_PT[$MSG_START_COLLECTING]="--- NWCollect est\xc3\xa1 reunindo informa\xc3\xa7\xc3\xb5es de configura\xc3\xa7\xc3\xa3o de rede no arquivo %1 ..."\nMSG_PL[$MSG_START_COLLECTING]="--- NWCollect zbiera dane na temat konfiguracji sieci do pliku %1 ..."\nMSG_CON_WRL=4\nMSG_EN[$MSG_CON_WRL]="--- (1) Wireless connection (WLAN)"\nMSG_FR[$MSG_CON_WRL]="--- (1) Connexion sans fil (WLAN)"\nMSG_CS[$MSG_CON_WRL]="--- (1) Bezdr\xc3\xa1tov\xc3\xa9 p\xc5\x99ipojen\xc3\xad (WLAN)"\nMSG_DE[$MSG_CON_WRL]="--- (1) Kabellose Verbindung (WLAN)"\nMSG_PT[$MSG_CON_WRL]="--- (1) Conex\xc3\xa3o sem fio (WLAN)"\nMSG_PL[$MSG_CON_WRL]="--- (1) Po\xc5\x82\xc4\x85czenie bezprzewodowe (WLAN)"\nMSG_ANSWER_CHARS_NO=5\nMSG_EN[$MSG_ANSWER_CHARS_NO]="Nn"\nMSG_FR[$MSG_ANSWER_CHARS_NO]="Nn"\nMSG_CS[$MSG_ANSWER_CHARS_NO]="Nn"\nMSG_DE[$MSG_ANSWER_CHARS_NO]="Nn"\nMSG_PT[$MSG_ANSWER_CHARS_NO]="Nn"\nMSG_PL[$MSG_ANSWER_CHARS_NO]="Nn"\nMSG_ANSWER_CHARS_YES=6\nMSG_EN[$MSG_ANSWER_CHARS_YES]="Yy"\nMSG_FR[$MSG_ANSWER_CHARS_YES]="Oo"\nMSG_CS[$MSG_ANSWER_CHARS_YES]="Aa"\nMSG_DE[$MSG_ANSWER_CHARS_YES]="Jj"\nMSG_PT[$MSG_ANSWER_CHARS_YES]="Ss"\nMSG_PL[$MSG_ANSWER_CHARS_YES]="Tt"\nMSG_MAIN_PROG_REQUIRED=7\nMSG_EN[$MSG_MAIN_PROG_REQUIRED]="!!! Program %1 not found. Install program and invoke script again"\nMSG_FR[$MSG_MAIN_PROG_REQUIRED]="!!! Le programme %1 est introuvable. Installez le programme et red\xc3\xa9marrez le script"\nMSG_CS[$MSG_MAIN_PROG_REQUIRED]="!!! Program %1 se nena\xc5\xa1el. Nainstalujte program a spus\xc5\xa5te skript znovu"\nMSG_DE[$MSG_MAIN_PROG_REQUIRED]="!!! Das Programm %1 ist nicht verf\xc3\xbcgbar. Das Programm nachinstallieren und das Script danach noch einmal ausf\xc3\xbchren"\nMSG_PT[$MSG_MAIN_PROG_REQUIRED]="!!! Programa %1 n\xc3\xa3o encontrado. Instale o programa e execute esse script novamente"\nMSG_PL[$MSG_MAIN_PROG_REQUIRED]="!!! Program %1 nie zosta\xc5\x82 znaleziony. Zainstaluj go i uruchom skrypt ponownie"\nMSG_MAIN_NO_ERROR_DETECTED=8\nMSG_EN[$MSG_MAIN_NO_ERROR_DETECTED]="--- No obvious errors/warnings detected. Post contents of file %1 in your favorite Linux forum and read $HTTP_UPLOAD_URL"\nMSG_FR[$MSG_MAIN_NO_ERROR_DETECTED]="--- Aucune erreur ou avertissement \xc3\xa9vidents d\xc3\xa9tect\xc3\xa9s. Postez le contenu du fichier %1 dans votre forum Linux pr\xc3\xa9f\xc3\xa9r\xc3\xa9 et lisez $HTTP_UPLOAD_URL"\nMSG_CS[$MSG_MAIN_NO_ERROR_DETECTED]="--- Nejsou detekov\xc3\xa1ny \xc5\xbe\xc3\xa1dn\xc3\xa9 z\xc5\x99ejm\xc3\xa9 chyby/hl\xc3\xa1\xc5\xa1en\xc3\xad. Po\xc5\xa1lete obsah souboru %1 do va\xc5\xa1eho obl\xc3\xadben\xc3\xa9ho Linux f\xc3\xb3ra a p\xc5\x99e\xc4\x8dt\xc4\x9bte $HTTP_UPLOAD_URL"\nMSG_DE[$MSG_MAIN_NO_ERROR_DETECTED]="--- Keine offensichtlichen Konfigurationsfehler/-warnungen gefunden. Die Datei %1 im bevorzugten Linux Forum posten und $HTTP_UPLOAD_URL lesen."\nMSG_PT[$MSG_MAIN_NO_ERROR_DETECTED]="--- Nenhum erro/aviso \xc3\xb3bvio detectado. Poste o conte\xc3\xbado do arquivo %1 em seu f\xc3\xb3rum Linux preferido e leia $HTTP_UPLOAD_URL"\nMSG_PL[$MSG_MAIN_NO_ERROR_DETECTED]="--- Nie znaleziono \xc5\xbcadnego oczywistego b\xc5\x82\xc4\x99du lub ostrze\xc5\xbcenia. Umie\xc5\x9b\xc4\x87 zawarto\xc5\x9b\xc4\x87 pliku %1 na swoim ulubionym forum i przeczytaj $HTTP_UPLOAD_URL"\nMSG_ASK_LANG=9\nMSG_EN[$MSG_ASK_LANG]="--- Do you want to post the result file in an international forum (y/[n])?"\nMSG_FR[$MSG_ASK_LANG]="--- Voulez-vous envoyer le fichier r\xc3\xa9sultat \xc3\xa0 un forum international (o/[n])?"\nMSG_CS[$MSG_ASK_LANG]="--- Chcete poslat soubour s v\xc3\xbdsledky do mezin\xc3\xa1rodn\xc3\xadho f\xc3\xb3ra (a/[n])?"\nMSG_DE[$MSG_ASK_LANG]="--- Soll das Ergebnisfile in einem internationalen Forum gepostet werden (j/[n])?"\nMSG_PT[$MSG_ASK_LANG]="--- Voc\xc3\xaa quer postar o arquivo resultante em um f\xc3\xb3rum internacional (s/[n])?"\nMSG_PL[$MSG_ASK_LANG]="--- Czy chcesz opublikowa\xc4\x87 wyniki na mi\xc4\x99dzynarodowym forum (t/[n])?"\nMSG_SELECT_LANG=10\nMSG_EN[$MSG_SELECT_LANG]="--- Please answer with yes (Y) or no (N):"\nMSG_FR[$MSG_SELECT_LANG]="--- S\'il vous pla\xc3\xaet r\xc3\xa9pondre par oui (O) ou non (N):"\nMSG_CS[$MSG_SELECT_LANG]="--- Pros\xc3\xadm, odpov\xc4\x9bzte takhle: ano (A) nebo ne (N):"\nMSG_DE[$MSG_SELECT_LANG]="--- Bitte mit ja (J) oder nein (N) antworten:"\nMSG_PT[$MSG_SELECT_LANG]="--- Por favor responda sim (S) ou n\xc3\xa3o (N):"\nMSG_PL[$MSG_SELECT_LANG]="--- Prosz\xc4\x99 odpowiedz tak (T) lub nie (N):"\nMSG_GET_TOPOLOGY=11\nMSG_EN[$MSG_GET_TOPOLOGY]="--- What\'s the type of networktopology?"\nMSG_FR[$MSG_GET_TOPOLOGY]="--- Quel est le type de topologie du res\xc3\xa9au?"\nMSG_CS[$MSG_GET_TOPOLOGY]="--- Jak\xc3\xbd je typ s\xc3\xad\xc5\xa5ov\xc3\xa9 topologie ?"\nMSG_DE[$MSG_GET_TOPOLOGY]="--- Welche Netzwerktopologie liegt vor?"\nMSG_PT[$MSG_GET_TOPOLOGY]="--- Qual \xc3\xa9 a topologia da rede?"\nMSG_PL[$MSG_GET_TOPOLOGY]="--- Jaki jest typ topologi sieci?"\nMSG_UNSUPPORTED_TOPOLOGY=12\nMSG_EN[$MSG_UNSUPPORTED_TOPOLOGY]="--- Unknown topology"\nMSG_FR[$MSG_UNSUPPORTED_TOPOLOGY]="--- Topologie inconnue"\nMSG_CS[$MSG_UNSUPPORTED_TOPOLOGY]="--- Nezn\xc3\xa1m\xc3\xa1 topologie"\nMSG_DE[$MSG_UNSUPPORTED_TOPOLOGY]="--- Netzwerktopologie unbekannt"\nMSG_PT[$MSG_UNSUPPORTED_TOPOLOGY]="--- Topologia desconhecida"\nMSG_PL[$MSG_UNSUPPORTED_TOPOLOGY]="--- Nieznana topologia"\nMSG_STRING=13\nMSG_EN[$MSG_STRING]="%1."\nMSG_PLEASE_CORRECT_ANSWER=14\nMSG_EN[$MSG_PLEASE_CORRECT_ANSWER]="--- Please answer with 1-%1: "\nMSG_FR[$MSG_PLEASE_CORRECT_ANSWER]="--- S\'il vous pla\xc3\xaet r\xc3\xa9pondre avec 1-%1:"\nMSG_CS[$MSG_PLEASE_CORRECT_ANSWER]="--- Pros\xc3\xadm odpov\xc4\x9bzte s 1-%1: "\nMSG_DE[$MSG_PLEASE_CORRECT_ANSWER]="--- Bitte mit 1-%1 anworten: "\nMSG_PT[$MSG_PLEASE_CORRECT_ANSWER]="--- Por favor responda com 1-%1: "\nMSG_PL[$MSG_PLEASE_CORRECT_ANSWER]="--- Prosz\xc4\x99 odpowiedz 1-%1: "\nMSG_TOPO_DM_LC=15\nMSG_EN[$MSG_TOPO_DM_LC]="--- (1) DSL modem <---> LinuxClient"\nMSG_FR[$MSG_TOPO_DM_LC]="--- (1) Modem DSL <---> Client Linux"\nMSG_CS[$MSG_TOPO_DM_LC]="--- (1) DSL modem <---> Linux klient"\nMSG_DE[$MSG_TOPO_DM_LC]="--- (1) DSL modem <---> LinuxClient"\nMSG_PT[$MSG_TOPO_DM_LC]="--- (1) Modem DSL <---> Cliente Linux"\nMSG_PL[$MSG_TOPO_DM_LC]="--- (1) modem DSL <----> Klient Linux"\nMSG_TOPO_DR_LC=16\nMSG_EN[$MSG_TOPO_DR_LC]="--- (2) DSL HW router <---> LinuxClient"\nMSG_FR[$MSG_TOPO_DR_LC]="--- (2) Routeur HW DSL <---> Client Linux"\nMSG_CS[$MSG_TOPO_DR_LC]="--- (2) DSL HW router <---> Linux klient"\nMSG_DE[$MSG_TOPO_DR_LC]="--- (2) DSL HW router <---> LinuxClient"\nMSG_PT[$MSG_TOPO_DR_LC]="--- (2) Roteador DSL <---> Cliente Linux"\nMSG_PL[$MSG_TOPO_DR_LC]="--- (2) DSL HW router <---> Klient Linux"\nMSG_TOPO_DM_LR_LC=17\nMSG_EN[$MSG_TOPO_DM_LR_LC]="--- (3) DSL modem  <---> LinuxRouter <---> LinuxClient"\nMSG_FR[$MSG_TOPO_DM_LR_LC]="--- (3) Modem DSL <--->  Routeur Linux <---> Client Linux"\nMSG_CS[$MSG_TOPO_DM_LR_LC]="--- (3) DSL modem  <---> Linux Router <---> Linux klient"\nMSG_DE[$MSG_TOPO_DM_LR_LC]="--- (3) DSL modem  <---> LinuxRouter <---> LinuxClient"\nMSG_PT[$MSG_TOPO_DM_LR_LC]="--- (3) Modem DSL <---> Roteador Linux <---> Cliente Linux"\nMSG_PL[$MSG_TOPO_DM_LR_LC]="--- (3) DSL modem  <---> LinuxRouter <---> Klient Linux"\nMSG_TOPO_DR_LR_LC=18\nMSG_EN[$MSG_TOPO_DR_LR_LC]="--- (4) DSL HW router <---> LinuxRouter <---> LinuxClient"\nMSG_FR[$MSG_TOPO_DR_LR_LC]="--- 4) Routeur HW DSL<---> Routeur Linux <---> Client Linux"\nMSG_CS[$MSG_TOPO_DR_LR_LC]="--- (4) DSL HW router <---> LinuxRouter <---> LinuxClient"\nMSG_DE[$MSG_TOPO_DR_LR_LC]="--- (4) DSL HW router <---> LinuxRouter <---> LinuxClient"\nMSG_PT[$MSG_TOPO_DR_LR_LC]="--- (4) Roteador DSL <---> Roteador Linux <---> Cliente Linux"\nMSG_PL[$MSG_TOPO_DR_LR_LC]="--- (4) DSL HW router <---> LinuxRouter <---> Klient Linux"\nMSG_MAIN_POST_FILE=27\nMSG_EN[$MSG_MAIN_POST_FILE]="--- If you are unsuccessful then place the contents of file %1 in the net\\n--- (see $HTTP_UPLOAD_URL for links) \\n--- and then paste the nopaste link on your favorite Linux forum. "\nMSG_FR[$MSG_MAIN_POST_FILE]="--- Si vous ne r\xc3\xa9ussissez pas,  placez le contenu du fichier %1 sur internet\\n --- (voir $HTTP_UPLOAD_URL pour les liens) \\n --- et puis collez le lien \'nopaste\' sur votre forum Linux favori."\nMSG_CS[$MSG_MAIN_POST_FILE]="--- Pokud pos\xc3\xadl\xc3\xa1n\xc3\xad selhalo, um\xc3\xadstn\xc4\x9bte obsah souboru %1 na internet\\n--- (viz $HTTP_UPLOAD_URL pro odkazy) \\n--- a pak vlo\xc5\xbete odkaz na va\xc5\xa1e obl\xc3\xadben\xc3\xa9 Linux f\xc3\xb3rum. "\nMSG_DE[$MSG_MAIN_POST_FILE]="--- Wenn eigene L\xc3\xb6sungsversuche erfolglos waren dann den Inhalt der Datei %1 im Netz ablegen\\n--- (Links siehe $HTTP_UPLOAD_URL) \\n--- und dann der nopaste Link im bevorzugten Linux Forum posten."\nMSG_PT[$MSG_MAIN_POST_FILE]="--- Se voc\xc3\xaa n\xc3\xa3o foi bem sucedido poste o conte\xc3\xbado do arquivo %1 na internet\\n--- (veja $HTTP_UPLOAD_URL para links) \\n--- e informe o link nopaste em seu f\xc3\xb3rum Linux preferido."\nMSG_PL[$MSG_MAIN_POST_FILE]="--- Je\xc5\xbceli nie uda\xc5\x82o si\xc4\x99 prosz\xc4\x99 umie\xc5\x9b\xc4\x87 zawarto\xc5\x9b\xc4\x87 pliku %1 w sieci\\n--- (linki mo\xc5\xbcesz znale\xc5\xba\xc4\x87 w $HTTP_UPLOAD_URL) \\n--- i umie\xc5\x9b\xc4\x87 link na swoim ulubionym forum. "\nMSG_GET_HOST=29\nMSG_EN[$MSG_GET_HOST]="--- On which host is the script executed?"\nMSG_FR[$MSG_GET_HOST]="--- Sur quel ordinateur h\xc3\xb4te le script est-il ex\xc3\xa9cut\xc3\xa9?"\nMSG_CS[$MSG_GET_HOST]="--- Na kter\xc3\xa9m host-u je skript spu\xc5\xa1t\xc4\x9bn?"\nMSG_DE[$MSG_GET_HOST]="--- Auf welchem Rechner wird das Script ausgef\xc3\xbchrt?"\nMSG_PT[$MSG_GET_HOST]="--- Em que host o script \xc3\xa9 executado?"\nMSG_PL[$MSG_GET_HOST]="--- Na jakim komputerze zosta\xc5\x82 uruchomiony skrypt?"\nMSG_UNSUPPORTED_HOST=30\nMSG_EN[$MSG_UNSUPPORTED_HOST]="--- Invalid host"\nMSG_FR[$MSG_UNSUPPORTED_HOST]="--- H\xc3\xb4te non valide"\nMSG_CS[$MSG_UNSUPPORTED_HOST]="--- Nespr\xc3\xa1vn\xc3\xbd host"\nMSG_DE[$MSG_UNSUPPORTED_HOST]="--- Ung\xc3\xbcltiger Rechner"\nMSG_PT[$MSG_UNSUPPORTED_HOST]="--- Host inv\xc3\xa1lido"\nMSG_PL[$MSG_UNSUPPORTED_HOST]="--- Nieprawid\xc5\x82owy host"\nMSG_HOST_RT=31\nMSG_EN[$MSG_HOST_RT]="--- (2) LinuxRouter"\nMSG_FR[$MSG_HOST_RT]="--- (2) Routeur Linux"\nMSG_CS[$MSG_HOST_RT]="--- (2) Linux Router"\nMSG_DE[$MSG_HOST_RT]="--- (2) LinuxRouter"\nMSG_PT[$MSG_HOST_RT]="--- (2) Roteador Linux"\nMSG_PL[$MSG_HOST_RT]="--- (2) LinuxRouter"\nMSG_HOST_CL=32\nMSG_EN[$MSG_HOST_CL]="--- (1) LinuxClient"\nMSG_FR[$MSG_HOST_CL]="--- (1) Client Linux"\nMSG_CS[$MSG_HOST_CL]="--- (1) Linux klient"\nMSG_DE[$MSG_HOST_CL]="--- (1) LinuxClient"\nMSG_PT[$MSG_HOST_CL]="--- (1) Cliente Linux"\nMSG_PL[$MSG_HOST_CL]="--- (1) Klient Linux"\nMSG_MAIN_BECOME_ROOT=33\nMSG_EN[$MSG_MAIN_BECOME_ROOT]="--- Please enter the root password."\nMSG_FR[$MSG_MAIN_BECOME_ROOT]="--- S\'il vous pla\xc3\xaet entrez le mot de passe root."\nMSG_CS[$MSG_MAIN_BECOME_ROOT]="--- Pros\xc3\xadm vlo\xc5\xbete root heslo."\nMSG_DE[$MSG_MAIN_BECOME_ROOT]="--- Bitte das root Kennwort eingeben."\nMSG_PT[$MSG_MAIN_BECOME_ROOT]="--- Por favor digite a senha de root."\nMSG_PL[$MSG_MAIN_BECOME_ROOT]="--- Prosz\xc4\x99 wprowadzi\xc4\x87 has\xc5\x82o u\xc5\xbcytkownika root."\nMSG_CON_WRD=40\nMSG_EN[$MSG_CON_WRD]="--- (2) Wired connection"\nMSG_FR[$MSG_CON_WRD]="--- (2) Connexion filaire"\nMSG_CS[$MSG_CON_WRD]="--- (2) Dr\xc3\xa1tov\xc3\xa9 p\xc5\x99ipojen\xc3\xad"\nMSG_DE[$MSG_CON_WRD]="--- (2) Kabelgebundene Verbindung"\nMSG_PT[$MSG_CON_WRD]="--- (2) Conex\xc3\xa3o cabeada"\nMSG_PL[$MSG_CON_WRD]="--- (2) Po\xc5\x82\xc4\x85czenie przewodowe"\nMSG_GET_CONNECTION=41\nMSG_EN[$MSG_GET_CONNECTION]="--- Which type of your network connection should be tested?"\nMSG_FR[$MSG_GET_CONNECTION]="--- Quel type de connexion de votre r\xc3\xa9seau doit \xc3\xaatre test\xc3\xa9?"\nMSG_CS[$MSG_GET_CONNECTION]="--- Kter\xc3\xbd typ va\xc5\xa1eho s\xc3\xad\xc5\xa5ov\xc3\xa9ho p\xc5\x99ipojen\xc3\xad se m\xc3\xa1 testovat?"\nMSG_DE[$MSG_GET_CONNECTION]="--- Welcher Netzwerkverbindungtyp soll getestet werden?"\nMSG_PT[$MSG_GET_CONNECTION]="--- Que tipo de conex\xc3\xa3o da sua rede deve ser testado?"\nMSG_PL[$MSG_GET_CONNECTION]="--- Kt\xc3\xb3ry typ po\xc5\x82\xc4\x85czenia sieciowego ma zosta\xc4\x87 przetestowany?"\nMSG_UNSUPPORTED_CONNECTION=42\nMSG_EN[$MSG_UNSUPPORTED_CONNECTION]="--- Unknown network connection type"\nMSG_FR[$MSG_UNSUPPORTED_CONNECTION]="--- Type de connexion r\xc3\xa9seau inconnu"\nMSG_CS[$MSG_UNSUPPORTED_CONNECTION]="--- Nezn\xc3\xa1m\xc3\xbd typ p\xc5\x99ipojen\xc3\xad"\nMSG_DE[$MSG_UNSUPPORTED_CONNECTION]="--- Netzwerkverbindungstyp unbekannt"\nMSG_PT[$MSG_UNSUPPORTED_CONNECTION]="--- Tipo de conex\xc3\xa3o desconhecido"\nMSG_PL[$MSG_UNSUPPORTED_CONNECTION]="--- Nieznany typ po\xc5\x82\xc4\x85czenia sieciowego"\nMSG_EMPTY_LINE=43\nMSG_EN[$MSG_EMPTY_LINE]=""\nMSG_MAIN_GOTO_LINK=44\nMSG_EN[$MSG_MAIN_GOTO_LINK]="--- Go to $HTTP_HELP_URL to get more detailed instructions \\n--- about the error/warning messages and how to fix the problems on your own."\nMSG_FR[$MSG_MAIN_GOTO_LINK]="--- Visitez $HTTP_HELP_URL pour obtenir des instructions plus d\xc3\xa9taill\xc3\xa9es \\n --- sur les messages d\'erreur/avertissement et comment r\xc3\xa9soudre vous m\xc3\xaame les probl\xc3\xa8mes."\nMSG_CS[$MSG_MAIN_GOTO_LINK]="--- Jd\xc4\x9bte na $HTTP_HELP_URL pro z\xc3\xadskan\xc3\xad v\xc3\xadce detailn\xc3\xadch instrukc\xc3\xad \\n--- o cyb\xc4\x9b/hl\xc3\xa1\xc5\xa1en\xc3\xad a jak probl\xc3\xa9m manu\xc3\xa1ln\xc4\x9b opravit."\nMSG_DE[$MSG_MAIN_GOTO_LINK]="--- Gehe zu $HTTP_HELP_URL um detailliertere Hinweise \\n--- zu den Fehlermeldungen/Warnungen zu bekommen und wie die Fehler selbst beseitigt werden k\xc3\xb6nnen."\nMSG_PT[$MSG_MAIN_GOTO_LINK]="--- Acesse $HTTP_HELP_URL para obter instru\xc3\xa7\xc3\xb5es detalhadas \\n--- sobre mensagens de erro/aviso e como resolver os problemas por conta pr\xc3\xb3pria."\nMSG_PL[$MSG_MAIN_GOTO_LINK]="--- Przejd\xc5\xba do $HTTP_HELP_URL aby uzyska\xc4\x87 szczeg\xc3\xb3\xc5\x82owe instrukcje \\n--- na temat b\xc5\x82\xc4\x99d\xc3\xb3w oraz ostrze\xc5\xbce\xc5\x84 oraz w jaki spos\xc3\xb3b samodzielnie usun\xc4\x85\xc4\x87 problemy."\nMSG_TOPO_AP_LC=46\nMSG_EN[$MSG_TOPO_AP_LC]="--- (1) WLAN access point <---> LinuxClient"\nMSG_FR[$MSG_TOPO_AP_LC]="--- (1) Point d\'acc\xc3\xa8s WLAN <---> Client Linux"\nMSG_CS[$MSG_TOPO_AP_LC]="--- (1) WLAN access point <---> Linux klient"\nMSG_DE[$MSG_TOPO_AP_LC]="--- (1) WLAN access point <---> LinuxClient"\nMSG_PT[$MSG_TOPO_AP_LC]="--- (1) Ponto de acesso wireless <---> Cliente Linux"\nMSG_PL[$MSG_TOPO_AP_LC]="--- (1) Punkt dost\xc4\x99powy WLAN <---> Klient Linux"\nMSG_TOPO_WR_LC=47\nMSG_EN[$MSG_TOPO_WR_LC]="--- (2) WLAN HW router <---> LinuxClient"\nMSG_FR[$MSG_TOPO_WR_LC]="--- (2) Routeur HW WLAN <---> Client Linux"\nMSG_CS[$MSG_TOPO_WR_LC]="--- (2) WLAN HW router <---> Linux klient"\nMSG_DE[$MSG_TOPO_WR_LC]="--- (2) WLAN HW router <---> LinuxClient"\nMSG_PT[$MSG_TOPO_WR_LC]="--- (2) Roteador wireless <---> Cliente Linux"\nMSG_PL[$MSG_TOPO_WR_LC]="--- (2) WLAN HW router <---> Klient Linux"\nMSG_TOPO_AP_LR_LC=48\nMSG_EN[$MSG_TOPO_AP_LR_LC]="--- (3) WLAN access point <---> LinuxRouter <---> LinuxClient"\nMSG_FR[$MSG_TOPO_AP_LR_LC]="--- (3) R\xc3\xa9seau sans fil <---> Routeur Linux <---> Client Linux"\nMSG_CS[$MSG_TOPO_AP_LR_LC]="--- (3) WLAN access point <---> Linux Router <---> Linux klient"\nMSG_DE[$MSG_TOPO_AP_LR_LC]="--- (3) WLAN access point <---> LinuxRouter <---> LinuxClient"\nMSG_PT[$MSG_TOPO_AP_LR_LC]="--- (3) Ponto de acesso wireless <---> Roteador Linux <---> Cliente Linux"\nMSG_PL[$MSG_TOPO_AP_LR_LC]="--- (3) Punkt dost\xc4\x99powy WLAN <---> LinuxRouter <---> Klient Linux"\nMSG_TOPO_WR_LR_LC=49\nMSG_EN[$MSG_TOPO_WR_LR_LC]="--- (4) WLAN HW router <---> LinuxRouter <---> LinuxClient"\nMSG_FR[$MSG_TOPO_WR_LR_LC]="--- (4) Routeur HW WLAN <---> Routeur Linux <---> Client Linux"\nMSG_CS[$MSG_TOPO_WR_LR_LC]="--- (4) WLAN HW router <---> Linux Router <---> Linux klient"\nMSG_DE[$MSG_TOPO_WR_LR_LC]="--- (4) WLAN HW router <---> LinuxRouter <---> LinuxClient"\nMSG_PT[$MSG_TOPO_WR_LR_LC]="--- (4) Roteador wireless <---> Roteador Linux <---> Cliente Linux"\nMSG_PL[$MSG_TOPO_WR_LR_LC]="--- (4) WLAN HW router <---> LinuxRouter <---> Klient Linux"\nMSG_ASK_FOR_ROOT=59\nMSG_EN[$MSG_ASK_FOR_ROOT]="--- Invoking this script as root allows a more detailed analysis and will give better results. \\n--- If you have any concerns to execute the script as root please read $HTTP_ROOT_ACCESS.\\n--- Do you want to run the script as root ([y]/n)?"\nMSG_FR[$MSG_ASK_FOR_ROOT]="--- Invoquer ce script en tant que root permet une analyse plus d\xc3\xa9taill\xc3\xa9e et donnera de meilleurs r\xc3\xa9sultats. \\n --- Si vous avez des inqui\xc3\xa9tudes sur l\' ex\xc3\xa9cution du script en tant que root, s\'il vous pla\xc3\xaet lisez $HTTP_ROOT_ACCESS. \\n --- Voulez-vous ex\xc3\xa9cuter le script en tant que root ([o] / n)"\nMSG_CS[$MSG_ASK_FOR_ROOT]="--- Spy\xc5\xa1t\xc4\x9bn\xc3\xad skriptu jako root umo\xc5\xbe\xc5\x88uje detailn\xc4\x9bj\xc5\xa1\xc3\xad anal\xc3\xbdzu a lep\xc5\xa1\xc3\xad v\xc3\xbdsledky. \\n--- Pokud m\xc3\xa1te jak\xc3\xa9koli zaujet\xc3\xad spustit skript jako root, pros\xc3\xadm p\xc5\x99e\xc4\x8dt\xc4\x9bte si $HTTP_ROOT_ACCESS.\\n--- Chcete spustit skript jako root ([a]/n)?"\nMSG_DE[$MSG_ASK_FOR_ROOT]="--- Der Aufruf des Scripts als root erlaubt eine detailiertere Analyse und liefert bessere Ergebnisse. \\n--- Falls Bedenken existieren das Script als root auszuf\xc3\xbchren bitte $HTTP_ROOT_ACCESS lesen.\\n--- Willst Du das Script als root ausf\xc3\xbchren lassen ([j]/n)?"\nMSG_PT[$MSG_ASK_FOR_ROOT]="--- Executar esse script como root permite uma an\xc3\xa1lise mais detalhada e melhores resultados. \\n--- Se voc\xc3\xaa se preocupa em executar o script como root por favor leia $HTTP_ROOT_ACCESS.\\n--- Voc\xc3\xaa quer executar o script como root ([s]/n)?"\nMSG_PL[$MSG_ASK_FOR_ROOT]="--- Uruchomienie tego skryptu jako root pozwala na uzyskanie bardziej szczeg\xc3\xb3\xc5\x82owej analizy i przewa\xc5\xbcnie daje lepsze rezultaty.\\n--- Je\xc5\xbceli masz jakiekolwiek obawy z uruchamianiem skryptu jako root prosz\xc4\x99 przeczytaj $HTTP_ROOT_ACCESS.\\n --- Czy mam uruchomi\xc4\x87 skrypt jak u\xc5\xbcytkownik root ([t]/n)?"\nMSG_GET_ESSID=60\nMSG_EN[$MSG_GET_ESSID]="--- Please enter the WLAN SSID you want to connect to (Will be masqueraded in output file): "\nMSG_FR[$MSG_GET_ESSID]="--- S\'il vous pla\xc3\xaet, indiquez le SSID du WLAN auquel vous voulez vous connecter (il sera masqu\xc3\xa9 dans le fichier de sortie):"\nMSG_CS[$MSG_GET_ESSID]="--- Pros\xc3\xadm vlo\xc5\xbete WLAN SSID ke kter\xc3\xa9mu se chcete p\xc5\x99ipojit (bude zm\xc4\x9bn\xc4\x9bno ve v\xc3\xbdsledn\xc3\xa9m souboru): "\nMSG_DE[$MSG_GET_ESSID]="--- Bitte die WLAN SSID zu der verbunden werden soll eingeben (Wird in der Ausgabedatei maskiert): "\nMSG_PT[$MSG_GET_ESSID]="--- Por favor digite a SSID da rede sem fio \xc3\xa0 qual quer se conectar (ser\xc3\xa1 mascarada no arquivo de sa\xc3\xadda): "\nMSG_PL[$MSG_GET_ESSID]="--- Prosz\xc4\x99 wprowad\xc5\xba nazw\xc4\x99 sieci bezprzewodowej (WLAN SSID) do kt\xc3\xb3rej chcesz si\xc4\x99 po\xc5\x82\xc4\x85czy\xc4\x87 (nazwa b\xc4\x99dzie niewidoczna w pliku wynikowym): "\nMSG_GOT_ESSID=61\n#         Attention: Message text below used in regex to masquerade SSID !\nMSG_EN[$MSG_GOT_ESSID]="--- WLAN SSID to connect to: %1"\nMSG_FR[$MSG_GOT_ESSID]="--- WLAN SSID \xc3\xa0 connecter: %1"\nMSG_CS[$MSG_GOT_ESSID]="--- WLAN SSID p\xc5\x99ipojit: %1"\nMSG_DE[$MSG_GOT_ESSID]="--- WLAN SSID zu der verbunden werden soll: %1"\nMSG_PT[$MSG_GOT_ESSID]="--- WLAN SSID da rede local sem fio a conectar: %1"\nMSG_PL[$MSG_GOT_ESSID]="--- WLAN SSID do po\xc5\x82\xc4\x85czenia: %1"\n\nMSG_ASK_FOR_XLATION=62\nMSG_EN[$MSG_ASK_FOR_XLATION]="==> Messages for your language are not translated right now and thus you get all messages in English.\\n==> Any help to translate messages into your language is welcome.\\n==> There is no programming expertise required. Native speakers will need about 1 hour to translate the messages.\\n==> Pls goto $HTTP_XLATE_URL to get more details how to help to translate script messages into your language."\n#\n#\n#\nMSG_NO_NIC_FOUND=300\nMSG_EN[$MSG_NO_NIC_FOUND]="!!! CND0100E: No network card for the selected connection type was found on the system"\nMSG_FR[$MSG_NO_NIC_FOUND]="!!! CND0100E: Aucune carte r\xc3\xa9seau pour le type de connexion s\xc3\xa9lectionn\xc3\xa9 a \xc3\xa9t\xc3\xa9 trouv\xc3\xa9e sur le syst\xc3\xa8me"\nMSG_CS[$MSG_NO_NIC_FOUND]="!!! CND0100E: Nena\xc5\xa1la se \xc5\xbe\xc3\xa1dn\xc3\xa1 s\xc3\xad\xc5\xa5ov\xc3\xa1 karta  pro zvolen\xc3\xbd typ p\xc5\x99ipojen\xc3\xad"\nMSG_DE[$MSG_NO_NIC_FOUND]="!!! CND0100E: Keine Netzwerkkarte f\xc3\xbcr den gew\xc3\xa4hlten Verbindungstyp kann auf dem System gefunden werden"\nMSG_PT[$MSG_NO_NIC_FOUND]="!!! CND0100E: Nenhuma placa de rede para a conex\xc3\xa3o escolhida foi encontrada no sistema"\nMSG_PL[$MSG_NO_NIC_FOUND]="!!! CND0100E: Nie znaleziono kart sieciowych umo\xc5\xbcliwiaj\xc4\x85cych po\xc5\x82\xc4\x85czenie wybranego typu"\nMSG_NO_VALID_NI_FOUND=301\nMSG_EN[$MSG_NO_VALID_NI_FOUND]="!!! CND0110E: For the selected connection type there was no active network interface found on your system"\nMSG_FR[$MSG_NO_VALID_NI_FOUND]="!!! CND0110E: Aucune interface r\xc3\xa9seau active n\'a \xc3\xa9t\xc3\xa9 trouv\xc3\xa9e sur votre syst\xc3\xa8me pour le type de connexion s\xc3\xa9lectionn\xc3\xa9e."\nMSG_CS[$MSG_NO_VALID_NI_FOUND]="!!! CND0110E: Nena\xc5\xa1lo se \xc5\xbe\xc3\xa1dn\xc3\xa9 aktivn\xc3\xad s\xc3\xad\xc5\xa5ov\xc3\xa9 rozhran\xc3\xad pro zvolen\xc3\xbd typ p\xc5\x99ipojen\xc3\xad"\nMSG_DE[$MSG_NO_VALID_NI_FOUND]="!!! CND0110E: Es wurde keine aktives Netzwerkinterface auf dem System f\xc3\xbcr der gew\xc3\xa4hlten Verbindungstyp gefunden"\nMSG_PT[$MSG_NO_VALID_NI_FOUND]="!!! CND0110E: Nenhuma interface de rede ativa foi encontrada no sistema para a conex\xc3\xa3o escolhida"\nMSG_PL[$MSG_NO_VALID_NI_FOUND]="!!! CND0110E: Nie aktywnych urz\xc4\x85dze\xc5\x84 dla wybranego typu po\xc5\x82\xc4\x85czenia"\nMSG_NO_IP_ASSIGNED_TO_NIC=302\nMSG_EN[$MSG_NO_IP_ASSIGNED_TO_NIC]="!!! CND0120E: Network card %1 has no IP address"\nMSG_FR[$MSG_NO_IP_ASSIGNED_TO_NIC]="!!! CND0120E: La carte r\xc3\xa9seau %1 n\'a pas d\'adresse IP"\nMSG_CS[$MSG_NO_IP_ASSIGNED_TO_NIC]="!!! CND0120E: S\xc3\xad\xc5\xa5ov\xc3\xa1 karta %1 nem\xc3\xa1 \xc5\xbe\xc3\xa1dnou IP adresu"\nMSG_DE[$MSG_NO_IP_ASSIGNED_TO_NIC]="!!! CND0120E: Die Netzwerkkarte %1 hat keine IP Adresse"\nMSG_PT[$MSG_NO_IP_ASSIGNED_TO_NIC]="!!! CND0120E: A placa de rede %1 n\xc3\xa3o est\xc3\xa1 associada a um endere\xc3\xa7o IP"\nMSG_PL[$MSG_NO_IP_ASSIGNED_TO_NIC]="!!! CND0120E: Karta sieciowa %1 nie ma przydzielonego adresu IP"\nMSG_DUPLICATE_NETWORKS=303\nMSG_EN[$MSG_DUPLICATE_NETWORKS]="!!! CND0130E: There is more than one network card defined in the same subnet: %1"\nMSG_FR[$MSG_DUPLICATE_NETWORKS]="!!! CND0130E: Il y a plus d\'une carte r\xc3\xa9seau d\xc3\xa9finies dans le m\xc3\xaame sous-r\xc3\xa9seau: %1"\nMSG_CS[$MSG_DUPLICATE_NETWORKS]="!!! CND0130E: Je definov\xc3\xa1no v\xc3\xadce s\xc3\xad\xc5\xa5ov\xc3\xbdch karet  ve stejn\xc3\xa9m subnet-u/pods\xc3\xadti: %1"\nMSG_DE[$MSG_DUPLICATE_NETWORKS]="!!! CND0130E: Es ist mehr als eine Netzwerkkarte im selben Subnetz definiert: %1"\nMSG_PT[$MSG_DUPLICATE_NETWORKS]="!!! CND0130E: H\xc3\xa1 mais de uma placa de rede associada \xc3\xa0 mesma subrede: %1"\nMSG_PL[$MSG_DUPLICATE_NETWORKS]="!!! CND0130E: Wi\xc4\x99cej ni\xc5\xbc jedna karta sieciowa jest przydzielona do tej samej podsieci: %1"\nMSG_NO_DEFAULT_GATEWAY_SET=304\nMSG_EN[$MSG_NO_DEFAULT_GATEWAY_SET]="!!! CND0140E: No default gateway set on your system"\nMSG_FR[$MSG_NO_DEFAULT_GATEWAY_SET]="!!! CND0140E: Aucune passerelle n\'est d\xc3\xa9finie sur votre syst\xc3\xa8me"\nMSG_CS[$MSG_NO_DEFAULT_GATEWAY_SET]="!!! CND0140E: V syst\xc3\xa9mu nen\xc3\xad nastavena \xc5\xbe\xc3\xa1dn\xc3\xa1 brana/gateway"\nMSG_DE[$MSG_NO_DEFAULT_GATEWAY_SET]="!!! CND0140E: Kein default gateway auf dem System definiert"\nMSG_PT[$MSG_NO_DEFAULT_GATEWAY_SET]="!!! CND0140E: Gateway padr\xc3\xa3o n\xc3\xa3o especificado nesse sistema"\nMSG_PL[$MSG_NO_DEFAULT_GATEWAY_SET]="!!! CND0140E: Brak domy\xc5\x9blnej bramy"\nMSG_CHECK_DEFAULT_GATEWAY_SETTING=305\nMSG_EN[$MSG_CHECK_DEFAULT_GATEWAY_SETTING]="!!! CND0150E: There might be a problem with the default gateway definition %1 on interface %2"\nMSG_FR[$MSG_CHECK_DEFAULT_GATEWAY_SETTING]="!!! CND0150E: Il pourrait y avoir un probl\xc3\xa8me avec la d\xc3\xa9finition de la passerelle par d\xc3\xa9faut %1 sur l\'interface %2"\nMSG_CS[$MSG_CHECK_DEFAULT_GATEWAY_SETTING]="!!! CND0150E: M\xc5\xaf\xc5\xbee b\xc3\xbdt probl\xc3\xa9m s p\xc5\x99ednastavenou br\xc3\xa1nou %1 v s\xc3\xad\xc5\xa5ov\xc3\xa9m rozhran\xc3\xad %2"\nMSG_DE[$MSG_CHECK_DEFAULT_GATEWAY_SETTING]="!!! CND0150E: Es kann ein Problem mit der default gateway definition %1 am Interface %2 vorliegen"\nMSG_PT[$MSG_CHECK_DEFAULT_GATEWAY_SETTING]="!!! CND0150E: Pode haver um problema com a especifica\xc3\xa7\xc3\xa3o do gateway padr\xc3\xa3o %1 na interface %2"\nMSG_PL[$MSG_CHECK_DEFAULT_GATEWAY_SETTING]="!!! CND0150E: Ustawienie domy\xc5\x9blnej bramy %1 na urz\xc4\x85dzeniu %2 mo\xc5\xbce stwarza\xc4\x87 problemy"\nMSG_NAMESERVER_NOT_ACCESSIBLE=306\nMSG_EN[$MSG_NAMESERVER_NOT_ACCESSIBLE]="!!! CND0160E: Unable to access nameserver with IP %1 defined in /etc/resolv.conf"\nMSG_FR[$MSG_NAMESERVER_NOT_ACCESSIBLE]="!!! CND0160E: Impossible d\'acc\xc3\xa9der au serveur de noms d\' IP %1 d\xc3\xa9fini dans /etc/resolv.conf"\nMSG_CS[$MSG_NAMESERVER_NOT_ACCESSIBLE]="!!! CND0160E: Nemohu se p\xc5\x99ipojit nameserver s IP %1 nastavenou v /etc/resolv.conf"\nMSG_DE[$MSG_NAMESERVER_NOT_ACCESSIBLE]="!!! CND0160E: Auf den definierter Nameserver mit der IP %1 in /etc/resolv.conf kann nicht zugegriffen werden"\nMSG_PT[$MSG_NAMESERVER_NOT_ACCESSIBLE]="!!! CND0160E: N\xc3\xa3o foi poss\xc3\xadvel acessar o servidor de nomes %1 especificado em /etc/resolv.conf"\nMSG_PL[$MSG_NAMESERVER_NOT_ACCESSIBLE]="!!! CND0160E: Serwer nazw %1 zdefiniowany w pliku /etc/resolv.conf jest nieosi\xc4\x85galny"\nMSG_NO_NAMESERVER_DEFINED=307\nMSG_EN[$MSG_NO_NAMESERVER_DEFINED]="!!! CND0170E: No nameserver defined in /etc/resolv.conf"\nMSG_FR[$MSG_NO_NAMESERVER_DEFINED]="!!! CND0170E: Aucun serveur de noms d\xc3\xa9fini dans /etc/resolv.conf "\nMSG_CS[$MSG_NO_NAMESERVER_DEFINED]="!!! CND0170E: Nen\xc3\xad nastaven\xc3\xbd \xc5\xbe\xc3\xa1dn\xc3\xbd nameserver v /etc/resolv.conf"\nMSG_DE[$MSG_NO_NAMESERVER_DEFINED]="!!! CND0170E: Kein Nameserver in /etc/resolv.conf definiert"\nMSG_PT[$MSG_NO_NAMESERVER_DEFINED]="!!! CND0170E: Nenhum servidor de nomes especificado em /etc/resolv.conf"\nMSG_PL[$MSG_NO_NAMESERVER_DEFINED]="!!! CND0170E: Brak zdefiniowanych serwer\xc3\xb3w nazw (DNS) w pliku /etc/resolv.conf"\nMSG_CANT_PING_EXTERNAL_IP=308\nMSG_EN[$MSG_CANT_PING_EXTERNAL_IP]="!!! CND0180I: The system can\'t ping external IP address %1"\nMSG_FR[$MSG_CANT_PING_EXTERNAL_IP]="!!! CND0180I: Le syst\xc3\xa8me ne peut pas pinguer l\'adresse IP externe %1"\nMSG_CS[$MSG_CANT_PING_EXTERNAL_IP]="!!! CND0180I: Syst\xc3\xa9m nem\xc5\xaf\xc5\xbee prov\xc3\xa9st ping test extern\xc3\xad IP adresy %1"\nMSG_DE[$MSG_CANT_PING_EXTERNAL_IP]="!!! CND0180I: Das System kann die externe IP %1 nicht pingen"\nMSG_PT[$MSG_CANT_PING_EXTERNAL_IP]="!!! CND0180I: O sistema n\xc3\xa3o consegue dar ping no IP %1"\nMSG_PL[$MSG_CANT_PING_EXTERNAL_IP]="!!! CND0180I: Komenda ping nie mo\xc5\xbce dotrze\xc4\x87 do zewn\xc4\x99trznego adresu IP %1"\nMSG_POSSIBLE_WLAN_FIRMWARE_PROBLEMS=309\nMSG_EN[$MSG_POSSIBLE_WLAN_FIRMWARE_PROBLEMS]="!!! CND0190E: WLAN firmware is missing or cannot be loaded"\nMSG_FR[$MSG_POSSIBLE_WLAN_FIRMWARE_PROBLEMS]="!!! CND0190E: Le firmware pour WLAN est absent ou ne peut pas \xc3\xaatre charg\xc3\xa9"\nMSG_CS[$MSG_POSSIBLE_WLAN_FIRMWARE_PROBLEMS]="!!! CND0190E: Chyb\xc3\xad nebo nemohu nahr\xc3\xa1t WLAN firmware"\nMSG_DE[$MSG_POSSIBLE_WLAN_FIRMWARE_PROBLEMS]="!!! CND0190E: WLAN Firmware fehlt oder kann nicht geladen werden"\nMSG_PT[$MSG_POSSIBLE_WLAN_FIRMWARE_PROBLEMS]="!!! CND0190E: O firmware da rede sem fio est\xc3\xa1 faltando ou n\xc3\xa3o pode ser carregado"\nMSG_PL[$MSG_POSSIBLE_WLAN_FIRMWARE_PROBLEMS]="!!! CND0190E: Brak firmware dla WLAN b\xc4\x85d\xc5\xba nie mo\xc5\xbce on zosta\xc4\x87 za\xc5\x82adowany"\nMSG_POSSIBLE_MTU_PROBLEMS=310\nMSG_EN[$MSG_POSSIBLE_MTU_PROBLEMS]="!!! CND0200W: Maximum possible MTU is %1, but actual MTU on nic %2 is %3"\nMSG_FR[$MSG_POSSIBLE_MTU_PROBLEMS]="!!! CND0200W: Le MTU maximum possible est de %1, mais le MTU r\xc3\xa9el sur la plaque r\xc3\xa9seau %2 est de %3"\nMSG_CS[$MSG_POSSIBLE_MTU_PROBLEMS]="!!! CND0200W: Maximum mo\xc5\xben\xc3\xa9ho MTU je %1, ale nyn\xc4\x9bj\xc5\xa1\xc3\xad MTU na kart\xc4\x9b %2 je %3"\nMSG_DE[$MSG_POSSIBLE_MTU_PROBLEMS]="!!! CND0200W: Die maximal ermittelte MTU ist %1, aber die aktuelle MTU an der Netzwerkkarte %2 ist %3"\nMSG_PT[$MSG_POSSIBLE_MTU_PROBLEMS]="!!! CND0200W: O MTU m\xc3\xa1ximo \xc3\xa9 %1, mas o MTU real na placa de rede %2 \xc3\xa9 %3"\nMSG_PL[$MSG_POSSIBLE_MTU_PROBLEMS]="!!! CND0200W: Maksymalne mo\xc5\xbcliwe MTU wynosi %1, lecz aktualnie ustawione na karcie %2 jest %3"\nMSG_APIPA_DETECTED=311\nMSG_EN[$MSG_APIPA_DETECTED]="!!! CND0210W: APIPA IP address %1 detected on network card %2"\nMSG_FR[$MSG_APIPA_DETECTED]="!!! CND0210W: Adresse IP APIPA  %1 d\xc3\xa9tect\xc3\xa9e sur la carte r\xc3\xa9seau %2"\nMSG_CS[$MSG_APIPA_DETECTED]="!!! CND0210W: APIPA IP adresa %1 detekov\xc3\xa1na na s\xc3\xad\xc5\xa5ov\xc3\xa9 kart\xc4\x9b %2"\nMSG_DE[$MSG_APIPA_DETECTED]="!!! CND0210W: APIPA IP Adresse %1 wurde an Netzwerkkarte %2 entdeckt"\nMSG_PT[$MSG_APIPA_DETECTED]="!!! CND0210W: Endere\xc3\xa7o IP %1 APIPA detectado na placa de rede %2"\nMSG_PL[$MSG_APIPA_DETECTED]="!!! CND0210W: Na karcie %2 przydzielony jest awaryjny automatyczny adres sieciowy (APIPA)"\nMSG_NIC_ERRORS=312\nMSG_EN[$MSG_NIC_ERRORS]="!!! CND0220W: Serious transmission errors on network interface %1 detected"\nMSG_FR[$MSG_NIC_ERRORS]="!!! CND0220W: Erreurs graves de transmission sur l\'interface de r\xc3\xa9seau %1 d\xc3\xa9tect\xc3\xa9e"\nMSG_CS[$MSG_NIC_ERRORS]="!!! CND0220W: Objevily se v\xc3\xa1\xc5\xben\xc3\xa9 p\xc5\x99enosov\xc3\xa9 chyby v s\xc3\xad\xc5\xa5ov\xc3\xa9m rozhran\xc3\xad %1 "\nMSG_DE[$MSG_NIC_ERRORS]="!!! CND0220W: Ungew\xc3\xb6hnlich viele \xc3\x9cbertragungsfehler am Interface %1 entdeckt"\nMSG_PT[$MSG_NIC_ERRORS]="!!! CND0220W: Erros s\xc3\xa9rios de transmiss\xc3\xa3o detectados na placa de rede %1"\nMSG_PL[$MSG_NIC_ERRORS]="!!! CND0220W: Na urz\xc4\x85dzeniu %1 wykryto powa\xc5\xbcne b\xc5\x82\xc4\x99dy transmisji"\nMSG_IPV6_DETECTED=313\nMSG_EN[$MSG_IPV6_DETECTED]="!!! CND0230W: IPV6 enabled and may be the reason for network problems"\nMSG_FR[$MSG_IPV6_DETECTED]="!!! CND0230W: IPV6 activ\xc3\xa9"\nMSG_CS[$MSG_IPV6_DETECTED]="!!! CND0230W: IPV6 povolen\xc3\xa9"\nMSG_DE[$MSG_IPV6_DETECTED]="!!! CND0230W: IPV6 ist eingeschaltet und kann der Grund f\xc3\xbcr Netzwerkprobleme sein"\nMSG_PT[$MSG_IPV6_DETECTED]="!!! CND0230W: IPV6 habilitado"\nMSG_PL[$MSG_IPV6_DETECTED]="!!! CND0230W: W\xc5\x82\xc4\x85czony protok\xc3\xb3\xc5\x82 IPV6"\nMSG_KNETWORKMANAGER_ERROR=314\nMSG_EN[$MSG_KNETWORKMANAGER_ERROR]="!!! CND0240E: networkmanager for network configuration enabled but a YAST network card configuration for %1 exist"\nMSG_FR[$MSG_KNETWORKMANAGER_ERROR]="!!! CND0240E: le networkmanager pour configuration du r\xc3\xa9seau est actif, mais il existe une configuration YAST de carte r\xc3\xa9seau pour %1"\nMSG_CS[$MSG_KNETWORKMANAGER_ERROR]="!!! CND0240E: networkmanager pro s\xc3\xad\xc5\xa5ovou konfiguraci je povolen, ale existuje YAST konfigurace s\xc3\xad\xc5\xa5ov\xc3\xa9 karty pro %1 "\nMSG_DE[$MSG_KNETWORKMANAGER_ERROR]="!!! CND0240E: networkmanager wird f\xc3\xbcr die Netzwerkkonfiguration benutzt aber eine YAST Netzwerkkartenkonfiguration f\xc3\xbcr %1 existiert"\nMSG_E[$MSG_KNETWORKMANAGER_ERROR]="!!! CND0240E: networkmanager for network configuration enabled but a YAST network card configuration for %1 exist"\nMSG_PL[$MSG_KNETWORKMANAGER_ERROR]="!!! CND0240E: networkmanager jest w\xc5\x82\xc4\x85czony ale jednocze\xc5\x9bnie karta sieciowa %1 jest skonfigurowana poprzez YAST"\nMSG_CANT_LOOKUP_EXTERNAL_DNS=315\nMSG_EN[$MSG_CANT_LOOKUP_EXTERNAL_DNS]="!!! CND0250E: The system can\'t lookup external DNS name %1"\nMSG_FR[$MSG_CANT_LOOKUP_EXTERNAL_DNS]="!!! CND0250E: Le syst\xc3\xa8me ne peut pas rechercher le DNS externe %1 "\nMSG_CS[$MSG_CANT_LOOKUP_EXTERNAL_DNS]="!!! CND0250E: System nem\xc5\xaf\xc5\xbee vyhledat extern\xc3\xad DNS jm\xc3\xa9no %1"\nMSG_DE[$MSG_CANT_LOOKUP_EXTERNAL_DNS]="!!! CND0250E: Das System kann den externen Namen %1 nicht aufl\xc3\xb6sen"\nMSG_PT[$MSG_CANT_LOOKUP_EXTERNAL_DNS]="!!! CND0250E: O sistema n\xc3\xa3o consegue resolver o nome DNS externo %1"\nMSG_PL[$MSG_CANT_LOOKUP_EXTERNAL_DNS]="!!! CND0250E: Nie mo\xc5\xbcna odpyta\xc4\x87 zewn\xc4\x99trznego serwera nazw (DNS) %1"\nMSG_NDISWRAPPER_PROB=316\nMSG_EN[$MSG_NDISWRAPPER_PROB]="!!! CND0260E: ndiswrapper for %1 can\'t be used in parallel with linux native driver %2"\nMSG_FR[$MSG_NDISWRAPPER_PROB]="!!! CND0260E: ndiswrapper pour %1 ne peut pas \xc3\xaatre utilis\xc3\xa9 en parall\xc3\xa8le avec le pilote Linux natif %2"\nMSG_CS[$MSG_NDISWRAPPER_PROB]="!!! CND0260E: ndiswrapper pro %1 nem\xc5\xaf\xc5\xbee b\xc3\xbdt pou\xc5\xbeit paraleln\xc4\x9b s linuxov\xc3\xbdm vlastn\xc3\xadm ovlada\xc4\x8dem %2"\nMSG_DE[$MSG_NDISWRAPPER_PROB]="!!! CND0260E: ndiswrapper f\xc3\xbcr %1 kann nicht gemeinsam mit dem linux Treiber %2 benutzt werden"\nMSG_PT[$MSG_NDISWRAPPER_PROB]="!!! CND0260E: ndiswrapper para %1 n\xc3\xa3o pode ser usado junto com o driver nativo do Linux %2"\nMSG_PL[$MSG_NDISWRAPPER_PROB]="!!! CND0260E: ndsiwrpaper dla %1 nie mo\xc5\xbce by\xc4\x87 u\xc5\xbcyty razem z natywnym sterownikiem dla linuxa %2"\nMSG_NDISWRAPPER_FW_PROB=317\nMSG_EN[$MSG_NDISWRAPPER_FW_PROB]="!!! CND0270E: Used windows driver %1 was either not installed completely (e.g. sys files are missing)\\n--- or is from a wrong windows version (e.g. Win 98 instead of XP)"\nMSG_FR[$MSG_NDISWRAPPER_FW_PROB]="!!! CND0270E: Le pilote Windows %1 n\'est soit pas install\xc3\xa9 compl\xc3\xa8tement (fichiers syst\xc3\xa8me manquants, par exemple) \\ n --- ou provient d\'une version incorrecte de Windows (par exemple, 98 au lieu de Win XP)"\nMSG_CS[$MSG_NDISWRAPPER_FW_PROB]="!!! CND0270E: Pou\xc5\xbeit\xc3\xbd windows ovlad\xc4\x8d %1 je ne\xc3\xbapln\xc4\x9b nainstalov\xc3\xa1n (nap\xc5\x99. chyb\xc3\xad sys soubory)\\n--- nebo je ze \xc5\xa1patn\xc3\xa9 windows verzi (nap\xc5\x99. Win 98 nam\xc3\xadsto XP)"\nMSG_DE[$MSG_NDISWRAPPER_FW_PROB]="!!! CND0270E: Der verwendete Windowstreiber %1 wurde entweder nicht vollst\xc3\xa4ndig installiert (Treiberbestandteile fehlen z.B. sys Dateien)\\n--- oder ist von der falschen Windows-Version (z.B. Win 98 statt XP)"\nMSG_PT[$MSG_NDISWRAPPER_FW_PROB]="!!! CND0270E: O driver Windows %1 usado n\xc3\xa3o foi instalado completamente (p. ex. arquivos .sys faltando)\\n--- ou s\xc3\xa3o de uma vers\xc3\xa3o windows incompat\xc3\xadvel (p. ex. Win 98 em vez de XP)"\nMSG_PL[$MSG_NDISWRAPPER_FW_PROB]="!!! CND0270E: U\xc5\xbcywany sterownik Windows %1 nie zosta\xc5\x82 w ca\xc5\x82o\xc5\x9bci zainstalowany (np. brak niekt\xc3\xb3rych plik\xc3\xb3w systemowych)\\n--- b\xc4\x85d\xc5\xba jest ze z\xc5\x82ej wersji Windows (np. Win98 zamiast XP)"\nMSG_NDISWRAPPER_ARCH_PROB=318\nMSG_EN[$MSG_NDISWRAPPER_ARCH_PROB]="!!! CND0280E: Incompatible windows driver architecture of %1 and Linux architecture (32 bit and 64 bit architecture mixed)"\nMSG_FR[$MSG_NDISWRAPPER_ARCH_PROB]="!!! CND0280E: Les architectures du pilote Windows de %1 et de Linux sont incompatibles (m\xc3\xa9lange d\'architectures 32 bits et 64 bits)"\nMSG_CS[$MSG_NDISWRAPPER_ARCH_PROB]="!!! CND0280E: Nekompatibiln\xc3\xad architektura windows ovlada\xc4\x8de %1 a Linux architektury (32 bit a 64 bit sm\xc3\xadchan\xc3\xa9 architektury)"\nMSG_DE[$MSG_NDISWRAPPER_ARCH_PROB]="!!! CND0280E: Inkompatible Windowstreiber Architektur von %1 und Linux Architektur (32 Bit und 64 Bit Architektur gemischt)"\nMSG_PT[$MSG_NDISWRAPPER_ARCH_PROB]="!!! CND0280E: Arquiteturas incompat\xc3\xadveis dos drivers Windows %1 e Linux (32 bits e 64 bits misturadas)"\nMSG_PL[$MSG_NDISWRAPPER_ARCH_PROB]="!!! CND0280E: Wersja sterownik\xc3\xb3w Windows %1 niekompatybilna z architektur\xc4\x85 Linuxa (Wymieszana architektura 32- i 64 bitowa)"\nMSG_NO_NIC_CONFIG_FOUND=319\nMSG_EN[$MSG_NO_NIC_CONFIG_FOUND]="!!! CND0290E: No network configuration found for interface %1"\nMSG_FR[$MSG_NO_NIC_CONFIG_FOUND]="!!! CND0290E: Configuration r\xc3\xa9seau introuvable pour l\'interface %1"\nMSG_CS[$MSG_NO_NIC_CONFIG_FOUND]="!!! CND0290E: Nena\xc5\xa1la se \xc5\xbe\xc3\xa1dn\xc3\xa1 s\xc3\xad\xc5\xa5ov\xc3\xa1 konfigurace pro rozhran\xc3\xad %1"\nMSG_DE[$MSG_NO_NIC_CONFIG_FOUND]="!!! CND0290E: Keine Netzwerkkonfiguration f\xc3\xbcr Interface %1 gefunden"\nMSG_PT[$MSG_NO_NIC_CONFIG_FOUND]="!!! CND0290E: Nenhuma configura\xc3\xa7\xc3\xa3o de rede encontrada para a interface %1"\nMSG_PL[$MSG_NO_NIC_CONFIG_FOUND]="!!! CND0290E: Nie znaleziono konfiguracji dla urz\xc4\x85dzenia %1"\nMSG_NO_DHCP_FOUND=320\nMSG_EN[$MSG_NO_DHCP_FOUND]="!!! CND0300E: No dhcp server found on interface %1"\nMSG_FR[$MSG_NO_DHCP_FOUND]="!!! CND0300E: Pas trouv\xc3\xa9 de serveur dhcp sur l\'interface %1"\nMSG_CS[$MSG_NO_DHCP_FOUND]="!!! CND0300E: Nena\xc5\xa1el se DHCP server found pro rozhran\xc3\xad %1"\nMSG_DE[$MSG_NO_DHCP_FOUND]="!!! CND0300E: Keinen dhcp Server am Interface %1 gefunden"\nMSG_PT[$MSG_NO_DHCP_FOUND]="!!! CND0300E: Nenhum servidor DHCP encontrado na interface %1"\nMSG_PL[$MSG_NO_DHCP_FOUND]="!!! CND0300E: Nie znaleziono serwera DHCP na urz\xc4\x85dzeniu %1"\nMSG_IFUP_CONFIGURED=321\nMSG_EN[$MSG_IFUP_CONFIGURED]="!!! CND0310W: Classic network configuration with ifup was detected. Configuration with networkmanager is easier"\nMSG_FR[$MSG_IFUP_CONFIGURED]="!!! CND0310W: une configuration classique de r\xc3\xa9seau par ifup a \xc3\xa9t\xc3\xa9 d\xc3\xa9tect\xc3\xa9e. La configuration par networkmanager est beaucoup plus facile"\nMSG_CS[$MSG_IFUP_CONFIGURED]="!!! CND0310W: Detekov\xc3\xa1na klasick\xc3\xa1 s\xc3\xad\xc5\xa5ov\xc3\xa1 konfigurace s ifup. Konfigurace s networkmanager-em je mnohem leh\xc4\x8d\xc3\xad"\nMSG_DE[$MSG_IFUP_CONFIGURED]="!!! CND0310W: Klassische Netzwerkkonfiguration mit ifup wurde entdeckt. Die Konfiguration mit networkmanager ist einfacher"\nMSG_PT[$MSG_IFUP_CONFIGURED]="!!! CND0310W: Configura\xc3\xa7\xc3\xa3o ifup cl\xc3\xa1ssica detectada. A configura\xc3\xa7\xc3\xa3o com o networkmanager \xc3\xa9 bem mais f\xc3\xa1cil"\nMSG_PL[$MSG_IFUP_CONFIGURED]="!!! CND0310W: Wykryto standardow\xc4\x85 konfiguracj\xc4\x99 sieciow\xc4\x85 poprzez ifup. Konfiguracja z u\xc5\xbcyciem networkmanager jest znacznie prostsza."\nMSG_WLAN_KILL_SWITCH_ON=322\nMSG_EN[$MSG_WLAN_KILL_SWITCH_ON]="!!! CND0320E: WLAN turned off by hardware or software switch"\nMSG_FR[$MSG_WLAN_KILL_SWITCH_ON]="!!! CND0320E: WLAN d\xc3\xa9sactiv\xc3\xa9 par interrupteur materiel ou logiciel"\nMSG_CS[$MSG_WLAN_KILL_SWITCH_ON]="!!! CND0320E: WLAN je vypnut\xc3\xa9 hardwarov\xc3\xa1m nebo softwarov\xc3\xbdm p\xc5\x99ep\xc3\xadna\xc4\x8dem/switch-em"\nMSG_DE[$MSG_WLAN_KILL_SWITCH_ON]="!!! CND0320E: WLAN ist mit dem Hardware oder Software Switch ausgeschaltet"\nMSG_PT[$MSG_WLAN_KILL_SWITCH_ON]="!!! CND0320E: Rede sem fio desligada por interruptor de hardware ou software"\nMSG_PL[$MSG_WLAN_KILL_SWITCH_ON]="!!! CND0320E: Sie\xc4\x87 bezprzewodowa zosta\xc5\x82a wy\xc5\x82\xc4\x85czona z poziomu sprz\xc4\x99towego b\xc4\x85d\xc5\xba programowego"\nMSG_WLAN_AUTH_PROBS=323\nMSG_EN[$MSG_WLAN_AUTH_PROBS]="!!! CND0330E: WLAN credential problems exist on interface %1"\nMSG_FR[$MSG_WLAN_AUTH_PROBS]="!!! CND0330E: Des probl\xc3\xa8mes d\'authenticit\xc3\xa9 du WLAN existent sur l\'interface %1"\nMSG_CS[$MSG_WLAN_AUTH_PROBS]="!!! CND0330E: WLAN pot\xc3\xad\xc5\xbee existuj\xc3\xad na rozhran\xc3\xad %1"\nMSG_DE[$MSG_WLAN_AUTH_PROBS]="!!! CND0330E: Es existierern Schl\xc3\xbcsselprobleme am Interface %1"\nMSG_PT[$MSG_WLAN_AUTH_PROBS]="!!! CND0330E: Problema de credenciais de rede sem fio na interface %1"\nMSG_PL[$MSG_WLAN_AUTH_PROBS]="!!! CND0330E: Na urz\xc4\x85dzeniu %1 istnieje problem z uwierzytelnianiem WLAN"\nMSG_NO_DHCP_DETECTED=324\nMSG_EN[$MSG_NO_DHCP_DETECTED]="!!! CND0350W: dhcp server may not available on interface %1"\nMSG_FR[$MSG_NO_DHCP_DETECTED]="!!! CND0350W: Serveur DHCP peut \xc3\xaatre indisponibles sur l\' interface %1"\nMSG_CS[$MSG_NO_DHCP_DETECTED]="!!! CND0350W: dhcp server m\xc5\xaf\xc5\xbee b\xc3\xbdt nedostupn\xc3\xbd na rozhran\xc3\xad %1"\nMSG_DE[$MSG_NO_DHCP_DETECTED]="!!! CND0350W: Ein dhcp Server scheint nicht am Interface %1 zu existieren"\nMSG_PT[$MSG_NO_DHCP_DETECTED]="!!! CND0350W: O servidor DHCP pode n\xc3\xa3o estar dispon\xc3\xadvel na interface %1"\nMSG_PL[$MSG_NO_DHCP_DETECTED]="!!! CND0350W: DHCP serwer mo\xc5\xbce nie by\xc4\x87 dost\xc4\x99pny dla urz\xc4\x85dzenia %1"\nMSG_WLAN_WIRED_ONLINE=325\nMSG_EN[$MSG_WLAN_WIRED_ONLINE]="!!! CND0360E: Wireless connection tested with an existing wired connection on interface %1. Unplug the cable and execute the script again"\nMSG_FR[$MSG_WLAN_WIRED_ONLINE]="!!! CND0360E: Connexion sans fil test\xc3\xa9e avec une connexion filaire existante sur interface %1. D\xc3\xa9branchez le c\xc3\xa2ble d\'interface et ex\xc3\xa9cutez le script \xc3\xa0 nouveau"\nMSG_CS[$MSG_WLAN_WIRED_ONLINE]="!!! CND0360E: Bezdr\xc3\xa1tob\xc3\xa9 p\xc5\x99ipojen\xc3\xad ostestov\xc3\xa1no s existuj\xc3\xadc\xc3\xadm dr\xc3\xa1tov\xc3\xbdm p\xc5\x99ipojen\xc3\xadm  na rozhran\xc3\xad %1. Odpojte kabel a op\xc4\x9bt spus\xc5\xa5te skript"\nMSG_DE[$MSG_WLAN_WIRED_ONLINE]="!!! CND0360E: Eine drahtlose Verbindung wurde getestet obwohl eine kabelgebundene Verbindung am Interface %1 existiert . Das Netzwerkkabel ausstecken und das Script noch einmal starten"\nMSG_PT[$MSG_WLAN_WIRED_ONLINE]="!!! CND0360E: Conex\xc3\xa3o sem fio testada com uma conex\xc3\xa3o cabeada na interface %1. Desconecte o cabo e execute o script novamente"\nMSG_PL[$MSG_WLAN_WIRED_ONLINE]="!!! CND0360E: Testy po\xc5\x82\xc4\x85czenia bezprzewodowego przeprowadzone z istniej\xc4\x85cym po\xc5\x82\xc4\x85czeniem sieciowym na urz\xc4\x85dzeniu %1. Prosz\xc4\x99 od\xc5\x82\xc4\x85cz kabel sieciowy i uruchom skrypt ponownie"\nMSG_CANT_PING_EXTERNAL_DNS=326\nMSG_EN[$MSG_CANT_PING_EXTERNAL_DNS]="!!! CND0370I: The system can\'t ping external DNS name %1"\nMSG_FR[$MSG_CANT_PING_EXTERNAL_DNS]="!!! CND0370I: Le syst\xc3\xa8me ne peut pas pinger le nom DNS externe %1"\nMSG_CS[$MSG_CANT_PING_EXTERNAL_DNS]="!!! CND0370I: System nem\xc5\xaf\xc5\xbee prov\xc3\xa9st ping test pro extern\xc3\xad DNS jm\xc3\xa9no %1"\nMSG_DE[$MSG_CANT_PING_EXTERNAL_DNS]="!!! CND0370I: Das System kann den externen DNS Namen %1 nicht pingen"\nMSG_PT[$MSG_CANT_PING_EXTERNAL_DNS]="!!! CND0370I: O sistema n\xc3\xa3o consegue dar ping no nome DNS externo %1"\nMSG_PL[$MSG_CANT_PING_EXTERNAL_DNS]="!!! CND0370I: Serwer nazw %1 niedost\xc4\x99pny z u\xc5\xbcyciem komendy ping"\nMSG_WLAN_NO_SCAN=327\nMSG_EN[$MSG_WLAN_NO_SCAN]="!!! CND0380E: No WLANs detected on interface %1. Hardware and/or driver not configured properly"\nMSG_FR[$MSG_WLAN_NO_SCAN]="!!! CND0380E: Pas de WLANs d\xc3\xa9tect\xc3\xa9s sur l\'interface %1. Le mat\xc3\xa9riel et/ou le pilote sont mal configur\xc3\xa9s"\nMSG_CS[$MSG_WLAN_NO_SCAN]="!!! CND0380E: Nedetkov\xc3\xa1no \xc5\xbe\xc3\xa1dn\xc3\xa9 WLAN na rozhran\xc3\xad %1. Hardware a/nebo ovlada\xc4\x8d nen\xc3\xad spr\xc3\xa1vn\xc4\x9b nakonfigurovno"\nMSG_DE[$MSG_WLAN_NO_SCAN]="!!! CND0380E: Es wurden keine WLANs am Interface %1 gefunden. Die Hardware und/oder Treiber ist nicht richtig konfiguriert"\nMSG_PT[$MSG_WLAN_NO_SCAN]="!!! CND0380E: Nenhuma rede local sem fio detectada na interface %1. Hardware e/ou driver configurados erroneamente"\nMSG_PL[$MSG_WLAN_NO_SCAN]="!!! CND0380E: Nie wykryto \xc5\xbcadnych sieci bezprzewodowych na urz\xc4\x85dzeniu %1. Urz\xc4\x85dzeniu i/lub sterownik nie zosta\xc5\x82y prawid\xc5\x82owo skonfigurowane"\nMSG_HW_NO_ACTIVE=328\nMSG_EN[$MSG_HW_NO_ACTIVE]="!!! CND0390E: No loaded module detected for interface %1"\nMSG_FR[$MSG_HW_NO_ACTIVE]="!!! CND0390E: Aucun module charg\xc3\xa9 n \'est d\xc3\xa9tect\xc3\xa9 pour l\'interface %1"\nMSG_CS[$MSG_HW_NO_ACTIVE]="!!! CND0390E: Nen\xc3\xad detekov\xc3\xa1n \xc5\xbe\xc3\xa1dn\xc3\xbd nahran\xc3\xbd modul pro rozhran\xc3\xad %1"\nMSG_DE[$MSG_HW_NO_ACTIVE]="!!! CND0390E: Kein Module am Interface %1 geladen"\nMSG_PT[$MSG_HW_NO_ACTIVE]="!!! CND0390E: Nenhum m\xc3\xb3dulo carregado detectado para a interface %1"\nMSG_PL[$MSG_HW_NO_ACTIVE]="!!! CND0390E: Brak za\xc5\x82adowanego modu\xc5\x82u dla urz\xc4\x85dzenia %1"\nMSG_HW_SOME_INACTIVE=329\nMSG_EN[$MSG_HW_SOME_INACTIVE]="!!! CND0400W: Alternate modules %1 detected for interface %2"\nMSG_FR[$MSG_HW_SOME_INACTIVE]="!!! CND0400W: Modules alternatifs %1 d\xc3\xa9tect\xc3\xa9s pour l\'interface %2"\nMSG_CS[$MSG_HW_SOME_INACTIVE]="!!! CND0400W: Alternativn\xc3\xad modul %1 detekov\xc3\xa1n pro rozhran\xc3\xad %2"\nMSG_DE[$MSG_HW_SOME_INACTIVE]="!!! CND0400W: Es existieren weitere m\xc3\xb6gliche Module %1 f\xc3\xbcr Interface %2"\nMSG_PT[$MSG_HW_SOME_INACTIVE]="!!! CND0400W: M\xc3\xb3dulo alternativo %1 detectado para a interface %2"\nMSG_PL[$MSG_HW_SOME_INACTIVE]="!!! cnd0400W: Alternatywne modu\xc5\x82y %1 zosta\xc5\x82y wykryte dla urz\xc4\x85dzenia %2"\nMSG_NAMESERVER_NOT_VALID=330\nMSG_EN[$MSG_NAMESERVER_NOT_VALID]="!!! CND0410E: Configured nameserver with IP %1 is no nameserver"\nMSG_FR[$MSG_NAMESERVER_NOT_VALID]="!!! CND0410E: Le DNS configur\xc3\xa9 par l\' IP %1 n\'est pas un serveur DNS"\nMSG_CS[$MSG_NAMESERVER_NOT_VALID]="!!! CND0410E: Nakonfigurovan\xc3\xbd nameserver s IP %1 nen\xc3\xad nameserver"\nMSG_DE[$MSG_NAMESERVER_NOT_VALID]="!!! CND0410E: Der konfigurierte Nameserver mit der IP %1 ist kein Nameserver"\nMSG_PT[$MSG_NAMESERVER_NOT_VALID]="!!! CND0410E: Servidor de nomes configurado com IP %1 n\xc3\xa3o \xc3\xa9 um servidor de nomes"\nMSG_PL[$MSG_NAMESERVER_NOT_VALID]="!!! CND0410E: Serwer nazw skonfigurowany pod adresem %1 nie jest w\xc5\x82a\xc5\x9bciwym serwerem nazw"\nMSG_NAMESERVER_PROBLEM_UNKNOWN=331\nMSG_EN[$MSG_NAMESERVER_PROBLEM_UNKNOWN]="!!! CND0420E: There exists a problem with configured nameserver with IP %1"\nMSG_FR[$MSG_NAMESERVER_PROBLEM_UNKNOWN]="!!! CND0420E: Il y a un probl\xc3\xa8me avec le serveur DNS configur\xc3\xa9 avec IP %1"\nMSG_CS[$MSG_NAMESERVER_PROBLEM_UNKNOWN]="!!! CND0420E: Je probl\xc3\xa9m s nakonfigurovan\xc3\xbdm nameserver-em s IP %1"\nMSG_DE[$MSG_NAMESERVER_PROBLEM_UNKNOWN]="!!! CND0420E: Es gibt ein Problem mit dem konfigurierten Nameserver mit der IP %1"\nMSG_PT[$MSG_NAMESERVER_PROBLEM_UNKNOWN]="!!! CND0420E: Existe um problema com o servidor de nomes configurado com IP %1"\nMSG_PL[$MSG_NAMESERVER_PROBLEM_UNKNOWN]="!!! CND0420E: Wykryto problem z serwerem nazw skonfigurowanym pod adresem %1"\nMSG_NWELIZA_UNAVAILABLE=332\nMSG_EN[$MSG_NWELIZA_UNAVAILABLE]="!!! CND0430I: NWEliza doesn\'t support this Linux distribution"\nMSG_FR[$MSG_NWELIZA_UNAVAILABLE]="!!! CND0430I: NWEliza ne supporte pas cette distribution Linux"\nMSG_CS[$MSG_NWELIZA_UNAVAILABLE]="!!! CND0430I: NWEliza nepodporuje tuto Linux distribuci"\nMSG_DE[$MSG_NWELIZA_UNAVAILABLE]="!!! CND0430I: NWEliza unterst\xc3\xbctzt diese Linux distribution nicht"\nMSG_PT[$MSG_NWELIZA_UNAVAILABLE]="!!! CND0430I: NWEliza n\xc3\xa3o suporta essa distribui\xc3\xa7\xc3\xa3o Linux"\nMSG_PL[$MSG_NWELIZA_UNAVAILABLE]="!!! CND0430I: NWEliza nie jest wspierana dla tej dystrybucji"\nMSG_DISTRO_NOT_SUPPORTED=333\nMSG_EN[$MSG_DISTRO_NOT_SUPPORTED]="!!! CND0440E: This distribution is not supported"\nMSG_FR[$MSG_DISTRO_NOT_SUPPORTED]="!!! CND0440E: Cette distribution n\'est pas support\xc3\xa9e"\nMSG_CS[$MSG_DISTRO_NOT_SUPPORTED]="!!! CND0440E: Tato distribuce nen\xc3\xad podporov\xc3\xa1na"\nMSG_DE[$MSG_DISTRO_NOT_SUPPORTED]="!!! CND0440E: Diese Distribution wird leider nicht unterst\xc3\xbctzt"\nMSG_PT[$MSG_DISTRO_NOT_SUPPORTED]="!!! CND0440E: Essa distribui\xc3\xa7\xc3\xa3o n\xc3\xa3o \xc3\xa9 suportada"\nMSG_PL[$MSG_DISTRO_NOT_SUPPORTED]="!!! CND0440E: Ta dystrybucja nie jest wspierana"\nMSG_CHECK_KEYS=334\nMSG_EN[$MSG_CHECK_KEYS]="!!! CND0450W: WLAN key masquerading is not fully tested on this distribution. Please check output file %1 for visible WLAN keys and masquerade them manually"\nMSG_FR[$MSG_CHECK_KEYS]="!!! CND0450W: Le \'masquerading\' WLAN n\'est pas enti\xc3\xa8rement test\xc3\xa9 sur cette distribution. S\'il vous pla\xc3\xaet v\xc3\xa9rifiez sur le fichier de sortie %1 les cl\xc3\xa9s WLAN visibles et \'mascaradez\' manuellement"\nMSG_CS[$MSG_CHECK_KEYS]="!!! CND0450W: WLAN masquerading kl\xc3\xad\xc4\x8d nen\xc3\xad zcela otestov\xc3\xa1n na t\xc3\xa9to distribuci. Pros\xc3\xadm, zkontrolujte v\xc3\xbdsledn\xc3\xbd soubor %1 pro viditeln\xc3\xa9 WLAN kl\xc3\xad\xc4\x8de a zamaskujte je manu\xc3\xa1ln\xc4\x9b"\nMSG_DE[$MSG_CHECK_KEYS]="!!! CND0450W: WLAN Schl\xc3\xbcsselmaskierung ist nicht vollst\xc3\xa4ndig auf dieser Distribution getestet. Bitte das Ausgabefile %1 nach sichtbaren WLAN Schl\xc3\xbcsseln absuchen und manuell maskieren"\nMSG_PT[$MSG_CHECK_KEYS]="!!! CND0450W: O mascaramento da chave de rede sem fio n\xc3\xa3o est\xc3\xa1 completamente testado nessa distribui\xc3\xa7\xc3\xa3o. Cheque o arquivo %1 e mascare chaves vis\xc3\xadveis manualmente"\nMSG_PL[$MSG_CHECK_KEYS]="!!! CND0450W: Maskowania kluczy WLAN dla tej dystrybucji nie zosta\xc5\x82o w pe\xc5\x82ni przetestowane. Prosz\xc4\x99 sprawd\xc5\xba plik z wynikami %1 czy s\xc4\x85 tam zapisane klucze WLAN i zamaskuj je r\xc4\x99cznie."\nMSG_NO_ANALYSIS_AS_USER=335\nMSG_EN[$MSG_NO_ANALYSIS_AS_USER]="!!! CND0460I: Analysis of %1 only possible if script is invoked as root"\nMSG_FR[$MSG_NO_ANALYSIS_AS_USER]="!!! CND0460I: L\'analyse de %1 est seulement possible si le script est invoqu\xc3\xa9 en tant que root"\nMSG_CS[$MSG_NO_ANALYSIS_AS_USER]="!!! CND0460I: Anal\xc3\xbdza %1 je mo\xc5\xben\xc3\xa1 pouze pokud je skript spu\xc5\xa1t\xc4\x9bn jako root"\nMSG_DE[$MSG_NO_ANALYSIS_AS_USER]="!!! CND0460I: Analyse von %1 nur m\xc3\xb6glich wenn das Script als root aufgerufen wird"\nMSG_PT[$MSG_NO_ANALYSIS_AS_USER]="!!! CND0460I: An\xc3\xa1lise de %1 s\xc3\xb3 \xc3\xa9 poss\xc3\xadvel se o script for executado como root"\nMSG_PL[$MSG_NO_ANALYSIS_AS_USER]="!!! CND0460I: Analiza %1 jest mo\xc5\xbcliwa tylko je\xc5\xbceli skrypt zosta\xc5\x82 uruchomiony jako u\xc5\xbcytkownik root"\nMSG_ANALYSIS_AS_USER=336\nMSG_EN[$MSG_ANALYSIS_AS_USER]="!!! CND0470I: Reduced analysis capability and less network information because script was not invoked as root"\nMSG_FR[$MSG_ANALYSIS_AS_USER]="!!! CND0470I: Capacit\xc3\xa9 d\'analyse r\xc3\xa9duite et moins d\'informations de r\xc3\xa9seau parce que le script n\'a pas \xc3\xa9t\xc3\xa9 invoqu\xc3\xa9 en tant que root"\nMSG_CS[$MSG_ANALYSIS_AS_USER]="!!! CND0470I: Anal\xc3\xbdza redukov\xc3\xa1na a m\xc3\xa9n\xc4\x9b s\xc3\xad\xc5\xa5ov\xc3\xbdch informac\xc3\xad, proto\xc5\xbee skript nebyl spu\xc5\xa1t\xc4\x9bn jako root"\nMSG_DE[$MSG_ANALYSIS_AS_USER]="!!! CND0470I: Reduzierte Analysef\xc3\xa4higkeit und weniger Netzwerkinformationen da das Script nicht als root ausgef\xc3\xbchrt wurde"\nMSG_PT[$MSG_ANALYSIS_AS_USER]="!!! CND0470I: Capacidade reduzida de an\xc3\xa1lise e menos informa\xc3\xa7\xc3\xb5es de rede porque o script n\xc3\xa3o foi executado como root"\nMSG_PL[$MSG_ANALYSIS_AS_USER]="!!! CND0470I: Poniewa\xc5\xbc skrypt nie zosta\xc5\x82 uruchomiony z prawami roota wiarygodno\xc5\x9b\xc4\x87 analizy oraz ilo\xc5\x9b\xc4\x87 informacji zosta\xc5\x82y obni\xc5\xbcone"\nMSG_MISSING_LINK=337\nMSG_EN[$MSG_MISSING_LINK]="!!! CND0480W: No link detected on interface %1"\nMSG_FR[$MSG_MISSING_LINK]="!!! CND0480W: Pas de lien d\xc3\xa9tect\xc3\xa9 sur l\'interface %1"\nMSG_CS[$MSG_MISSING_LINK]="!!! CND0480W: Nne\xc3\xad deetekov\xc3\xa1no \xc5\xbe\xc3\xa1dn\xc3\xa9 spojen\xc3\xad na rozhran\xc3\xad %1"\nMSG_DE[$MSG_MISSING_LINK]="!!! CND0480W: Es wurde kein Linksignal auf Interface %1 entdeckt"\nMSG_PT[$MSG_MISSING_LINK]="!!! CND0480W: Nenhuma conex\xc3\xa3o detectada na interface %1"\nMSG_PL[$MSG_MISSING_LINK]="!!! CND0480W: Brak po\xc5\x82\xc4\x85czenia na urz\xc4\x85dzeniu %1"\nMSG_WLAN_NO_SSID_IN_SCAN_FOUND=338\nMSG_EN[$MSG_WLAN_NO_SSID_IN_SCAN_FOUND]="!!! CND0490E: No access point with your SSID detected on interface %1"\nMSG_FR[$MSG_WLAN_NO_SSID_IN_SCAN_FOUND]="!!! CND0490E: Aucun point d\'acc\xc3\xa8s avec votre SSID d\xc3\xa9tect\xc3\xa9 sur l\'interface %1"\nMSG_CS[$MSG_WLAN_NO_SSID_IN_SCAN_FOUND]="!!! CND0490E: Nen\xc3\xad detekov\xc3\xa1n \xc5\xbe\xc3\xa1dny p\xc5\x99\xc3\xadstupov\xc3\xbd bod s va\xc5\xa1im SSID  na rozhran\xc3\xad %1"\nMSG_DE[$MSG_WLAN_NO_SSID_IN_SCAN_FOUND]="!!! CND0490E: Kein Accesspoint mit der benutzen SSID auf dem Interface %1 gefunden"\nMSG_PT[$MSG_WLAN_NO_SSID_IN_SCAN_FOUND]="!!! CND0490E: Nenhum ponto de acesso com sua SSID detectado na interface %1"\nMSG_PL[$MSG_WLAN_NO_SSID_IN_SCAN_FOUND]="!!! CND0490E: Nie znaleziono punktu dost\xc4\x99powego z podan\xc4\x85 nazw\xc4\x85 (SSID) dla urz\xc4\x85dzenia %1"\nMSG_SSID_SAME_CHANNEL=339\nMSG_EN[$MSG_SSID_SAME_CHANNEL]="!!! CND0500W: Channel %1 used by your accesspoint is also used by %2 other access points"\nMSG_FR[$MSG_SSID_SAME_CHANNEL]="!!! CND0500W: Canal %1 utilis\xc3\xa9 par votre point d\'acc\xc3\xa8s est \xc3\xa9galement utilis\xc3\xa9e par %2 autres points d\'acc\xc3\xa8s"\nMSG_CS[$MSG_SSID_SAME_CHANNEL]="!!! CND0500W: Kan\xc3\xa1l %1 pou\xc5\xbeit\xc3\xbd va\xc5\xa1im p\xc5\x99\xc3\xadstupov\xc3\xbdm bodem je tak\xc3\xa9 pou\xc5\xbeit %2 ostatn\xc3\xadmi p\xc5\x99\xc3\xadstup. body"\nMSG_DE[$MSG_SSID_SAME_CHANNEL]="!!! CND0500W: Der Kanal %1, der vom eigenen Accesspoint benutzt wird, wird von %2 weiteren Accesspoints genutzt"\nMSG_PT[$MSG_SSID_SAME_CHANNEL]="!!! CND0500W: O canal %1 usado por seu ponto de acesso tamb\xc3\xa9m \xc3\xa9 usado por %2 outros pontos de acesso"\nMSG_PL[$MSG_SSID_SAME_CHANNEL]="!!! CND0500W: Kana\xc5\x82 %1 u\xc5\xbcywany przez Tw\xc3\xb3j punkt dost\xc4\x99powy jest wykorzystywany r\xc3\xb3wnie\xc5\xbc %2 innych punkt\xc3\xb3w"\nMSG_SSID_INTERFERENCES=340\nMSG_EN[$MSG_SSID_INTERFERENCES]="!!! CND0510W: Channel %1 used by your accesspoint interferes with %2 adjacent access points"\nMSG_FR[$MSG_SSID_INTERFERENCES]="!!! CND0510W: Canal %1 utilis\xc3\xa9 par votre point d\'acc\xc3\xa8s interf\xc3\xa8re avec %2 des points d\'acc\xc3\xa8s adjacents"\nMSG_CS[$MSG_SSID_INTERFERENCES]="!!! CND0510W: Kan\xc3\xa1l %1 pou\xc5\xbeit\xc3\xbd va\xc5\xa1im p\xc5\x99\xc3\xadstupov\xc3\xbdm bodem se m\xc3\xadch\xc3\xa1 s %2 soused\xc3\xadc\xc3\xadmi p\xc5\x99\xc3\xadstup. body"\nMSG_DE[$MSG_SSID_INTERFERENCES]="!!! CND0510W: Der Kanal %1, der vom eigenen Accesspoint benutzt wird, wird von %2 benachbarten Access Points \xc3\xbcberlagert"\nMSG_PT[$MSG_SSID_INTERFERENCES]="!!! CND0510W: O canal %1 usado por seu ponto de acesso interfere com %2 pontos de acesso adjacentes"\nMSG_PL[$MSG_SSID_INTERFERENCES]="!!! CND0510W: Kana\xc5\x82 %1 u\xc5\xbcywany przez tw\xc3\xb3j punkt dost\xc4\x99powy interferuje z %2 innymi punktami dost\xc4\x99powymi"\nMSG_NO_WPA_SUPPLICANT_ACTIVE=341\nMSG_EN[$MSG_NO_WPA_SUPPLICANT_ACTIVE]="!!! CND0520W: wpa_supplicant is not active"\nMSG_FR[$MSG_NO_WPA_SUPPLICANT_ACTIVE]="!!! CND0520W: Le wpa_supplicant n\'est pas actif"\nMSG_CS[$MSG_NO_WPA_SUPPLICANT_ACTIVE]="!!! CND0520W: wpa_supplicant nen\xc3\xad aktivn\xc3\xad"\nMSG_DE[$MSG_NO_WPA_SUPPLICANT_ACTIVE]="!!! CND0520W: wpa_supplicant ist nicht aktiv"\nMSG_PT[$MSG_NO_WPA_SUPPLICANT_ACTIVE]="!!! CND0520W: wpa-supplicant n\xc3\xa3o est\xc3\xa1 ativo"\nMSG_PL[$MSG_NO_WPA_SUPPLICANT_ACTIVE]="!!! CND0520W: wpa_supplicant nie jest aktywny"\nMSG_ENL80211L=342\nMSG_EN[$MSG_ENL80211L]="!!! CND0530E: Module %1 requires WIRELESS_WPA_DRIVER=\'wext\' to be configured"\nMSG_DE[$MSG_ENL80211L]="!!! CND0530E: Module %1 erfordert die Konfiguration von WIRELESS_WPA_DRIVER=\'wext\'"\nMSG_NIC_DROPPED=343\nMSG_EN[$MSG_NIC_DROPPED]="!!! CND0540W: Messages dropped on network interface %1"\nMSG_DE[$MSG_NIC_DROPPED]="!!! CND0540W: Messages wurden am Netzwerkinterface %1 verworfen"\nMSG_NO_NIC_FOUND_WARNING=344\nMSG_EN[$MSG_NO_NIC_FOUND_WARNING]="!!! CND0550W: Unable to detect USB network card for the selected connection type"\nMSG_DE[$MSG_NO_NIC_FOUND_WARNING]="!!! CND0550W: F\xc3\xbcr den gew\xc3\xa4hlten Netzwerkverbindungstyp konnte keine USB Netzwerkarte gefunden werden"\nMSG_INVALID_SSID=345\nMSG_EN[$MSG_INVALID_SSID]="!!! CND0560E: Invalid characters in SSIDs detected"\nMSG_DE[$MSG_INVALID_SSID]="!!! CND0560E: Es befinden sich ung\xc3\xbcltige Zeichen in der SSID"\n\n#################################################################################\n# Debug helper\n#################################################################################\n\nfunction debug() { # message\n   if [[ $DEBUG == "on" ]];  then\n      echo "@@@ $1 $2 $3 $4 $5 $6 $7 $8 $9 ${10}"\n   fi\n}\n\nfunction state() { # message\n   echo "${1}${2}${3}${4}${5}${6}${7}${8}${9}${10}" >> $STATE\n}\n\n########################################################################\n#\n# --- Check if a command was detected on the system \n#\n########################################################################\n\nfunction isCommandAvailable() {\t\t# $1: command\n\n      local ucCmd\t  \n      local rc \n      ucCMD=`echo $1 | perl -e "print uc(<>);"`\n   \n      if [[ "${!ucCMD}" == "" ]]; then\n\t rc=1\n      else\n\t rc=0\n      fi\n\n      return $rc\n\n}\n\n#################################################################################\n# message & console handling\n#################################################################################\n\n# --- Writes a message to the console without an NL\n\nfunction writeToConsoleNoNL() {   # messagenumber\n   local msg\n   msg=`getLocalizedMessage $*`\n   if [[ $GUI -eq 0 ]]; then\n\t   echo -ne $msg >> /dev/tty\n   else\n\t   echo -ne $msg >> $CONSOLE_RESULT\n\t   echo -ne $msg\n   fi\n}\n\n# --- Writes a message to the console\n\nfunction writeToConsole() {   # messagenumber\n   local msg\n   msg=`getLocalizedMessage $*`\n   if [[ $GUI -eq 0 ]]; then\n\t   echo -e $msg >> /dev/tty\n   else\n\t   echo -e $msg >> $CONSOLE_RESULT\n\t   echo -e $msg\n   fi\n}\n\n# --- Creates a progress bar on the console\n\nfunction processingMessage() { #number #maxnumber #activity\n   local c\n   local ip\n   local p\n   local m\n\n   if (( $GUI )); then\n\treturn\n   fi\n\n   m=$1\n   echo -ne "\\r                                               \\r" >> /dev/tty\n   if [[ $m -ge 0 ]]; then\n      let p=$m*100/$2\n      echo -n "($p%) "\n   fi\n}\n\nfunction progress() {\n\n   if [ "$1" != "" ]; then \n      echo -ne "\\bDone " \n   fi\n\n   PROGRESS_CHARS="|/-\\\\"\n   if [[ $PROGRESS_CHAR == "" || $PROGRESS_I > "3" ]]; then\n      PROGRESS_I=0\n   fi\n   PROGRESS_CHAR=${PROGRESS_CHARS:$PROGRESS_I:1}\n   let PROGRESS_I++\n   echo -en "\\b$PROGRESS_CHAR"\n   }\n\n# ---Writes a messages to the NWEliza log and console\n\nfunction writeToEliza() {   # messagenumber\n   local severity\n\n   local msg\n   msg=`getTargetMessage $*`\n   echo -e $msg >> "$ELIZA_RESULT"\n   msg=`getLocalizedMessage $*`\n   if [[ $GUI -eq 0 ]]; then\n\techo -e $msg >> /dev/tty\n   else\n\techo -e $msg\n   fi\n\n   severity=`echo $msg | cut -d " " -f 2`\n\n   if [[ `echo $severity | $EGREP "CND[0-9]+E"` ]]; then\n      let askEliza_error=$askEliza_error+1\n   fi\n\n   if [[ `echo $severity | $EGREP "CND[0-9]+W"` ]]; then\n      let askEliza_warning=$askEliza_warning+1\n   fi\n}\n\n# ---Writes a messages to the NWEliza log\n\nfunction writeToElizaOnly() {                              # messagenumber\n   local msg\n   msg=`getTargetMessage $*`\n   echo -e $msg >> "$ELIZA_RESULT"\n}\n\n# checks whether there exists support for the given language\n#\n# returns 1 for yes and 0 for no\n\nfunction isLanguageSupported() {\n\n   LANG_EXT=`echo $LANG | tr \'[:lower:]\' \'[:upper:]\'`\n   LANG_SUFF=${LANG_EXT:0:2}\n\n   msgVar="MSG_${LANG_SUFF}"\n\n   if [[ ${!msgVar} != "" ]]; then\n      return 1\n   else\n      return 0\n   fi\n}\n\n# checks whether there exists support for the given language and the os language is not english\n#\n# returns 1 for yes and 0 for no\n\nfunction isLanguageSupportedAndNotEnglish() {\n\n   LANG_EXT=`echo $LANG | tr \'[:lower:]\' \'[:upper:]\'`\n   LANG_SUFF=${LANG_EXT:0:2}\n   if [[ $LANG_SUFF == "EN" ]]; then\n      return 0\n   fi\n\n   msgVar="MSG_${LANG_SUFF}"\n\n   if [[ ${!msgVar} != "" ]]; then\n      return 1\n   else\n      return 0\n   fi\n}\n\n# --- Helper function to extract the message text in German or English and insert message parameters\n\nfunction getLocalizedMessage() { # messageNumber parm1 parm2\n\n   msg=`getMessageText L $@`\n   echo $msg\n}\n\n# get message for target forum\n\nfunction getTargetMessage() { # messageNumber parm1 parm2\n\n   if (( $CND_INTERNATIONAL_POST )); then\n      msg=`getMessageText D $@`\n   else\n      msg=`getMessageText L $@`\n   fi\n   echo $msg\n}\n\nfunction getMessageText() {         # languageflag messagenumber parm1 parm2 ...\n   local msg\n   local p\n   local i\n   local s\n\n   if [[ $1 == "D" ]]; then\n      msg=${MSG_EN[$2]};             # default is english\n   else\n\n      LANG_EXT=`echo $LANG | tr \'[:lower:]\' \'[:upper:]\'`\n      LANG_SUFF=${LANG_EXT:0:2}\n\n      msgVar="MSG_${LANG_SUFF}"\n\n      if [[ ${!msgVar} != "" ]]; then\n         msgVar="$msgVar[$2]"\n         msg=${!msgVar}\n         if [[ $msg == "" ]]; then               # no translation found\n            msg=${MSG_EN[$2]};                      # fallback into english\n         fi\n\n      else\n         msg=${MSG_EN[$2]};                      # default is english\n      fi\n   fi\n\n   for (( i=3; $i <= $#; i++ )); do              # substitute all message parameters\n      p="${!i}"\n      let s=$i-2\n      s="%$s"\n      msg=`echo $msg | sed \'s!\'$s\'!\'$p\'!\'`\t# have to use explicit command name \n   done\n   msg=`echo $msg | perl -p -e "s/%[0-9]+//g"`      # delete trailing %n definitions\n   echo $msg\n}\n\n#################################################################################\n# --- Check whether pings are possible\n#\n# --- Ping google dns with it\'s IP address\n# --- return 1 if ip ping failed\n# --- return 0 otherwise\n#\n#################################################################################\n\nfunction checkIPPings() {\n\n   debug ">>checkIPPings"\n\n   local I\n   local PING_RES\n   local C\n   local rc=0\n\n   MY_IPS="8.8.8.8"\n\n   for I in $MY_IPS; do\n      C=`$PING -c 3 -W 3 $I 2>&1`\n      PING_RES=`echo $C | $GREP " 0%"`\n      pingRC=$?\n\n      if [[ $pingRC == 0 ]]; then\n      \t break      \n      fi\n   done\n\n   if [[ $pingRC != 0 ]]; then\n      writeToEliza $MSG_CANT_PING_EXTERNAL_IP $I\n      let rc=1\n   fi\n\n  state "PNG:$rc"\n  debug "<<checkIPPings $rc"\n\nreturn $rc\n}\n\n#################################################################################\n# --- Execute ping tests\n#\n# --- Ping www.google.com with it\'s IP address and dns name\n#################################################################################\n\nfunction pingTests() {\n   local I\n   local PING_RES\n   local C\n\n   MY_IPS="8.8.8.8"\n\n   for I in $MY_IPS; do\n      C=`$PING -c 3 -W 3 $I 2>&1`\n      PING_RES=`echo $C | $GREP " 0%"`\n      pingRC=$?\n\n      if [[ $pingRC == 0 ]]; then\n      \t break      \n      fi\n   done\n\n   if [[ $pingRC == 0 ]]; then\n      echo "Ping of $I OK"\n   else\n      echo "Ping of $I failed"\n   fi\n\n   MY_IPS="www.google.com"\n\n   for I in $MY_IPS; do\n      C="$PING -c 3 -W 3 $I"\n      PING_RES=`$C | $GREP " 0%"`\n\n      if [[ -z $PING_RES ]]; then\n         echo "Ping of $I failed"\n      else\n         echo "Ping of $I OK"\n      fi\n   done\nreturn\n}\n\n#################################################################################\n# --- Execute dhcp tests\n#\n# --- execute dhcpcd-test against interfaces\n#################################################################################\n\nfunction dhcpTests() {\n   local i\n   local C\n   local R\n\n   if [[ $DISTRO == $SUSE ]]; then\n\t  if (( $USE_ROOT )); then\n\n\t\tif [[ -z $1 ]]; then\n\n\t\t\ti=1\n\t\t\twhile [[ $i -le $INTERFACE_NO ]]; do\n\t\t\t\tif [[ $CONNECTION == $CONNECTION_WRL && ${INTERFACE_TYPE[$i]} == $CONNECTION_WRL ]] ||\n                    [[ $CONNECTION == $CONNECTION_WRD && ${INTERFACE_TYPE[$i]} == $CONNECTION_WRD ]]; then\n         #            C=`$DHCPCD_TEST -t 3 ${INTERFACE_NAME[$i]} 2>/dev/null`\n\t\t\t\t\tC=`$DHCPCD -Td -t 3 -NYRG -c /bin/true ${INTERFACE_NAME[$i]} 2>/dev/null`\n\t\t\t\t\tR=`echo $C | grep \'offered\'`\n\t\t\t\t\tif [[ $? == 0 ]]; then\n\t\t\t\t\t\techo "${INTERFACE_NAME[$i]}: DHCP server available"\n\t\t\t\t\telse\n\t\t\t\t\t\techo "${INTERFACE_NAME[$i]}: No DHCP server detected $C"\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tlet i=i+1\n\t\t\tdone\n\t\telse\n\t\t\techo "dhcpcd-test"\n\t\tfi\n\telse\n   \t\twriteToEliza $MSG_NO_ANALYSIS_AS_USER "DHCP_availability"\n\tfi\nfi\n\nreturn\n}\n\n#################################################################################\n# --- display rfkill results if rfkill is available\n#\n#################################################################################\n\nfunction listrfkill() {\n\n   if `isCommandAvailable rfkill`; then\n\n      if [[ -z $1 ]]; then\n      \t$RFKILL list wifi\n      else\n\techo "rfkill list wifi"\n   fi\nfi\n\nreturn\n}\n\n#################################################################################\n# check whether dhcp is configured either with a config file or by using networkmanager if there is no IP address\n#\n# return 0 if no dhcp was configured\n# return 1 if dhcp was configured for wired connection\n# return 2 if dhcp was configured for wireless connection\n#################################################################################\n\nfunction checkDHCP() {\n   local rc=0\n   local conf=0\n   local C\n   local R\n\n   debug ">>checkDHCP"\n\n   if (( ! $CONFIG_READABLE )); then\n   \t\twriteToEliza $MSG_NO_ANALYSIS_AS_USER "DHCP_networkmanager_usage"\n\t\treturn 0\n   fi\n\n   C=`$EGREP -i \'NETWORKMANAGER.*=.*yes\' /etc/sysconfig/network/config `\n   knme=$?\n\n   i=1\n   while [[ $i -le $INTERFACE_NO ]]; do\n      if [[ $CONNECTION == $CONNECTION_WRL && ${INTERFACE_TYPE[$i]} == $CONNECTION_WRL ]] ||\n            [[ $CONNECTION == $CONNECTION_WRD && ${INTERFACE_TYPE[$i]} == $CONNECTION_WRD ]]; then\n\n         if [[ ${INTERFACE_IP[$i]} == "" ]]; then                                           # no IP address\n            fileName="/etc/sysconfig/network/ifcfg-${INTERFACE_NAME[$i]}";\n\n            conf=0\n            if [[ -e $fileName ]]; then                                                     # exists config file?\n                  C=`$EGREP -i \'BOOTPROTO.*=.*dhcp\' $fileName 2>/dev/null`                  # dhcp configured?\n                  if [[ $? == 0 ]]; then                                                    # yes\n                     conf=1\n                  fi\n            fi\n\n            if [[ $knme == 0 && $conf == 0 ]] || [[ $knme != 0 && $conf == 1 ]]; then       # dhcp configured\n               C=`$DHCPCD_TEST -t 3 ${INTERFACE_NAME[$i]} 2>/dev/null`\n               R=`echo $C | $GREP \'offered\'`\n               if [[ $? == 1 ]]; then\n                    writeToEliza $MSG_NO_DHCP_FOUND ${INTERFACE_NAME[$i]}                   # no dhcp found\n                    if [[ $CONNECTION == $CONNECTION_WRL ]]; then\n                      rc=2\n                    else\n                      rc=1\n                    fi\n               fi\n            fi\n         fi\n      fi\n      let i=i+1\n   done\n\n   state "DHCP:$rc"\n   debug "<<checkDHCP $rc"\n\n}\n\n#################################################################################\n# --- Execute dns tests\n#\n# --- Ping www.google.com with it\'s dns name\n# --- return 1 if dns ping didn\'t get a response\n# --- return 2 if dns ping failed because of missing dns\n# --- return 0 otherwise\n#\n#################################################################################\n\nfunction checkDNS() {\n\n   debug ">>checkDNS"\n\n   local I\n   local PING_RES\n   local C\n   local rc=0\n   local name="www.google.com"\n\n# ping: unknown host www.google.com\n\n   C=`$PING -c 1 -W 3 $name 2>&1`\n   pingRC=$?\n\n   if [[ $pingRC == 2 ]]; then\n      writeToEliza $MSG_CANT_LOOKUP_EXTERNAL_DNS $name\n   elif [[ $pingRC == 1 ]]; then\n      writeToEliza $MSG_CANT_PING_EXTERNAL_DNS $name\n   fi\n\n   state "DNS:$pingRC"\n   debug "<<checkDNS $pingRC"\n\nreturn $pingRC\n}\n\n#################################################################################\n#\n# detect all interfaces available on system with ifconfig and identify wireless interfaces with iwconfig\n#\n# result: 1 based array\n# INTERFACE_NO: number of interfaces detected\n# INTERFACE_NAME: name of interface (enx, wly, ethx, wlany, ...)\n# INTERFACE_IP: ipaddress of interface (empty if no IP address found)\n# INTERFACE_IP6: ipv6 address of interface (empty if no IPV6 address found)\n# INTERFACE_MAC: mac address of interface\n# INTERFACE_WRL_NO: number of wireless interfaces detect\n# INTERFACE_RCV_ERROR: receive errors (%)\n# INTERFACE_XMT_ERROR: xmit errors (%)\n# INTERFACE_RCV_DROPPED: receive messages dropped (%)\n# INTERFACE_XMT_DROPPED: xmit messages dropped (%)\n# INTERFACE_TYPE: either $CONNECTION_WRD or $CONNECTION_WRL\n# if $INTERFACE_TYPE == $CONNECTION_WRL\n# INTERFACE_ESSID: ESSID\n# INTERFACE_MODE: mode of interface\n# INTERFACE_ACCESS_POINT: access point mac\n# INTERFACE_KEY: wireless key\n#\n# return number of interfaces found for the selected connection type\n#\n#################################################################################\n\nfunction detectInterfaces () {\n   local q\n   local i\n   local j\n   local k\n   local rc\n   local interface\n   local element\n   INTERFACE_NAME=()\n   INTERFACE_IP=()\n   INTERFACE_MAC=()\n   INTERFACE_RCV_ERROR=()\n   INTERFACE_XMT_ERROR=()\n   INTERFACE_ESSID=()\n   INTERFACE_MODE=()\n   INTERFACE_AP=()\n   INTERFACE_KEY=()\n   INTERFACE_TYPE=()\n   INTERFACE_WRL_NO=0\n   INTERFACE_WRD_NO=0\n   INTERFACE_NO=0\n\n   debug ">>detectInterfaces"\n\n#eth0      Link encap:Ethernet  HWaddr 00:1E:37:21:38:F8\n#          inet addr:192.168.0.4  Bcast:192.168.0.255  Mask:255.255.255.0\n#          inet6 addr: fe80::21e:37ff:fe21:38f8/64 Scope:Link\n#          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n#          RX packets:223 errors:0 dropped:0 overruns:0 frame:0\n#          TX packets:208 errors:0 dropped:0 overruns:0 carrier:0\n#          collisions:0 txqueuelen:100\n#          RX bytes:126331 (123.3 Kb)  TX bytes:22788 (22.2 Kb)\n#          Base address:0x3000 Memory:ee000000-ee020000\n\n   # return a list of tokens\n   # tokens separated by ?, list separated by %\n   # return number of interfaces found\n   q=`$IFCONFIG | $AWK \'  BEGIN { numberOfNics=0; result=""; }\n         /^(en|wl|eth|ath|wlan|ra).*:Ethernet/ { name = $1;\n            mac = $5\n            numberOfNics++;\n            getline;\n   # line with IPV4 infos?\n            if ($1 == "inet") {\n               match($2,"[0-9]+.[0-9]+.[0-9]+.[0-9]+")\n               ip=substr($2,RSTART,RLENGTH);\n               match($3,"[0-9]+.[0-9]+.[0-9]+.[0-9]+")\n               bc=substr($3,RSTART,RLENGTH);\n               match($4,"[0-9]+.[0-9]+.[0-9]+.[0-9]+")\n               nm=substr($4,RSTART,RLENGTH);\n               getline;\n            }\n   # line with IPV6 infos? \n\t\t\tip6=""\t\n            if (match($0,"inet6")) {      # skip inet6 address\n               match($3,".*/")\n               ip6=substr($3,RSTART,RLENGTH-1);\n            }\n            getline;\n            match($2,"[0-9]+")\n            rcv=substr($2,RSTART,RLENGTH);\n            rcv_error=0\n            if (rcv > 0) {\n               match($3,"[0-9]+")\n               rcv_err=substr($3,RSTART,RLENGTH);\n               perc=rcv_err/rcv*100;\n               rcv_error = perc\n            }\n            match($4,"[0-9]+")\n            rcv_dropped=substr($4,RSTART,RLENGTH);\n\n            getline;\n            match($2,"[0-9]+")\n            xmt=substr($2,RSTART,RLENGTH);\n            xmt_error=0\n            if (xmt > 0) {\n               match($3,"[0-9]+")\n               xmt_err=substr($3,RSTART,RLENGTH);\n               perc=xmt_err/xmt*100;\n               xmt_error=perc\n            }\n            match($4,"[0-9]+")\n            xmt_dropped=substr($4,RSTART,RLENGTH);\n\n            if ( result != "" ) {\n               result=result "%"\n            }\n            result=result name "?" mac "?" ip "?" ip6 "?" rcv_error "?" xmt_error "?" rcv_dropped "?" xmt_dropped\n            name=""\n            mac=""\n            ip=""\n            rcv_error=""\n            xmt_error=""\n            }\n         END {    print result\n            exit numberOfNics\n             }\n         \'`\n   INTERFACE_WRD_NO=$?\n   INTERFACE_NO=$INTERFACE_WRD_NO\n\n   IFS_OLD=$IFS\n   IFS="%"\n   i=0\n   for interface in $q; do\n      let i=i+1\n      INTERFACE_TYPE[$i]=$CONNECTION_WRD\n      IFS="?"\n      j=0\n      for element in $interface; do\n         case $j in\n            0) INTERFACE_NAME[$i]=$element\n               debug "Interface $element detected";;\n            1) INTERFACE_MAC[$i]=$element\n               debug "Interface ${INTERFACE_NAME[$i]}: Mac $element detected";;\n            2) INTERFACE_IP[$i]=$element\n               debug "Interface ${INTERFACE_NAME[$i]}: IP $element detected";;\n            3) INTERFACE_IP6[$i]=$element\n               debug "Interface ${INTERFACE_NAME[$i]}: IP6 $element detected";;\n            4) INTERFACE_RCV_ERROR[$i]=$element\n               debug "Interface ${INTERFACE_NAME[$i]}: RCV $element detected";;\n            5) INTERFACE_XMT_ERROR[$i]=$element\n               debug "Interface ${INTERFACE_NAME[$i]}: XMT $element detected";;\n            6) INTERFACE_RCV_DROPPED[$i]=$element\n               debug "Interface ${INTERFACE_NAME[$i]}: RCV-dropped $element detected";;\n            7) INTERFACE_XMT_DROPPED[$i]=$element\n               debug "Interface ${INTERFACE_NAME[$i]}: XMT-dropped $element detected";;\n            *) writeToElizaOnly $MSG_INTERNAL_ERROR;;\n         esac\n         let j=j+1\n      done\n   done\n   IFS=$IFS_OLD\n\n# eth0      no wireless extensions.\n\n#wlan0     unassociated  ESSID:off/any\n#          Mode:Managed  Frequency=nan kHz  Access Point: Not-Associated\n#          Bit Rate:0 kb/s   Tx-Power:16 dBm\n#          Retry limit:15   RTS thr:off   Fragment thr:off\n#          Encryption key:off\n#          Power Management:off\n#          Link Quality:0  Signal level:0  Noise level:0\n#          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0\n#          Tx excessive retries:0  Invalid misc:220   Missed beacon:0\n\n#wlan0     IEEE 802.11g  ESSID:"ESSID"\n#          Mode:Managed  Frequency:2.462 GHz  Access Point: 00:14:6C:E5:F7:1F\n#          Bit Rate:36 Mb/s   Tx-Power:15 dBm\n#          Retry limit:15   RTS thr:off   Fragment thr:off\n#          Encryption key:AAAA-BBBB-CCCC-DDDD-EEEE-FFFF-GGGG-HHHH   Security mode:open\n#          Power Management:off\n#          Link Quality=67/100  Signal level=-71 dBm  Noise level=-72 dBm\n#          Rx invalid nwid:0  Rx invalid crypt:1  Rx invalid frag:0\n#          Tx excessive retries:0  Invalid misc:240   Missed beacon:0\n\n   q=`$IWCONFIG 2>&1 | $AWK \' BEGIN { numberOfNics=0; essid=""; result=""; }\n         /^(en|wl|eth|ath|wlan|ra).*no wireless/ { next; }          # skip\n         /^(en|wl|eth|ath|wlan|ra).*/ {\n            numberOfNics++;\n            name=substr($1,1,8)   # iwconfig allows IO names > 8 chars, ifconfig allows 8 chars only\n            sub("ESSID:","",$4)\n                 if ( $4 == "off/any") {\n                     essid=""\n            }\n                 else {\n                  gsub("\\"","",$4)\n               essid=$4\n                 }\n            getline\n            sub("Mode:","",$1)\n            mode=$1\n            if ( $6 == "Not-Associated" || $6 == "None" ) {\n               ap=""\n            }\n            else {\n               ap=$6\n            }\n            getline\n            getline\n            getline\n            sub("key:","",$2)\n            if ( $2 == "off") {\n               key=""\n            }\n            else {\n               key=$2\n            }\n\n            if ( result != "" ) {\n               result=result "%"\n            }\n            result=result name "?" essid "?" mode "?" ap "?" key\n            }\n         END {    print result\n            exit numberOfNics\n             }\n         \'`\n\n   INTERFACE_WRL_NO=$?\n   debug "Number of WLAN nics detected: $INTERFACE_WRL_NO"\n   debug "iwconfig scan contents: $q"\n\n   IFS_OLD=$IFS\n   IFS="%"\n   i=0\n   for interface in $q; do\n      let i=i+1\n      IFS="?"\n      j=0\n      for element in $interface; do\n         case $j in\n            0) INTERFACE_WRL_NAME=$element;\n               debug "Interface $element detected"\n               k=1;\n               index=0\n               while [[ $k -le $INTERFACE_WRD_NO ]]; do\n               if [[ ${INTERFACE_NAME[$k]} == $INTERFACE_WRL_NAME ]]; then\n                  debug "Found match for $element"\n                  index=$k\n               fi\n               let k=k+1\n               done\n               if [[ $index -le 0 ]]; then          # HACK: no match to ifconfig\n               let INTERFACE_NO=$INTERFACE_NO+1\n               index=$INTERFACE_NO\n                  INTERFACE_NAME[$index]=$INTERFACE_WRL_NAME\n                  INTERFACE_TYPE[$index]=$CONNECTION_WRL\n               debug "Added unmatched -$element-"\n               else\n                  INTERFACE_TYPE[$index]=$CONNECTION_WRL\n               debug "Added matched -$element-"\n               fi\n               ;;\n            1) INTERFACE_ESSID[$index]=$element\n               ;;\n            2) INTERFACE_MODE[$index]=$element\n               ;;\n            3) INTERFACE_AP[$index]=$element\n               ;;\n            4) INTERFACE_KEY[$index]=$element\n               ;;\n            *) writeToElizaOnly $MSG_INTERNAL_ERROR\n               ;;\n         esac\n         let j=$j+1\n      done\n   done\n\n   IFS=$IFS_OLD\n\n# log IF states\n   local i=1\n   while [[ $i -le $INTERFACE_NO ]]; do\n      echo "IF:${INTERFACE_NAME[$i]}  IM:${INTERFACE_TYPE[$i]}" >> $STATE\n      let i=i+1\n   done\n\n   state "DI:$INTERFACE_NO"\n   debug "<<detectInterfaces $INTERFACE_NO"\n\nreturn\n\n}\n\n#################################################################################\n#\n# --- Check whether there is a eth/ath/wlan/ra network interface for the connection type available.\n# --- If yes,execute various tests on the interface\n#\n# --- Returns 2 if no IP was found\n# --- Returns 1 if no network interface was found\n# --- Returns 0 otherwise\n#\n#################################################################################\n\nfunction checkNetworkInterfaces () {\n\n   debug ">>checkNetworkInterfaces"\n\n   local q\n   local i\n   local rc=1   # no IF found\n   local rcSub\n\n   IP_ADDRESS_FOUND=0\n\n   i=1\n   while [[ $i -le $INTERFACE_NO ]]; do\n      if [[ $CONNECTION == $CONNECTION_WRL && ${INTERFACE_TYPE[$i]} == $CONNECTION_WRL ]] ||\n            [[ $CONNECTION == $CONNECTION_WRD && ${INTERFACE_TYPE[$i]} == $CONNECTION_WRD ]]; then\n\n         checkNetworkInterfaceCommon $i\n         rcSub=$?\n         state "cNiC:$i:$rcSub"\n         if [[ $rcSub == 0 ]]; then    # there is an IP address and interface\n            rc=0\n         fi\n         if [[ $rcSub == 1 ]]; then    # there is no IP address\n            rc=2\n         fi\n      fi\n      let i=i+1\n\n   done\n\n   if [[ $i == 1 ]]; then\n         writeToEliza $MSG_NO_VALID_NI_FOUND\n   fi\n\n   state "NI:$rc"\n   debug "<<checkNetworkInterfaces $rc"\n\nreturn $rc\n}\n\n#################################################################################\n#\n# Do some common checks\n#\n# return 0 if there is an ip address and return 1 if there is no IP address\n#\n#################################################################################\n\nfunction checkNetworkInterfaceCommon () { # intecheckNetworkInterfacesrfaceIndex\n\n   debug ">>checkNetworkInterfaceCommon"\n\n   local index\n   local rc=0\n   local name\n   local nibble\n\n   # check whether there is a ip address on the interface\n   # if there is an ip address check whether there are rcv and xmit errors\n\n   index=$1\n   name=${INTERFACE_NAME[${index}]}\n\n   if [[ -z ${INTERFACE_IP[${index}]} ]]; then                                 # no ip address\n      writeToEliza $MSG_NO_IP_ASSIGNED_TO_NIC $name\n      rc=1\n   else\n      nibble=`echo ${INTERFACE_IP[${index}]} | cut -d "." -f 1`         # check for APIPA address\n\n      debug "--checkForAPIPAdress"\n\n      if [[ $nibble  == 169 ]]; then\n         writeToEliza $MSG_APIPA_DETECTED ${INTERFACE_IP[${index}]} $name\n      fi\n\n      debug "--checkForRCV-XMTErrors"\n\n      if [[ ${INTERFACE_RCV_ERROR[${index}]} > $MAX_ERROR_PERCENT ]]; then      # receive errors\n         writeToEliza $MSG_NIC_ERRORS $name\n      else\n         if [[ ${INTERFACE_XMT_ERROR[${index}]} > $MAX_ERROR_PERCENT ]]; then   # transmission errors\n            writeToEliza $MSG_NIC_ERRORS $name\n         fi\n      fi\n\n      debug "--checkForRCV-XMTDrops"\n\n      if [[ ${INTERFACE_RCV_DROPPED[${index}]} -gt 0 ]]; then      # receive messages dropped\n         writeToEliza $MSG_NIC_DROPPED $name\n      else\n         if [[ ${INTERFACE_XMT_DROPPED[${index}]} -gt 0 ]]; then   # transmission messages dropped\n            writeToEliza $MSG_NIC_DROPPED $name\n         fi\n      fi\n\n   fi\n\n   state "NIC:$rc"\n   debug "<<checkNetworkInterfaceCommon $rc"\n\nreturn $rc\n\n}\n\n#################################################################################\n#\n# Do some common tests for wired interfaces\n#\n# (empty right now)\n#\n#################################################################################\n\nfunction checkNetworkInterfaceWrd () {\n   debug ">>checkNetworkInterfacesWrd"\n   rc=0\n   state "NIWD:$rc"\n   debug "<<checkNetworkInterfacesWrd $rc"\n   return $rc\n}\n\n#################################################################################\n#\n# Do some common tests for wireless interfaces for HW problems\n#\n# Return 0 if no errors\n# Return 1 if there are errors\n#\n#################################################################################\n\nfunction checkNetworkInterfaceWrlHW () {\n   local rc\n   local finalrc=0\n   debug ">>checkNetworkInterfacesWrlHW"\n\n   checkForWLANKillSwitch\n   rc=$?\n   if [[ $rc != 0 ]]; then\n      writeToEliza $MSG_WLAN_KILL_SWITCH_ON\n      finalrc=1\n   fi\n\n   if [[ $finalrc == 0 ]]; then\n      checkForNdisWrapperAndLinuxModule\n      rc=$?\n      if [[ $rc != 0 ]]; then\n         finalrc=1\n      fi\n   fi\n\n   if [[ $finalrc == 0 ]]; then\n         checkForMissingWLANFirmware\n         rc=$?\n         if [[ $rc != 0 ]]; then\n            writeToEliza $MSG_POSSIBLE_WLAN_FIRMWARE_PROBLEMS\n            finalrc=1\n         fi\n   else\n         writeToEliza $MSG_NO_ANALYSIS_AS_USER "WLAN_firmware_problems"\n   fi\n\n   debug "<<checkNetworkInterfacesWrlHW $finalrc"\nreturn $finalrc\n}\n\n#################################################################################\n#\n# Do some common tests for wireless interfaces for auth problems\n#\n# Return 0 if no errors\n# Return 1 if there are errors\n#\n#################################################################################\n\nfunction checkNetworkInterfaceWrlAUTH () {\n   local rc\n   local finalrc=0\n   debug ">>checkNetworkInterfacesWrlAUTH"\n\n   # check for mode set\n   # if not WEP or WPA key missing\n\n   # check for wpa_supplicant to be active and create a warning message\n\n   o=`ps -eo comm 2>/dev/null | $EGREP wpa_supplicant`\n   if [[ -z $o ]]; then\n      writeToEliza $MSG_NO_WPA_SUPPLICANT_ACTIVE\n      finalrc=1\n   fi\n\n   state "NIWLA:$finalrc"\n   debug "<<checkNetworkInterfacesWrlAUTH $finalrc"\n   return $finalrc\n}\n\n#################################################################################\n#\n# --- Check whether there is at least one networkdevice available. Use lspci\n#\n# -- Return the number of devices found\n#\n#################################################################################\n\nfunction checkForAtLeastOneNic () {\n\n   debug ">>checkForAtLeastOneNic"\n\n\n   if [[ $CONNECTION == $CONNECTION_WRL ]]; then\n         rc=`$PERL -e\'\n            foreach my $line (qx %\'$LSPCI\'%) {\n               if ($line =~ /network.*controller|ethernet.*controller.*(wireless|802\\.11)/i) {\n                  print "1";\n                  exit;\n               }\n            }\n            foreach my $line (qx %\'$LSUSB\'%) {\n               if ($line =~ /wlan|wireless|802\\.11/i) {\n                   print "1";\n                   exit;\n                }\n            }\n            print "2";\n            \'`\n   else           # wired connection - assumption: no USB card used\n         rc=`$PERL -e\'\n            foreach my $line (qx %\'$LSPCI\'%) {\n               if ($line =~ /ethernet.*controller/i && $line !~ /wireless|802\\.11/i) {\n                  print "1";\n                  exit;\n               }\n            }\n            print "0";\n            \'`\n   fi\n\n   state "FALON:$rc"\n   debug "<<checkForAtLeastOneNic $rc"\n\nreturn $rc\n\n}\n\n#################################################################################\n#\n# --- Check whether there are multiple nics in the same subnet.\n#\n# --- Return 0 if no nics are in the same subnet\n# --- Return 1 if there are nics in the same subnet\n#\n#################################################################################\n\nfunction checkForNicsInSameSubnet() {\n\n   local rc\n   local q\n\n   debug ">>checkForNicsInSameSubnet"\n\n   q=`$IFCONFIG  | $PERL -e \'my $nic; my %nicsFound;\n#         collect all nics with their ip and netmask\n         while (my $line=<STDIN>) {\n#            print "$line \\n";\n            if ( $line=~/^([a-z0-9]+).*/) {\n               $nic=$1;\n            } else {\n#                                $1 (ip)                  $2 (bc)                 $3 (mask)\n               $line=~/.*:(\\d+\\.\\d+\\.\\d+\\.\\d+).*:(\\d+\\.\\d+\\.\\d+\\.\\d+).*:(\\d+\\.\\d+\\.\\d+\\.\\d+)/;\n               if ( $1 != "") {\n                  my @ipNibbles=split /\\./, $1, 4;\n                  my @maskNibbles=split /\\./, $3, 4;\n                  $netNibbles[0]=$ipNibbles[0] + 0 & $maskNibbles[0];\n                  $netNibbles[1]=$ipNibbles[1] + 0 & $maskNibbles[1];\n                  $netNibbles[2]=$ipNibbles[2] + 0 & $maskNibbles[2];\n                  $netNibbles[3]=$ipNibbles[3] + 0 & $maskNibbles[3];\n                  my $maskedIP="$netNibbles[0]\\.$netNibbles[1]\\.$netNibbles[2]\\.$netNibbles[3]";\n                  $nicsFound{$nic} = $maskedIP;\n#                  print ".$nic,$maskedIP.";\n               }\n            }\n             }\n\n#         check whether there are identical networks used by the nics\n#            $nicsFound{"eth1"} = "192.168.0.0";\n\n         my @ips=values %nicsFound;\n         my @nics=keys %nicsFound;\n         my $size=$#nics;\n         for (my $i=0; $i<$size; $i++) {\n            for (my $j=$i+1; $j<=$size; $j++) {\n                  if ($ips[$i] eq $ips[$j]) {\n                     print "$nics[$i]:$nics[$j]"\n                  }\n            }\n         }\n\'`\n    checkForNicsInSameSubnet_Result=$q\n\n    if [[ $q != "" ]]; then\n      rc=1\n    else\n      rc=0;\n    fi\n\nstate "NISS:$rc"\ndebug "<<checkForNicsInSameSubnet $rc"\n\nreturn $rc\n\n}\n\n#################################################################################\n#\n# --- Check whether there are no modules loaded or any inactive modules\n#\n# --- Return 0 if nothing special\n# --- Return 1 if there is no module loaded\n# --- Return 2 if there are inactive modules\n# --- Return 3 if there is no module loaded and inactive modules\n#\n#################################################################################\n\nfunction checkModules() {\n   debug ">>checkModules"\n\n   local ifce\n   local rc\n   local result\n\n   if [[ $CONNECTION == $CONNECTION_WRL ]]; then\n      ifce=""\n   else\n      ifce="eth"\n   fi\n\n   result=`echo $ifce |  $PERL -e\'\n\nmy $active=0;\nmy $inactive=0;\nmy @inactiveName=();\nmy $activeName="";\nmy $nicName="";\nmy $found=0;\n\nmy $nic;\nmy $nicI=<>;\nif ( $nicI =~ /eth/ ) {\n   $nic="Ether";\n}\nelse {\n   $nic="(Network|WLAN)";\n}\n\nforeach my $line (qx %\'$HWINFO\' --netcard%) {\n\n#  print $line;\n\n   if ($line =~ /^\\d+:/ && $found) {\n      last;\n   }\n   if ($line =~ /^\\d+:.+$nic/) {\n      $found=1;\n      next;\n   }\n\n   if ($line =~ /Driver Status: (\\w+).*(not|in).*active/) {\n      $inactive++;\n      if (scalar @inactiveName == 0) {\n         push @inactiveName,$1;\n      }\n      else {\n         push @inactiveName,",$1";\n      }\n   }\n      elsif ($line =~ /Driver Status: (\\w+).*active/) {\n      $active++;\n      $activeName=$1;\n   }\n      elsif ($line =~ /Device File: (\\w+)$/) {\n      $nicName = $1;\n   }\n}\nif ( $found ) {\n   print "$nicName | $activeName | @inactiveName\\n";\n}\nif ($activeName eq "" && scalar @inactiveName == 0) {\n  exit 3\n}\nif ($activeName eq "") {\n  exit 1\n}\nif (scalar @inactiveName > 0) {\n  exit 2\n}\nexit 0\'`\n\n   rc=$?\n\n   nicName=`echo $result | cut -d "|" -f 1`\n   active=`echo $result | cut -d "|" -f 2`\n   inactive=`echo $result | cut -d "|" -f 3`\n\n   if [[ $rc  == 1 || $rc == 3 ]]; then\n      writeToEliza $MSG_HW_NO_ACTIVE $nicName\n   fi\n   if [[ $rc  == 2 ]]; then\n      writeToEliza $MSG_HW_SOME_INACTIVE $inactive $nicName\n   fi\n   state "CM:$rc"\n   debug "<< checkModules $rc"\nreturn $rc\n}\n\n#################################################################################\n#\n# --- Check MTU\n#\n#################################################################################\n\nfunction checkMTU() {\n\ndebug ">>checkMTU"\n\n   local DFDetected\n   local testMTU\n   local dummy\n   local rc\n\n#   detect maximum possible MTU for client or router using pppoe\n\n   DFDetected=0\n   testMTU=1600\n\n   while [[ $DFDetected == 0 ]]; do\n       dummy=`$PING -c1 195.135.220.3 -s $testMTU -M do | $GREP "DF set"`\n      DFDetected=$?\n      if [[ $DFDetected == 0 ]]; then\n         let testMTU=$testMTU-100\n      fi\n   done\n\n   DFDetected=0\n   let testMTU=$testMTU+100\n\n   while [[ $DFDetected == 0 ]]; do\n      dummy=`$PING -c1 195.135.220.3 -s $testMTU -M do | $GREP "DF set"`\n      DFDetected=$?\n      if [[ $DFDetected == 0 ]]; then\n         let testMTU=$testMTU-10\n      fi\n   done\n\n   DFDetected=0\n   let testMTU=$testMTU+10\n\n   while [[ $DFDetected == 0 ]]; do\n      dummy=`$PING -c1 195.135.220.3 -s $testMTU -M do | $GREP "DF set"`\n      DFDetected=$?\n      if [[ $DFDetected == 0 ]]; then\n         let testMTU=$testMTU-2\n      fi\n   done\n\n   let mtuRequired=$testMTU+28\n\n#   mtuRequired=`ping -c1 195.135.220.3 -s 1600 -M do | perl -e \'my $mtu; while(<>) { if ($_=~/mtu.* (\\d+)\\)/) { print "$1"};\n#}\'`\n   defaultGatewayNic=`$ROUTE -n | $AWK \'/^[0]+\\.[0]+\\.[0]+\\.[0]+/ { print $NF; } \'`\n   mtuActive=`$IFCONFIG $defaultGatewayNic | $PERL -e \'my $mtu; while(<>) { if ($_=~/MTU:(\\d+)/) { print "$1"}; }\'`\n\n   if [[ $mtuRequired -lt $mtuActive ]]; then\n      rc=1\n   else\n      rc=0\n   fi\n   state "MTU:$rc"\n   debug "<<checkMTU $rc $mtuRequired"\n   return $rc\n\n}\n\n#################################################################################\n#\n# --- Check whether there is a default route defined\n#\n# --- return\n# ---    0 if there is no default route set\n# ---    1 if there is a default route set\n# --- and set global variable checkDefaultRoute_gateway_host to the hostname of the default gateway\n# --- and set global variable checkDefaultRoute_gateway_nic to the nic which is used for the default gateway\n#\n#################################################################################\n\nfunction checkDefaultRoute () {\n\n   debug ">>checkDefaultRoute"\n\n   local q\n   local i\n   local v\n   local rc\n\n# 0.0.0.0         192.168.0.1     0.0.0.0         UG    0      0        0 eth0\n\n    q=`$ROUTE -n | $AWK \'/^[0]+\\.[0]+\\.[0]+\\.[0]+/ { print$0; } \'`\n\n    if [[ $q == "" ]]; then\n      rc=0\n    else\n      rc=1\n      i=1\n      for v in $q; do\n         if [[ $i == 2 ]]; then\n            checkDefaultRoute_gateway_host=$v\n         fi\n         if [[ $i == 8 ]]; then\n            checkDefaultRoute_gateway_nic=$v\n         fi\n\n         let i=i+1\n      done;\n   fi\n   state "DR:$rc"\n   debug "<<checkDefaultRoute $rc"\n   CHECK_DEFAULT_ROUTE=$rc\nreturn $rc\n\n}\n\n#################################################################################\n#\n# --- Cat all config files in /etc/sysconfig/network/ifcfg-*\n# --- Masquerade wireless keys and passwords\n#\n#################################################################################\n\nfunction catMyConfig() {\nlocal C\n\n# masquerade WLAN credentials\n\n# BOOTPROTO=\'dhcp\'\n# BROADCAST=\'\'\n# ETHTOOL_OPTIONS=\'\'\n# IFPLUGD_PRIORITY=\'10\'\n# IPADDR=\'\'\n# MTU=\'\'\n# NAME=\'Intel Thinkpad  X60s, R60e model 0657\'\n# NETMASK=\'\'\n# NETWORK=\'\'\n# REMOTE_IPADDR=\'\'\n# STARTMODE=\'ifplugd\'\n# USERCONTROL=\'no\'\n# WIRELESS_AP=\'\'\n# WIRELESS_AUTH_MODE=\'open\'\n# WIRELESS_BITRATE=\'auto\'\n# WIRELESS_CA_CERT=\'\'\n# WIRELESS_CHANNEL=\'\'\n# WIRELESS_CLIENT_CERT=\'\'\n# WIRELESS_CLIENT_KEY=\'\'\n# WIRELESS_CLIENT_KEY_PASSWORD=\'\'\n# WIRELESS_DEFAULT_KEY=\'0\'\n# WIRELESS_EAP_AUTH=\'\'\n# WIRELESS_EAP_MODE=\'\'\n# WIRELESS_ESSID=\'FRAMP\'\n# WIRELESS_FREQUENCY=\'\'\n# WIRELESS_KEY=\'\'\n# WIRELESS_KEY_0=\'\'\n# WIRELESS_KEY_1=\'\'\n# WIRELESS_KEY_2=\'\'\n# WIRELESS_KEY_3=\'\'\n# WIRELESS_KEY_LENGTH=\'128\'\n# WIRELESS_MODE=\'Managed\'\n# WIRELESS_NICK=\'\'\n# WIRELESS_NWID=\'\'\n# WIRELESS_PEAP_VERSION=\'\'\n# WIRELESS_POWER=\'yes\'\n# WIRELESS_WPA_ANONID=\'\'\n# WIRELESS_WPA_IDENTITY=\'\'\n# WIRELESS_WPA_PASSWORD=\'\'\n# WIRELESS_WPA_PSK=\'\'\n\nif (( ! $CONFIG_READABLE )); then\n\twriteToEliza $MSG_NO_ANALYSIS_AS_USER "network_config_files"\n\treturn 0\nfi\n\nfor C in `ls /etc/sysconfig/network/ifcfg-[earwd]* 2>/dev/null`; do\n   c="cat $C"\n   m=`colorate "$c"`\n   echo $m >> $LOG;\n   cat $C | $GREP -v "^#" | $GREP -v "^$" \\\n   | $AWK "BEGIN { FS=\\"=\\"} \\\n      /WIRELESS_KEY[ ]*=|WIRELESS_KEY_[0-9][ ]*=|WIRELESS_DEFAULT_KEY[ ]*|WIRELESS_KEY_LENGTH[ ]*=|\\\n      WIRELESS_WPA_IDENTITY[ ]*=|WIRELESS_WPA_PASSWORD[ ]*=|WIRELESS_WPA_PSK[ ]*=/ \\\n      { cred=\\"@@@@@@\\"; \\\n        if ( \\$2 ~ /[\'\\"].+[\'\\"]/ || \\$2 !~ /[\'\\"]/ ) { \\\n           if ( substr(\\$2,1,1) ~ /[\'\\"]/ ) {\n              cred=substr(\\$2,1,1) cred substr(\\$2,1,1);\n         }\n           print \\$1 \\"=\\" cred; next;\n         }\n      }\n      { print \\$0}" | $EGREP -v ".*=\'\'" >> $LOG\ndone\nreturn 0\n}\n\n#################################################################################\n#\n# --- Check whether ipv6 module is loaded\n#\n# --- return 1 if module is loaded\n# --- return 0 otherwise\n#\n#################################################################################\n\nfunction checkForIPV6() {\n\n   debug ">>checkForIPV6"\n\n   local l\n\n   rc=0\n   i=1\n   while [[ $i -le $INTERFACE_NO ]]; do\n      if [[ $CONNECTION == $CONNECTION_WRL && ${INTERFACE_TYPE[$i]} == $CONNECTION_WRL ]] ||\n          [[ $CONNECTION == $CONNECTION_WRD && ${INTERFACE_TYPE[$i]} == $CONNECTION_WRD ]]; then\n         if [[ -n ${INTERFACE_IP6[$i]} ]]; then\n            rc=1\n            break\n         fi\n      fi\n      ((i++))\n   done\n\n   state "IP6:$rc"\n   debug "<<checkForIPV6 $rc"\n\n   return $rc\n\n}\n\nfunction checkForSSID () {\n   local rc\n   local i\n   debug ">>checkForSSID"\n   rc=0\n\n   i=1\n   while [[ $i -le $INTERFACE_NO ]]; do\n      if [[ $CONNECTION == $CONNECTION_WRL && ${INTERFACE_TYPE[$i]} == $CONNECTION_WRL ]]; then\n         wlanif=${INTERFACE_NAME[$i]}\n         debug "checking WLAN $wlanif"\n         rc=`$IWLIST $wlanif scanning 2>/dev/null | $GREP -c \\"$essid\\"`\n         if [[ $rc == 0 ]]; then\n            writeToEliza $MSG_WLAN_NO_SSID_IN_SCAN_FOUND $wlanif\n            rc=1\n         fi\n      fi\n      let i=$i+1\n   done\n   debug "<<checkForSSID $rc"\nreturn $rc\n}\n\n#wlan0     Scan completed :\n#          Cell 01 - Address: 00:14:6C:E5:F7:1F\n#                    ESSID:"FRAMP"\n#                    Protocol:IEEE 802.11bg\n#                    Mode:Master\n#                    Channel:11\n#                    Frequency:2.462 GHz (Channel 11)\n#                    Encryption key:on\n#                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 6 Mb/s; 9 Mb/s\n#                              11 Mb/s; 12 Mb/s; 18 Mb/s; 24 Mb/s; 36 Mb/s\n#                              48 Mb/s; 54 Mb/s\n#                    Quality=59/100  Signal level=-72 dBm  Noise level=-72 dBm\n#                    IE: WPA Version 1\n#                        Group Cipher : TKIP\n#                        Pairwise Ciphers (2) : CCMP TKIP\n#                        Authentication Suites (1) : PSK\n#                    IE: IEEE 802.11i/WPA2 Version 1\n#                        Group Cipher : TKIP\n#                        Pairwise Ciphers (2) : CCMP TKIP\n#                        Authentication Suites (1) : PSK\n#                    Extra: Last beacon: 708ms ago\n#\n\nfunction detectAPs () {\n   local wlanif\n   local i\n   local num=0\n\n   debug ">>detectAPs $INTERFACE_NO"\n\n   i=1\n   while [[ $i -le $INTERFACE_NO ]]; do\n      if [[ $CONNECTION == $CONNECTION_WRL && ${INTERFACE_TYPE[$i]} == $CONNECTION_WRL ]]; then\n         wlanif=${INTERFACE_NAME[$i]}\n         $IWLIST $wlanif scanning 2>/dev/null | $EGREP -i "ESSID|Channel|Quality|Signal" >> $LOG      # skip IE: Unknown\n         if [[ $? == 0 ]]; then\n            let num=$num+1\n         fi\n      fi\n      let i=$i+1\n   done\n\n   if [[ $num == 0 ]]; then\n      echo "No WLANs found" >> $LOG\n   fi\n\n   state "AP:$num"\n   debug "<<detectAPs"\n\n}\n\n#################################################################################\n#\n# --- Do common tests if a wireless interface has no IP address\n#\n#################################################################################\n\nfunction checkNetworkInterfaceWrlNoIP () {\n   local rc\n   local q\n   local finalRC=0\n   local i\n   local wlanif\n\n   debug "<<checkNetworkInterfaceWrlNoIP"\n\n   checkForSSID\n\n   i=1\n   while [[ $i -le $INTERFACE_NO ]]; do\n      if [[ $CONNECTION == $CONNECTION_WRL && ${INTERFACE_TYPE[$i]} == $CONNECTION_WRL ]]; then\n         wlanif=${INTERFACE_NAME[$i]}\n\n         $IWLIST $wlanif scanning 2>/dev/null 2>/dev/null | $GREP "ESSID" 1>/dev/null\n         if [[ $? != 0 ]]; then\n            writeToEliza $MSG_WLAN_NO_SCAN $wlanif\n            debug "HW/Driver problems on WLAN"\n            finalRC=1\n\n# no connection to AP\n\n#wlan0     unassociated  ESSID:off/any\n#          Mode:Managed  Frequency=nan kHz  Access Point: Not-Associated\n#          Bit Rate:0 kb/s   Tx-Power:16 dBm\n#          Retry limit:15   RTS thr:off   Fragment thr:off\n#          Encryption key:off\n#          Power Management:off\n#          Link Quality:0  Signal level:0  Noise level:0\n#          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0\n#          Tx excessive retries:0  Invalid misc:15   Missed beacon:0\n\n      elif [[ ${INTERFACE_AP[$i]} == "" && ${INTERFACE_ESSID[$i]} == "" ]]; then\n         writeToEliza $MSG_WLAN_AUTH_PROBS $wlanif\n         debug "Authentication problem on WLAN"\n         finalRC=2\n\n#wlan0     unassociated  ESSID:"FRAMP"\n#          Mode:Managed  Frequency=nan kHz  Access Point: Not-Associated\n#          Bit Rate:0 kb/s   Tx-Power:16 dBm\n#          Retry limit:15   RTS thr:off   Fragment thr:off\n#          Encryption key:off\n#          Power Management:off\n#          Link Quality:0  Signal level:0  Noise level:0\n#          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0\n#          Tx excessive retries:0  Invalid misc:18   Missed beacon:0\n\n#         elif [[ ${INTERFACE_AP[$i]} == "" && ${INTERFACE_ESSID[$i]} != "" ]]; then\n#         writeToEliza $MSG_WLAN_CON_NOESSID $wlanif\n#         debug ""\n#         finalRC=3\n#     fi\n\n# connection successfully\n\n#wlan0     IEEE 802.11g  ESSID:"FRAMP"\n#          Mode:Managed  Frequency:2.462 GHz  Access Point: 00:14:6C:E5:F7:1F\n#          Bit Rate:36 Mb/s   Tx-Power:15 dBm\n#          Retry limit:15   RTS thr:off   Fragment thr:off\n#          Encryption key:xxxx-xxxx-xxxx-xxxx-xxxx-xxxx-xxxx-xxxx   Security mode:open\n#          Power Management:off\n#          Link Quality=65/100  Signal level=-68 dBm  Noise level=-69 dBm\n#          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0\n#          Tx excessive retries:0  Invalid misc:25   Missed beacon:0\n\n      elif [[ ${INTERFACE_AP[$i]} != "" && ${INTERFACE_ESSID[$i]} != "" ]]; then\n         debug "Connection and ESSID"\n         finalRC=0\n      fi\n   fi\n\n   let i=$i+1\n   done\n\n   state "NIW:$wlanif-$finalRC"\n\n   debug ">>checkNetworkInterfaceWrlNoIP $finalRC"\n\n   return $finalRC\n\n}\n\n#################################################################################\n#\n# --- check if networkmanager is enabled and there exist configurations for wireless/wired which will be used by ifup\n#\n# --- return 1 if there is a configuration mismatch\n# --- return 0 otherwise\n# --- place in KNETWORK_IF the names of the interfaces which is misconfigured\n#\n#################################################################################\n\nfunction checkKnetworkManager () {\n\ndebug ">>checkKnetworkManager"\n\n   local f\n   local C\n   local rc\n   local error=0\n   local mask\n   local nmRunning=0\n   KNETWORK_IF=""\n\n   if (( ! $CONFIG_READABLE )); then\n   \t\twriteToEliza $MSG_NO_ANALYSIS_AS_USER "static_network_configuration_with_networkmanager"\n\t\treturn\n\tfi\n\n\tC=`$EGREP -i \'NETWORKMANAGER.*=.*yes\' /etc/sysconfig/network/config `\n\trc=$?\n\t\n\tdebug "NM in config enabled: $rc"\n\t\n\tif [[ $rc != 0 ]]; then\t\t\t# not enabled in config\n\t\tC=`ps -ef | grep "/sbin/NetworkManager" | grep -v "grep" 2>&1 1>/dev/null`\n\t\tif [[ $C != "" ]]; then\t\t\t\t# NM active\n\t\t\tdebug "Found running NM"\n\t\t\tnmRunning=1\n\t\t\trc=0\n\t\tfi\n\tfi\n\t\n\tdebug "NM configured: $rc"\n\t\n\tmask="[arwe]"                                                                   # yes\n\tif [[ $rc == 0 ]]; then                                                         # networkmanager enabled\n\t\tif (( ! $nmRunning )); then\n\t\t\tdebug "NM not running"\n\t\t\tfor f in `ls /etc/sysconfig/network/ifcfg-${mask}* 2>/dev/null`; do      # no configs allowed\n\t\t\t\terror=1\n\t\t\t\tif  [[ $KNETWORK_IF == "" ]]; then\n\t\t\t\t\tKNETWORK_IF="${f##*-}"\n\t\t\t\telse\n\t\t\t\t\tKNETWORK_IF="${f##*-},$KNETWORK_IF"\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\telse\n\t\tdebug "NM not running"\n\t\tnodhcp=0\t# NM not configured or running, check whether dhcp is used in config for all IFs \n\t\tfor f in `ls /etc/sysconfig/network/ifcfg-${mask}* 2>/dev/null`; do      # process all configs\n\t\t\tif $GREP -i "BOOTPROTO=.*dhcp" $f 1>/dev/null 2>/dev/null; then\n\t\t\t\tdebug "$f OK"\n\t\t\t\t:\n\t\t\telse\n\t\t\t\tdebug "$f NOK"\n\t\t\t\tnodhcp=1\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\tif (( $nodhcp )); then\n\t\t\twriteToEliza $MSG_IFUP_CONFIGURED                                                         # warning that ifup is enabled\n\t\tfi\n\tfi\n\n   state "KM:$error $nodhcp"\n   debug "<<checkKnetworkManager $error $KNETWORK_IF"\n\n   return $error\n\n}\n\n#################################################################################\n#\n# --- check for missing firmware for WLAN cards\n#\n# --- return 1 if string found\n#\n#################################################################################\n\nfunction checkForMissingWLANFirmware() {\n\n   debug ">>checkForMissingWLANFirmware"\n   local rc\n   local testString\n   testString="((microcode|firmware).*(fail|error|not.*found))|prism.*faulty|((fail|error).*(microcode|firmware))"\n#   $TAIL -n $NUMBER_OF_LINES_TO_CHECK_IN_VAR_LOG_MESSAGES ${VAR_LOG_MESSAGE_FILE}* | $EGREP -i $testString > /dev/null\n#     rc=$?\n#\n#   if [[ $rc == 0 ]]; then\n#      rc=1\n#   else\n      dmesg | $EGREP -i $testString > /dev/null\n      if [[ $rc == 0 ]]; then\n         rc=1\n      else\n        rc=0\n      fi\n#   fi\n\n   debug ">>checkForMissingWLANFirmware $rc"\n\n   return $rc\n\n}\n\n#################################################################################\n#\n# --- check if the WLAN kill switch is on\n#\n# --- return 1 is yes\n# --- return 0 otherwise\n#\n#################################################################################\n\n\nfunction checkForWLANKillSwitch() {\n\n   debug ">>checkForWLANKillSwitch"\n   local rc\n   local rfkillResult\n   local dummy\n   local temprc\n\n# try rfkill first if its available\n\n#\tTODO !!! Use vars for commands initialized below\n   if `isCommandAvailable rfkill`; then\n\trfkillResult=`$RFKILL list wifi`\n\tdebug "rfKillResult: $rfkillResult"\n\tif [[ $rfkillResult != "" ]]; then\n\t\tdebug "rfkill tried"\n\t#0: phy0: Wireless LAN\n\t#\tSoft blocked: no\n\t#\tHard blocked: yes\n\t\t`echo $rfkillResult | $GREP "blocked.*yes" >/dev/null`\n\t\tif [ $? == 0 ]; then\n\t\t\trc=1\n\t\t\tdebug "<<checkForWLANKillSwitch1 $rc"\n\t\t\treturn $rc\n\t\tfi\n\tfi\n   fi\n\n# now check for messages in dmesg\n\n   `dmesg | $EGREP -i "radio.*disabled|disabled.*radio|radio.*switch.*off|off.*radio.*switch" > /dev/null`\n   temprc=$?\n\n   if [[ $temprc == 0 ]]; then\n      rc=1\n\tdebug "dmesg used"\n   else\n\trc=0\n\n# still no success, use hwinfo if available\n\n#28: PCI 400.0: 0282 WLAN controller\n#  Model: "Intel ThinkPad R60e/X60s"\n#  Vendor: pci 0x8086 "Intel Corporation"\n#  Device: pci 0x4227 "PRO/Wireless 3945ABG [Golan] Network Connection"\n#  SubVendor: pci 0x8086 "Intel Corporation"\n#  SubDevice: pci 0x1011 "ThinkPad R60e/X60s"\n#  Driver: "iwl3945"\n#  Driver Modules: "iwl3945"\n#  Device File: wlan0      <=== missing Link detected msg\n#    Driver Status: iwl3945 is active\n#    Driver Activation Cmd: "modprobe iwl3945"\n#29: PCI 600.0: 0200 Ethernet controller\n#  Model: "Broadcom NetLink BCM5906M Fast Ethernet PCI Express"\n#  Vendor: pci 0x14e4 "Broadcom"\n#  Device: pci 0x1713 "NetLink BCM5906M Fast Ethernet PCI Express"\n#  SubVendor: pci 0x17aa "Lenovo"\n#  SubDevice: pci 0x3861\n#  Driver: "tg3"\n#  Driver Modules: "tg3"\n#  Device File: eth0\n#  Link detected: no\n#    Driver Status: tg3 is active\n#    Driver Activation Cmd: "modprobe tg3"\n\n#   if `isCommandAvailable hwinfo`; then\n\n#\tdebug "hwinfo used"\n#\tdebug "hwinfo: $HWINFO"\n\n#      if [[ $CONNECTION == $CONNECTION_WRD ]]; then\n#         CONN="eth"\n#         PARM="--netcard"\n#      else\n#         CONN="eth|ath|wlan|ra"\n#         PARM="--wlan"\n#      fi\n#\n#      devs=`$PERL -e \'\n#       my $line;\n#       my $multiple=0;\n#       my $devices="";\n#       my $linkDetected="";\n#       my $isActive="";\n#\n#       sub chk {\n#                  if ($isActive eq "yes" && $linkDetected ne "yes") {\n#                     if ($devices != "") {\n#                        $devices="$devices,$device";\n#                     }\n#                     else {\n#                        $devices="$device";\n#                     }\n#                  }\n#        }\n#\n#       foreach $line (qx %\'$HWINFO\' \'$PARM\'%) {\n#            if ($line =~ /Device File.*: ([a-z0-9]+)/) {\n#                if ($device ne "" && $device =~ \'$CONN\') {\n#                        chk();\n#                }\n#                else {\n#                       $device=$1;\n#                       $linkDetected="";\n#                       $isActive="";\n#                }\n#            }\n#            if ($line =~ /Link detected: ([a-zA-z]+)/) {\n#               $linkDetected=$1;\n#            }\n#            if ($line =~ /Driver Status:.+is active/) {\n#               $isActive="yes";\n#            }\n#         }\n#        chk();\n#        print $devices\'`\n#\n#      if [[ $devs != "" ]]; then\n#         rc=1\n#      else\n#         rc=0\n#      fi\n#\n#      fi # hwinfo available\n\n   fi # check hwinfo instead of dmesg\n\n   debug "<<checkForWLANKillSwitch $rc"\n\n   return $rc\n}\n\n##################################################################################\n#\n#  --- Ask user for environment\n#\n##################################################################################\n\n# --- Ask for the NW topology used\n\nfunction getTopology () {\n   local answer\n   local answerNo\n   local answerOffset\n   TOPOLOGY=0\n   TOPOLOGY_DM_LC=1\n   TOPOLOGY_DR_LC=2\n   TOPOLOGY_DM_LR_LC=3\n   TOPOLOGY_DR_LR_LC=4\n   TOPOLOGY_AP_LC=5\n   TOPOLOGY_WR_LC=6\n   TOPOLOGY_AP_LR_LC=7\n   TOPOLOGY_WR_LR_LC=8\n\n   if [[ $TOPOLOGYTYPEOPTION -eq 0 ]]; then\n\n      writeToConsole $MSG_EMPTY_LINE\n      writeToConsole $MSG_GET_TOPOLOGY\n\n      while [[ $TOPOLOGY == 0 ]]; do\n         if [[ $CONNECTION == $CONNECTION_WRD ]]; then\n            writeToConsole $MSG_TOPO_DM_LC\n            writeToConsole $MSG_TOPO_DR_LC\n            writeToConsole $MSG_TOPO_DM_LR_LC\n            writeToConsole $MSG_TOPO_DR_LR_LC\n            answerNo=4\n            answerOffset=0\n         else\n            writeToConsole $MSG_TOPO_AP_LC\n            writeToConsole $MSG_TOPO_WR_LC\n            writeToConsole $MSG_TOPO_AP_LR_LC\n            writeToConsole $MSG_TOPO_WR_LR_LC\n            answerNo=4\n            answerOffset=4\n         fi\n\n         writeToConsoleNoNL $MSG_PLEASE_CORRECT_ANSWER $answerNo\n         read answer\n         if [[ "$answer" -le 0 || "$answer" -gt $answerNo ]]; then\n            writeToConsole $MSG_UNSUPPORTED_TOPOLOGY\n            answer=-1\n         else\n            let TOPOLOGY=answer+answerOffset\n            answer=0\n         fi\n      done\n   else\n      TOPOLOGY=$TOPOLOGYTYPEOPTION\n   fi\n\n#   if [[ $TOPOLOGYTYPEOPTION -ne 0 ]]; then\n\n      writeToElizaOnly $MSG_EMPTY_LINE\n      writeToElizaOnly $MSG_GET_TOPOLOGY\n      case $TOPOLOGY in\n         1) writeToElizaOnly $MSG_TOPO_DM_LC;;\n         2) writeToElizaOnly $MSG_TOPO_DR_LC;;\n         3) writeToElizaOnly $MSG_TOPO_DM_LR_LC;;\n         4) writeToElizaOnly $MSG_TOPO_DR_LC;;\n\n         5) writeToElizaOnly $MSG_TOPO_AP_LC;;\n         6) writeToElizaOnly $MSG_TOPO_WR_LC;;\n         7) writeToElizaOnly $MSG_TOPO_AP_LR_LC;;\n         8) writeToElizaOnly $MSG_TOPO_WR_LR_LC;;\n\n         *) writeToElizaOnly $MSG_INTERNAL_ERROR;;\n      esac\n#   fi\n}\n\n# --- Ask for the NW connection used\n\nfunction getConnection () {\n   local answer\n   CONNECTION=0\n   CONNECTION_WRD=2\n   CONNECTION_WRL=1\n\n   if [[ $CONNECTIONTYPEOPTION -eq 0 ]]; then\n\n#      writeToConsole $MSG_EMPTY_LINE\n      writeToConsole $MSG_GET_CONNECTION\n\n      while [[ $CONNECTION == 0 ]]; do\n         writeToConsole $MSG_CON_WRL\n         writeToConsole $MSG_CON_WRD\n         writeToConsoleNoNL $MSG_PLEASE_CORRECT_ANSWER 2\n         read answer\n         if [[ "$answer" -le 0 || "$answer" -gt 2 ]]; then\n            writeToConsole $MSG_UNSUPPORTED_CONNECTION\n            answer=-1\n         else\n            CONNECTION=$answer\n            answer=0\n         fi\n      done\n   else\n      CONNECTION=$CONNECTIONTYPEOPTION\n   fi\n\n   if [[ $CONNECTION -eq 1 ]]; then\n\t   FLAGS="${FLAGS}w"   # turn on wireless outputs\n   fi\n\n#   if [[ $CONNECTIONTYPEOPTION -ne 0 ]]; then\n      writeToElizaOnly $MSG_EMPTY_LINE\n      writeToElizaOnly $MSG_GET_CONNECTION\n      case $CONNECTION in\n         1) writeToElizaOnly $MSG_CON_WRL\n            ;;\n         2) writeToElizaOnly $MSG_CON_WRD\n            ;;\n         *) writeToElizaOnly $MSG_INTERNAL_ERROR\n            ;;\n      esac\n#   fi\n}\n\n\n# --- Ask for the host the script was run on\n\nfunction getExecutionHost () {\n   \n   if [[ $EXECUTIONHOSTOPTION -eq 0 ]]; then\n\n      EXECUTION_HOST_CL=1\n      EXECUTION_HOST_RT=2\n      EXECUTION_HOST=0\n\n      if [[ $TOPOLOGY != $TOPOLOGY_DM_LC && $TOPOLOGY != $TOPOLOGY_DR_LC && $TOPOLOGY != $TOPOLOGY_AP_LC && $TOPOLOGY != $TOPOLOGY_WR_LC ]]; then\n         writeToConsole $MSG_EMPTY_LINE\n         writeToConsole $MSG_GET_HOST\n\n         while [[ $EXECUTION_HOST == 0 ]]; do\n            writeToConsole $MSG_HOST_CL\n            writeToConsole $MSG_HOST_RT\n            writeToConsoleNoNL $MSG_PLEASE_CORRECT_ANSWER 2\n            read answer\n            if [[ "$answer" -le 0 || "$answer" -gt 2 ]]; then\n               writeToConsole $MSG_UNSUPPORTED_HOST\n            else\n               EXECUTION_HOST=$answer\n            fi\n         done\n      else\n         EXECUTION_HOST=$EXECUTION_HOST_CL   # has to be the client\n      fi\n   else\n      EXECUTION_HOST=$EXECUTIONHOSTOPTION\n   fi\n\n#  if [[ $EXECUTIONHOSTOPTION -ne 0 ]]; then\n\n      writeToElizaOnly $MSG_EMPTY_LINE\n      writeToElizaOnly $MSG_GET_HOST\n      case $EXECUTION_HOST in\n         1) writeToElizaOnly $MSG_HOST_CL\n            ;;\n         2) writeToElizaOnly $MSG_HOST_RT\n            ;;\n         *) writeToElizaOnly $MSG_INTERNAL_ERROR\n            ;;\n      esac\n#   fi\n\n}\n\n# --- Ask for the ESSID if WLAN check\n\nfunction getESSID () {\n\n   essid=""\n   local answer\n   local chars\n   local i\n\n   if [[ $CONNECTION == $CONNECTION_WRL ]]; then\n      if [[ $ESSIDOPTION == "" ]]; then\n          while [[ $essid == "" ]]; do\n\n         writeToConsole $MSG_EMPTY_LINE\n         writeToConsoleNoNL $MSG_GET_ESSID\n\n         read answer\n         essid=$answer\n\n         chars=${#answer}\n         echo -n $\'\\x1b[1A\\x1b[2K\'      # masquerade SSID - just in case\n         writeToConsoleNoNL $MSG_GET_ESSID\n         for ((i=1; $i<=$chars; i++)); do\n            echo -n "*"\n         done\n         echo\n      done\n   else\n      essid=$ESSIDOPTION\n   fi\n\n    # masquerade essid\n\n   writeToElizaOnly $MSG_GOT_ESSID $essid    # masqueraded later\n   fi\n\n}\n\n##################################################################################\n#\n# --- check if WLAN should be tested but a wired connection exists\n#\n# --- return 1 if yes\n# --- return 0 otherwise\n#\n##################################################################################\n\nfunction checkIfWLANTestButWiredOnline () {\n\n   local i\n   local rc=0\n   local defaultGatewayNic\n   local foundWRLIP=0\n\n   debug ">>checkIfWLANTestButWiredOnline"\n\n   i=1\n   while [[ $i -le $INTERFACE_NO ]]; do\n\n#      if [[ $CONNECTION == $CONNECTION_WRL && ${INTERFACE_TYPE[$i]} == $CONNECTION_WRL && ${INTERFACE_IP[$i]} != "" ]]; then\n#        foundWRLIP=1\n#      fi\n\n      if [[ $CONNECTION == $CONNECTION_WRL && ${INTERFACE_TYPE[$i]} == $CONNECTION_WRD && ${INTERFACE_IP[$i]} != "" ]]; then\n         defaultGatewayNic=`$ROUTE -n | $AWK \'/^[0]+\\.[0]+\\.[0]+\\.[0]+/ { print $NF; } \'`\n         if [[ $defaultGatewayNic == ${INTERFACE_NAME[$i]} ]]; then   # default GW is wired nic\n            rc=1\n            checkIfWLANTestButWiredOnline=${INTERFACE_NAME[$i]}\n            break;\n         fi\n      fi\n      let i=i+1\n   done\n\n#if [[ $foundWRLIP == 0 ]]; then        # no WRL IP found, then ignore an existing WRD connection\n#  rc=0\n#fi\n\n   debug "<<checkIfWLANTestButWiredOnline $rc"\n   state "WLW:$checkIfWLANTestButWiredOnline $rc"\n\nreturn $rc\n}\n\n# checks whether a module is loaded\n# returns 1 if module is not loaded\n\n#Module                  Size  Used by\n#nfs                   227500  1\n#lockd                  63864  2 nfs\n#nfs_acl                 7552  1 nfs\n#sunrpc                160892  4 nfs,lockd,nfs_acl\n#iptable_filter          6912  0\n#ip_tables              16324  1 iptable_filter\n#ip6table_filter         6784  0\n#ip6_tables             17476  1 ip6table_filter\n#x_tables               18308  2 ip_tables,ip6_tables\n\nfunction moduleNotLoaded () {   # moduleName\n   local q\n   local rc\n\n   debug ">>moduleNotLoaded $0"\n\n   q=`$PERL -e \'foreach (qx %\'$LSMOD\'%) {\n         (my $module) = ($_ =~ /^(\\w+) /);\n         if ( $module eq $ARGV[0]) {\n            print "$module\\n";\n            exit 0;\n         }\n      }\n      exit 1;\n      \' $0`\n\n   rc=$?\n   debug "<<moduleNotLoaded $rc"\n\n}\n\n# checks whether a nl80211 module is loaded\n# returns 1 if module is not loaded\n\n#Module                  Size  Used by\n#nfs                   227500  1\n#lockd                  63864  2 nfs\n#nfs_acl                 7552  1 nfs\n#sunrpc                160892  4 nfs,lockd,nfs_acl\n#iptable_filter          6912  0\n#ip_tables              16324  1 iptable_filter\n#ip6table_filter         6784  0\n#ip6_tables             17476  1 ip6table_filter\n#x_tables               18308  2 ip_tables,ip6_tables\n\nfunction modulenl80211() {   # moduleName\n   local q\n   local rc\n\n   debug ">>modulenl80211 $0"\n\n   q=`$PERL -e \'foreach (qx %\'$LSMOD\'%) {\n         (my $module) = ($_ =~ /^(\\w+) /);\n         if ( $module eq $ARGV[0]) {\n            print "$module\\n";\n            exit 0;\n         }\n      }\n      exit 1;\n      \' $0`\n\n   rc=$?\n   debug "<<modulenl80211 $rc"\n\n}\n\nfunction checkSSID() {\n\n   debug ">>checkSSID $essid"\n\n$PERL -e \'\n\t# From IEEE 802.11 7.3.2.1\n\t# 7.3.2.1 Service Set Identity (SSID) element\n\tmy $s=$ARGV[0];\n    # print "ESSID $s\\n";\n\tif (\n      \t  ($s =~ /[?\\"\\$\\[\\\\\\]\\+]/) \t        # invalid all the time \n\t     || ($s =~ /^[!#;]/)                # invalid in front\n\t     || ($s =~ /[\\x00-\\x1F]/)           # non printable character\n\t     || ($s =~ /[\\x80-\\xFF]/)           # extended characters >= 0x80\n\t   ) {\n      \t  exit 1;\n\t        }\n\telse    {\n      \t  exit 0;\n\t        }\n\t\' $essid\n   rc=$?\n   debug "<<checkSSID $rc"\n   return $rc\n}\n\nfunction NWElizaStates () {\n\n   debug ">>NWElizaStates `cat $STATE`"\n\n   if (( NWELIZA_ENABLED )); then\n\n      if [[ -z $1 ]]; then\n         cat $STATE | $PERL -e \'while (<>) { s/  / /g; s/\\n//; s/: /:/; print "$_ " }; print "\\n"\'\n      else\n         echo "NWElizaStates $CVS_VERSION"\n      fi\n   fi\n   debug "<<NWElizaStates `cat $STATE`"\n\n}\n\n##################################################################################\n#\n# --- Check if networkmanager is not used whether there is a config file\n#\n##################################################################################\n\nfunction checkNetworkManagerConfigured () {\n   local C\n   local i\n   local rc\n   local knme\n   local fileName\n\n   debug ">>checkNMConfigured"\n\n   if (( ! $CONFIG_READABLE )); then\n   \t\twriteToEliza $MSG_NO_ANALYSIS_AS_USER "Networkmanager_configuration"\n\t\treturn 0\n   fi\n\n   C=`$EGREP -i \'NETWORKMANAGER.*=.*yes\' /etc/sysconfig/network/config `\n   knme=$?\n\n   i=1\n   while [[ $i -le $INTERFACE_NO ]]; do\n      if [[ $CONNECTION == $CONNECTION_WRL && ${INTERFACE_TYPE[$i]} == $CONNECTION_WRL ]] ||\n            [[ $CONNECTION == $CONNECTION_WRD && ${INTERFACE_TYPE[$i]} == $CONNECTION_WRD ]]; then\n\n        if [[ ${INTERFACE_IP[$i]} == "" ]]; then                                       # no IP address\n            fileName="/etc/sysconfig/network/ifcfg-${INTERFACE_NAME[$i]}";\n\n            if [[ $knme != 0 ]]; then                                                   # networkmanager not enabled\n               if [[ ! -e $fileName ]]; then\n                  writeToEliza $MSG_NO_NIC_CONFIG_FOUND ${INTERFACE_NAME[$i]}\n          fi\n            fi\n\t\tfi\n      fi\n      let i=i+1\n   done\n\n   debug "<<checkNMConfigured"\n\n}\n\n##################################################################################\n#\n# --- Generate a simple tabular alphabetically sorted list of available firmware\n#\n##################################################################################\n\nfunction listFirmware() {\n\n\n   dir="/lib/firmware"\n   # check for missing firmware of broadcom card (thx larry)\n   dummy=`$LSPCI -nn | $GREP "14e4:43"`\n   if [[ $? == 0 ]]; then\n      dir="/lib/firmware/b43"\n   fi\n   dummy=`$LSPCI -nn | $EGREP "14e4:4301|14e4:4306"`\n#      dummy=`lspci -nn | egrep "10de:00f1|1095:0680"`\n   if [[ $? == 0 ]]; then\n      dir="/lib/firmware/bc43legacy"\n   fi\n   if [[ -z $1 ]]; then\n\tlistFirmwareDirectory $dir\n    else\n\techo "ls $dir/*.{fw,ucode,bin}"\n    fi\n}\n\nfunction listFirmwareDirectory () {\n   local dummy\n\n   if [[ -d $1 ]]; then\n\n      $PERL -e \'my $i=0;\n            my $LIMIT=3;\n\t    my $dir=$ARGV[0];\n\t    opendir(DIR, $dir) or die $!;\n\n\t    my @files = sort readdir(DIR);\n\t    while (my $m = shift @files) {\n               next unless (-f "$dir/$m");\n               next unless ($m =~ m/\\.(ucode|fw|bin)$/);\n\n               printf "| %-24s","$m";\n               if ( $i++ == $LIMIT ) {\n                  print " |\\n";\n                  $i=0;\n               }\n            }\n            if ( $i != 0 ) {\n               print "|\\n";\n            }\' $1 >> $LOG\n\n   else\n       echo "$1 not found" >> $LOG\n   fi\n}\n\n##################################################################################\n#\n# --- Generate a simple tabular alphabetically sorted list of loaded modules\n#\n# To reduce the length of the list common non network related modules are filtered\n#\n##################################################################################\n\nfunction listLoadedModules () {\n\n   $PERL -e \'   my @modules=qx %\'$LSMOD\' | sort %;\n      my $i=0;\n      my $modlist1 = qr /acpi|agp|^asus|async|ata_generic|auth_rpcgss|autofs4|battery|bluetooth|bridge|bttv|^bt|button|cdrom|cpu|crc|crypto|crypt|^cx|decoder|dm_mod|dvb|edd|exportfs|ext[34]|^fan$|^fat$|firewire|floppy|fuse/i;\n      my $modlist2 = qr /game|ir_common|ide|^ip[6]*table|^ip6|ip[6]*t_|iTCO|joy|lockd|loop|license|Module|matrox|nfs|nf_|nfs|nls|nvidia|parport|pata|pcmcia|pcspkr|pppoe|ppox/i;\n      my $modlist3 = qr /processor|psmouse|radeon|raid|reiserfs|^rtc_|^snd|soundcore|sunrpc|thermal|usbcore|usbhid|video|vbox|vesa|vfat|video|vmci|vmmon|vmnet|vsock|x_tables|xor|xt_/i;\n\n      my $COLUMNS = 4;\n\n      foreach my $module (@modules) {\n         my ($m, $s, $u, $b) = ($module =~ /(\\S+)\\s+(\\S+)\\s+(\\S+)(\\s+(\\S+))?/);\n         if ($m =~ $modlist1 || $m =~ $modlist2 || $m =~ $modlist3) {\n            next;\n         }\n         printf "| %-16s","$m";\n         if ( $i++ == $COLUMNS ) {\n            print " |\\n";\n            $i=0;\n         }\n      }\n      if ( $i != 0 ) {\n            print "|\\n";\n      }\' >> $LOG\n\n}\n\nfunction checkModulenl80211() {\n\n  debug ">>checkModulenl80211"\n\n      module=`$PERL -e \'\n   @modules = ("rt2860sta","rt2870sta","rt3070sta","rt3090sta", "rt3562sta", "rt3572sta", "5390sta", "r8192ce_pci", "r8192se_pci", "r8192e_pci", "r8192u_usb", "r8192s_usb", "r8712u");\n\n   $rc="";\n\n   $configFile= "/etc/sysconfig/network/config";\n   $releaseFile="/etc/SuSE-release";\n\n   if (-e $releaseFile && qx%egrep -i "VERSION.*=.*11\\.3" $releaseFile 2>/dev/null%\n      && -e $configFile && qx%egrep -v -i "NETWORKMANAGER.*=.*yes" $configFile 2>/dev/null%) {\n      foreach (qx %lsmod%) {\n         (my $module) = ($_ =~ /^(\\w+) /);\n         foreach $m (@modules) {\n            if ($m eq $module) {\n               $rc=$module;\n               last;\n            }\n         }\n      }\n   }\n   print $rc;\n   \'`\n      if [[ $module != "" ]]; then     # found module\n          writeToEliza $MSG_ENL80211L $module\n      fi\n   debug "<<checkModulenl80211"\n\n}\n\n##################################################################################\n#\n#  --- checkWLANInterferences\n#\n# Check whether there are other WLANs which have interferences to the used WLAN channel\n#\n# Calculate number of APs using the same channel and number of APs interferring with same channel\n#\n##################################################################################\n\nfunction checkWLANInterferences () {\n\n   local interferences\n   local channels\n\n   debug ">>checkWLANInterferences"\n\n   if [[ $INTERFACE_WRL_NO -gt 0 ]]; then\n\n      IFS=\'$\'\t\t# don\'t use space as separator, otherwise spaces cause problems when essid is passed into perl code\n      channels=`$PERL -e \'\n\n      my @channels = (0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n      my $essid="\'$essid\'";\n      my $essidChannel=0;\n      my $channel;\n\n      foreach my $line (qx %iwlist scan 2>/dev/null%) {\n         print $_;\n         if ($line =~ /Channel:(\\d+)/)  {\n               $channels[$1]++;\n               $channel=$1;\n         }\n         if ($line =~ /ESSID:"(.*)"/) {\n               if ($essid eq $1) {\n                  $essidChannel=$channel;\n               }\n         }\n      }\n      $inter=0;\n      $min=1;\n      $max=$#channels;\n      if ($essidChannel-4 > 1) { $min=$essidChannel-4; }\n      if ($essidChannel+4 < $#channels) { $max=$essidChannel+4; }\n\n      foreach my $chan ($min .. $max) {\n              $inter+=$channels[$chan];\n      }\n\n      $inter-=$channels[$essidChannel];\n      $sameChannel=$channels[$essidChannel]-1;\n\n      print "$essidChannel $sameChannel";\n      exit $inter;\n      \'`\n      unset \n      interferences=$?\n      essidChannel=`echo $channels | cut -d " " -f 1`\n      sameChannel=`echo $channels | cut -d " " -f 2`\n\n      debug "Interferences: $interferences"\n      debug "essidChannel: $essidChannel"\n      debug "sameChannel: $sameChannel"\n\n      if [[ $essidChannel -gt 0 ]]; then      # found essid\n         if [[ $sameChannel -gt 0 ]]; then\n               writeToEliza $MSG_SSID_SAME_CHANNEL $essidChannel $sameChannel\n         fi\n\n         if [[ $interferences -gt 0 ]]; then\n               writeToEliza $MSG_SSID_INTERFERENCES $essidChannel $interferences\n         fi\n      fi\n    unset IFS\n    fi\n\n   debug "<<checkWLANInterferences"\n\n}\n\n##################################################################################\n#\n#  --- NWEliza\n#\n##################################################################################\n\nfunction NWEliza () {\n   local result\n   local rc\n   local ns\n   local subRC\n   local ip\n\n   askEliza_error=0\n   askEliza_warning=0\n   askEliza_HW_problem=0\n\n#   detectInterfaces      done already for NWCollect\n\n   checkForAtLeastOneNic\n   rc=$?\n   if [[ $rc == 0 ]]; then\t# wired connection and nothing found with lspci\n      writeToEliza $MSG_NO_NIC_FOUND\n      return         # without HW there is no network connection possible :-(\n   fi\n\n   if [[ $rc == 2 ]]; then\t# wireless connection and and nothing found neither with lspci nor lsusb\n\t\t\t\t\t# lsusb check is weak so generate warning only\n      writeToEliza $MSG_NO_NIC_FOUND_WARNING\n   fi\n\n# ---   check for IP address and other possible NI problems\n   checkNetworkInterfaces\n   rc=$?\n   state "cNI:$rc"\n\n   case $rc in\n\n      0) # there is an ip address on the interface\n         debug "--NWEliza IP found"\n\n         # ---   Check whether an external ip address can be pinged\n         checkIPPings\n         rc=$?\n\t PING_OK=$rc\n         if [[ $rc == 1 ]]; then                                 # ping failure for IP\n            checkDefaultRoute\n            rc=$?\n            if [[ $rc == 0 ]]; then\n               writeToEliza $MSG_NO_DEFAULT_GATEWAY_SET\n            else\n               writeToEliza $MSG_CHECK_DEFAULT_GATEWAY_SETTING $checkDefaultRoute_gateway_host $checkDefaultRoute_gateway_nic\n            fi\n         else\n            checkDNS\n            rc=$?\n            if [[ $rc -gt 0 ]]; then                         # ping failure for DNS\n\t       ns=`grep nameserver /etc/resolv.conf`\n               subRC=$?\n               if [[ $subRC != 0 ]]; then\n                  writeToEliza $MSG_NO_NAMESERVER_DEFINED\n               else\n                  ip=`cat /etc/resolv.conf | awk \'/nameserver/ { print $2; exit}\'`\n                  C=`ping -c 3 -W 3 $ip 2>&1`\n                  PING_RES=`echo $C | grep " 0%"`\n                  pingRC=$?\n                  if [[ $pingRC != 0 ]]; then\n                     writeToEliza $MSG_NAMESERVER_NOT_ACCESSIBLE $ip\n                  else\n                     r=`dig @$ip www.google.com +noques +nostats +time=1 | egrep -v "^;|^$" | egrep "IN.*A"`\n                     rc=$?\n                     if [[ $rc != 0 ]]; then\n                        writeToEliza $MSG_NAMESERVER_NOT_VALID $ip\n                     else\n                        writeToEliza $MSG_NAMESERVER_PROBLEM_UNKNOWN $ip\n                     fi\n                  fi\n               fi\n            fi\n         fi\n\n# ---\n# --- Misc other general tests if there is an ip address\n# ---\n\n         if [[ $DISTRO == $SUSE ]]; then\n            checkNetworkManagerConfigured\n            checkModulenl80211\n         fi\n\n\t if [[ $PING_OK == 0 ]]; then\t# MTU check only valid if ping is OK\n            checkMTU\n            subRC=$?\n\n            if [[ $subRC != 0 ]]; then\n               writeToEliza $MSG_POSSIBLE_MTU_PROBLEMS $mtuRequired $defaultGatewayNic $mtuActive\n            fi\n         fi\n     \n         checkForNicsInSameSubnet\n         rc=$?\n\n         if [[ $rc != 0 ]]; then\n            writeToEliza $MSG_DUPLICATE_NETWORKS $checkForNicsInSameSubnet_Result\n         fi\n         ;;\n\n      1) # no NIC\n         debug "--NWEliza no valid NIC found"\n\n         if [[ $CONNECTION == $CONNECTION_WRD ]]; then\n            checkNetworkInterfaceWrd\n         else\n            checkNetworkInterfaceWrlHW\n            checkModulenl80211\n         fi\n         if [[ $DISTRO == $SUSE ]]; then\n            checkModules\n         fi\n         ;;\n\n      2) # no IP found\n         # writeToEliza (no IP found) already done before for all NICs\n         debug "--NWEliza no IP found"\n\n         if [[ $DISTRO == $SUSE ]]; then\n            checkNetworkManagerConfigured\n            checkModulenl80211\n            fi\n\n         if [[ $CONNECTION == $CONNECTION_WRD ]]; then\n            if [[ $DISTRO == $SUSE ]]; then\n               checkDHCP     \t    \n            fi\n\t    checkNetworkInterfaceWrd\n         else\n\t    checkNetworkInterfaceWrlNoIP\n            rc=$?\n            if [[ $rc == 0 ]]; then      # essid set and connected\n               if [[ $DISTRO == $SUSE ]]; then\n                  checkDHCP\n               fi\n            elif [[ $rc == 1 ]]; then      # HW driver problem\n               checkNetworkInterfaceWrlHW\n            elif [[ $rc == 2 ]]; then      # auth problem\n\t       checkNetworkInterfaceWrlAUTH\n             fi\n#             analyzeSpecificNoWLANNICProblems\n         fi\n         if [[ $DISTRO == $SUSE ]]; then\n\t    checkModules\n         fi\n         ;;\n\n      esac\n\n#  ---\n#  --- Tests executed all the time\n#  ---\n\n   checkWLANInterferences\n\n   if [[ $CONNECTION == $CONNECTION_WRL ]]; then\n   \tcheckSSID\n\trc=$?\n\tif [[ $rc != 0 ]]; then\n      \t   writeToEliza $MSG_INVALID_SSID\n        fi\n   fi\n\n   checkForMissingLink\n   rc=$?\n   if [[ $rc != 0 ]]; then\n      writeToEliza $MSG_MISSING_LINK $checkForMissingLink\n   fi\n\n   checkForIPV6\n   rc=$?\n   if [[ $rc != 0 ]]; then\n      writeToEliza $MSG_IPV6_DETECTED\n   fi\n\n   if [[ $DISTRO == $SUSE ]]; then\n      checkKnetworkManager\n      rc=$?\n      if [[ $rc != 0 ]]; then\n         writeToEliza $MSG_KNETWORKMANAGER_ERROR $KNETWORK_IF\n      fi\n   fi\n\n   checkIfWLANTestButWiredOnline\n   rc=$?\n   if [[ $rc != 0 ]]; then\n      writeToEliza $MSG_WLAN_WIRED_ONLINE $checkIfWLANTestButWiredOnline\n   fi\n\n   debug "<<NWEliza $askEliza_error"\n   state "RTDT: $DISTRO_NAME"\n\n  return $askEliza_error\n}\n\n\n##################################################################################\n#\n# --- check if wpa_supplicant and/or networkmanager process is active\n#\n##################################################################################\n\nfunction listActiveProcesses() {\n   local rc\n   local PROCESSES="wpa_supplicant networkmanager nm-applet"\n   local p\n   local result=""\n   local o\n\n   for p in $PROCESSES; do\n\n      o=`ps -eo comm 2>/dev/null | $EGREP -i $p`\n      if [[ -z $o ]]; then\n         result="$result $p:NO"\n      else\n         result="$result $p:YES"\n      fi\n   done\n\n   echo $result >> $LOG\n\n}\n\nfunction listWPAProcesses() {\nlocal o\n\n   o=`ps -eo comm 2>/dev/null | $EGREP -i "networkmanager"`      # networkmanager not used\n   if [[ -z $o ]]; then\n\n        if [[ -z $1 ]]; then\n\n         o=`ps -eo comm 2>/dev/null | $EGREP -i "wpa_supplicant"`\n         if [[ ! -z $o ]]; then\n            IFSO=$IFS\n            IFS=""\n            o=`ps -eo args | $GREP -i [w]pa_supplicant`\n            if [[ $o != "" ]]; then\n               echo $o >> $LOG\n            fi\n            IFS=$IFSO\n         fi\n      else\n         o=`ps -eo comm 2>/dev/null | $EGREP -i "wpa_supplicant"`\n         if [[ ! -z $o ]]; then\n            echo "Active WPA processes"\n         fi\n      fi\n   fi\n}\n\n##################################################################################\n#\n# --- check if ndiswrapper is active and in parallel a Linux driver is loaded\n#\n# --- return 1 if that\'s the case, 0 otherwise\n#\n# --- First suggestion to test this was from IOtz - improved version was suggested from Grothesk\n#\n##################################################################################\n\nfunction checkForNdisWrapperAndLinuxModule {\n\n#local linuxNativeDrivers="rt2x00usb rt73usb rt2400pci rt2500pci rt2500usb rt61pci ipw2200 bcm43xx bcm4306 ipw2100 ipw3945 p54pci ath_pci zd1211rw at76c503a rtl8187 r8187"\n   local rc\n   local q\n   local finalrc=0\n   local module\n   local native\n\n   debug ">>checkForNdisWrapperAndLinuxModule"\n\n   $LSMOD | $GREP -i ndiswrapper > /dev/null\n   rc=$?\n   if [[ $rc != 0 ]]; then    # ndiswrapper not loaded\n      state "NDIS:0"\n      debug "<<checkForNdisWrapperAndLinuxModule 0"\n      return 0;\n   fi\n\n#ts154usb : driver installed\n#        device (083A:4501) present (alternate driver: p54usb)\n\n   module=`ndiswrapper -l | $PERL -e \'<>=~/(\\w+)\\s+:/; print "$1";\'`                            # get module name used in ndiswrapper\n\n   native=`ndiswrapper -l | $PERL -e \'while (<>) {          # get native driver\n        if ($_=~/alternate driver: (\\w+)/) {\n                print "$1"; leave;\n        }\n   }\'`\n\n# ts154usb : driver installed\n# device (083A:4501) present (alternate driver: p54usb)\n\n   ndiswrapper -l  | $GREP -i "alternate driver" > /dev/null\n   rc=$?\n\n   if [[ $rc == 0 ]]; then\n      writeToEliza $MSG_NDISWRAPPER_PROB $module $native\n      finalrc=1;\n   fi\n\n   ndiswrapper -l | $GREP -i "driver invalid" > /dev/null\n   rc=$?\n\n   if [[ $rc == 0 ]]; then\n      writeToEliza $MSG_NDISWRAPPER_FW_PROB $module\n      finalrc=1;\n   fi\n\n# kernel ndiswrapper version 1.47 loaded (smp=yes)\n# kernel: usb 5-7: reset high speed USB device using ehci_hcd and address 8\n# kernel: ndiswrapper (check_nt_hdr:150): kernel is 64-bit, but Windows driver is not 64-bit;bad magic: 010B\n# kernel: ndiswrapper (load_sys_files:216): couldn\'t prepare driver \'sis163u\'\n\n   if (( $USE_ROOT )); then\n\n     $GREP -i "ndiswrapper.*bad magic.*" 2>&1 1>/dev/null $VAR_LOG_MESSAGE_FILE\n      rc=$?\n\n     if [[ $rc == 0 ]]; then\n         writeToEliza $MSG_NDISWRAPPER_ARCH_PROB $module\n         finalrc=1;\n     fi\n   else\n      writeToEliza $MSG_NO_ANALYSIS_AS_USER "ndiswrapper_arch_problems"\n  fi\n\n   state "NDIS:$finalrc"\n   debug "<<checkForNdisWrapperAndLinuxModule $finalrc"\nreturn $finalrc;\n\n}\n\nfunction listLSPCIModules() {\n\n   local i\n   local j\n   local matchString\n\n   debug ">>listLSPCIModules"\n\n   if [[ -z $1 ]]; then\n\n      if [[ $CONNECTION == $CONNECTION_WRL ]]; then\n         matchString="network.*controller|ethernet.*controller.*(wireless|802\\.11)"\n      else\n         matchString="ethernet.*controller"\n      fi\n\n      for i in $($LSPCI -nn | $EGREP -i $matchString | $PERL -n -e \'/\\[(\\w+:\\w+)\\]/; print "$1\\n";\'); do\n\n        VENDORID=$(echo $i | cut -d ":" -f 1);\n        DEVICEID=$(echo $i | cut -d ":" -f 2);\n\n        echo "Available kernelmodules for VendorId:DeviceId - $i" >> $LOG\n\n        for j in $(find /lib/modules/`uname -r` -name "*.ko") ; do \\\n           MODULE=${j##*/}\n           MODULE=${MODULE/.ko/}\n           echo "Module: $MODULE" && /sbin/modinfo "$j" | $GREP -i "$VENDORID" | $GREP -i "$DEVICEID" ; \\\n        done | while read ; do\n              $GREP -B1 alias | head -n 1 >> $LOG\n              done\n      done\n   else\n      echo "find /lib/modules/\\`uname -r\\` -name \\"*.ko\\""\n   fi\n\n   debug "<<listLSPCIModules"\n\n}\n\n##################################################################################\n#\n# --- Extract some useful info from hwinfo (SUSE and debian only)\n#\n##################################################################################\n\nfunction listHWInfo() {\n\n   debug ">>listHWInfo"\n\n   if `isCommandAvailable hwinfo`; then\n\n      if [[ -z $1 ]]; then\n\n         $PERL -e \'\n\n          my $MATCH = qr /Model:|Vendor:|Device:|Driver:|Driver Modules:|Subvendor:|Subdevice:|Device File:|^\\d+:|Link detected|Driver Status:|Driver Activation Cmd:/;\n          my $line;\n\n            foreach $line (`\'$HWINFO\' --netcard`) {\n               if ($line =~ /$MATCH/) {\n                  print "$line";\n               }\n            }\n         \'\n      else\n         echo "hwinfo (filtered)"\n      fi\n\n   elif `isCommandAvailable lshw`; then\n\n      if [[ -z $1 ]]; then\n         $PERL -e \'\n\n          my $MATCH = qr /product:|vendor:|capabilities:|configuration:/;\n          my $line;\n\n            foreach $line (`\'$LSHW\' -C network`) {\n               if ($line =~ /$MATCH/) {\n                  print "$line";\n               }\n            }\n         \'\n      else\n         echo "lshw -C network (filtered)"\n      fi\n\n   fi\n\n   debug "<<listHWInfo"\n\n}\n\nfunction ifConfig() {\n\n    $PERL -e \'\n    my $DEVICES="^(en|wl|eth|wlan|ra|ath|dsl)";\n\n       my $line;\n       my $startSequence=0;\n       foreach $line (qx %\'$IFCONFIG\'%) {\n          if ($line =~ $DEVICES) {\n             print $line;\n             $startSequence=1;\n          }\n          elsif ($line =~ /^$/) {\n             $startSequence=0;\n          }\n          elsif ($startSequence == 1) {\n             print $line;\n          }\n       }\n    \'\n}\n\n##################################################################################\n#\n# --- Check whether there is a link missing on network interface\n#\n##################################################################################\n\n# Device File: eth0\n#  Memory Range: 0xdb800000-0xdb803fff (rw,non-prefetchable)\n#  I/O Ports: 0xd800-0xd8ff (rw)\n#  IRQ: 18 (126399 events)\n#  HW Address: 00:0e:a6:3b:dd:06\n#  Link detected: yes\n\nfunction checkForMissingLink () {\n\n   debug ">>checkForMissingLink"\n\n   if [[ $DISTRO == $SUSE ]]; then\n\n      if [[ $CONNECTION == $CONNECTION_WRD ]]; then\n         CONN="en|eth"\n         PARM="--netcard"\n      else\n         CONN="en|wl|eth|ath|wlan|ra"\n         PARM="--wlan"\n      fi\n\n      checkForMissingLink=`$PERL -e \'\n\n          my $line;\n          my $multiple=0;\n          my $devices="";\n          foreach $line (qx %\'$HWINFO\' \'$PARM\'%) {\n               if ($line =~ /Link detected: no/) {\n                  if ($device =~ \'$CONN\') {\n                     if ($multiple eq 1) {\n                        $devices="$devices,$device";\n                     }\n                     else {\n                        $devices="$device";\n                        $multiple=1;\n                      }\n                  }\n               }\n               if ($line =~ /Device File.*: ([a-z0-9]+)/) {\n                  $device=$1;\n               }\n            }\n         print $devices\n         \'`\n   fi\n\n   debug "<<checkForMissingLink $checkForMissingLink"\n\n   if [ "$checkForMissingLink" != "" ]; then\n      return 1\n   fi\n}\n\n##################################################################################\n#\n# Extract some info from /etc/sysconfig/network (SUSE only)\n#\n##################################################################################\n\nfunction listSuSEConfig() {\n   local m\n\n   debug ">>listSuSEConfig"\n\n   if [[ $DISTRO == $SUSE ]]; then\n      if [[ -z $1 ]]; then\n         $EGREP -i "^[^#].*(persistent|networkmanager)" /etc/sysconfig/network/config \n      else\n         m=`colorate "egrep -i \\"^[^#].*(persistent|networkmanager)\\" /etc/sysconfig/network/config"`\n         echo $m\n      fi\n   fi\n\n   debug "<<listSuSEConfig"\n\n}\n\n##################################################################################\n#\n#  -- Masquerade sensitive informations\n#\n##################################################################################\n\n#\n# This function masquerades mac addresses\n#\n# All identical macs get the same masqueraded values so xref is possible\n#\n\nfunction masqueradeMacs() {\n\n   debug ">>masqueradeMACs"\n\n   cat "$FINAL_RESULT" | $PERL -e \'\n\n   my $MAC_ADDRESS = qr /(([\\da-fA-F]{2}\\:){5}[\\da-fA-F]{2})/;\n   my $MAC_MASK="#";\n   my $mac_cnt=0;\n   my %macAddresses;\n\n   while (<>) {\n\n       $line=$_;\n       pos($line)=0;\n\n       while ($line =~ /($MAC_ADDRESS)/g) {\n\n        my $mac = $1;\n             my $privateMac = $mac;\n        my $normalizedMac = uc($mac);\n\n             if ( $macAddresses{$normalizedMac} ) {\n                   $privateMac = $macAddresses{$normalizedMac};        # get masqueraded mac\n             }\n             else {\n               $mac_cnt++;\n               $privateMac =~ s/\\w/$MAC_MASK/g;\n   #           $privateMac =~ s/(.)./$1$MAC_MASK/g;\n               $privateMac =~ s/$MAC_MASK$/$mac_cnt/;\n               $macAddresses{$normalizedMac} = $privateMac;        # cache mac\n             }\n             s/$mac/$privateMac/;\n         }\n      print "$_";\n   }\n\n   exit $mac_cnt;\n\n   \' > "$FINAL_RESULT_mm_$$"\n\n# writeToEliza $MSG_MASQ_MAC $?\n\n   mv "$FINAL_RESULT_mm_$$" "$FINAL_RESULT"\n\n   debug "<<masqueradeMACs"\n\n}\n\n#\n# This function masquerades ESSIDs\n#\n# All identical ESSID get the same masqueraded values so xref is possible\n#\n\nfunction masqueradeESSIDs() {\n\n   debug ">>masqueradeESSIDs"\n\n   cat "$FINAL_RESULT" | $PERL -e \'\n\n   my $ESSID_MASK="\'$ESSID_MASK\'";\n   my $essid_cnt=0;\n   my %essidAddresses;\n   my $tick=chr(0x27);    # tick mark\n\n   while (<>) {\n\n   #         iwcsan                   ifcfg                              ssid log message\n       if (/ESSID:"(.+)"/ || /WIRELESS_ESSID=${tick}(.+)${tick}/ || /--- WLAN SSID.*: (.+)/ ) {\n\n             my $essid = $1;\n             my $privateEssid = $essid;\n\n             if ( $essidAddresses{$essid} ) {\n                   $privateEssid = $essidAddresses{$essid};        # get masqueraded essid\n             }\n             else {\n               $essid_cnt++;\n               $privateEssid = "${ESSID_MASK}${essid_cnt}";\n   #            $privateEssid =~ s/(.)./$1#/g;\n               $essidAddresses{$essid} = $privateEssid;            # cache essid\n             }\n             s/$essid/$privateEssid/;\n         }\n      print "$_";\n   }\n\n   exit $essid_cnt;\n\n   \' > "$FINAL_RESULT_ee_$$"\n\n   mv "$FINAL_RESULT_ee_$$" "$FINAL_RESULT"\n\n   debug "<<masqueradeESSIDs"\n\n}\n\n#\n# This function masquerades IPs\n#\n# All private IP addresses (e.g. 192er numbers, 10er numbers etc) are NOT masqueraded\n## All identical ips get the same masqueraded values so xref is possible\n#\n\nfunction masqueradeIPs() {\n\n   debug ">>masqueradeIPs"\n\n   cat "$FINAL_RESULT" | $PERL -e \'\n\n   my $IP_ADDRESS = qr /(([\\d]{1,3}\\.){3}[\\d]{1,3})/;\n   my $IP_MASK="%";\n   my $ip_cnt=0;\n   my %ipAddresses;\n   my $line;\n   my $route_flag=0;\n   my $line_cnt;\n   my $inBlock=0;\n\n   while (<>) {\n\n       if ($_ =~ "^=+.*(route|ifconfig|iwconfig|cat /etc/hosts|cat /etc/resolv|cat /etc/sysconfig/network/ifcfg)") {\n         $inBlock=1;\n       }\n       else {\n\t\t if ( $_ =~ "^=+" ) {                         # route block (and others) ends\n\t\t\t$inBlock=0;\n\t\t\t$route_flag=0;\n\t\t }\n       }\n\n      if ( $inBlock == 1) {\n\n         if ($_ =~ "^=+ route") {                      # route block starts\n            $route_flag=1;\n         }\n\n         $line=$_;\n         pos($line)=0;\n         $line_cnt=0;\n\n         while ($line =~ /($IP_ADDRESS)/g ) {\n\n            if ($_ =~ "Ping of") {                         # external ping\n               next;\n            }\n\n            my $ip = $1;\n            $line_cnt++;\n\n            my $privateIp = $ip;\n            if ( $` =~ /Mask[e]?/) {            # skip mask in ifconfig (German and English locale)\n               next;\n            }\n\n            if ($route_flag == 1 && $line_cnt==3) {      # skip mask in route command\n               next;\n            }\n\n            if ( $1 !~ /^192\\.168\\./\n               && $1 !~ /^127\\./\n               && $1 !~ "0\\.0\\.0\\.0"\n               && $1 !~ "255\\.0\\.0\\.0"\n               && $1 !~ "255\\.255\\.0\\.0"\n               && $1 !~ "255\\.255\\.255\\.0"\n               && $1 !~ "255\\.255\\.255\\.255"\n               && $1 !~ "^169\\."\n               && $1 !~ "^10\\."\n               && $1 !~ "^172\\.([1][6-9]|2[1-9]|3[0-1])" ) {\n\n               if ( $ipAddresses{$ip} ) {\n                   $privateIp = $ipAddresses{$ip};                 # get masqueraded ip\n               }\n               else {\n                  $ip_cnt++;\n                  $privateIp =~ s/\\d+\\.\\d+/%%%.%%%/;\n   #               $privateIp =~ s/\\d/$IP_MASK/g;\n   #               $privateIp =~ s/$IP_MASK$/$ip_cnt/;\n                  $ipAddresses{$ip} = $privateIp;                 # cache ip\n               }\n            s/$ip/$privateIp/;\n            }\n         }\n     }\n     print "$_";\n   }\n\n   exit $ip_cnt;\n\n   \' > "$FINAL_RESULT_mi_$$"\n\n   mv "$FINAL_RESULT_mi_$$" "$FINAL_RESULT"\n\n   debug "<<masqueradeIPs"\n\n}\n\n#function stripWLANKeys () {\n#   $PERL -e \'while (<>) {\n#      if (/\\S+/) {\n#            print "$_";\n#      }\n#   }\' $1\n#}\n\n\n##################################################################################\n#\n# --- Helperfunctions\n#\n##################################################################################\n\nfunction stripEmptyLines () {\n   $PERL -e \'while (<>) {\n        if (/\\S+/) {\n                print "$_";\n        }\n      }\' $1\n}\n\nfunction joinLines () {\n   $PERL -e \'while (<>) {\n               chomp;\n               print "$_ ";\n            }\' $1\n}\n\nfunction stripWLANKeys() {\n\n$PERL -e \'\n\n$mask="@@@@@@";\n%keywords = ( "WIRELESS_KEY" => 1,              # SUSE -> /etc/sysconfig/network/ifcfg-*\n             "WIRELESS_DEFAULT_KEY" => 1,\n             "WIRELESS_KEY_0" =>1,\n             "WIRELESS_KEY_1" =>1,\n             "WIRELESS_KEY_2" =>1,\n             "WIRELESS_KEY_3" =>1,\n             "WIRELESS_KEY_LENGTH" =>1,\n             "WIRELESS_WPA_IDENTITY" => 1,\n             "WIRELESS_WPA_PASSWORD" => 1,\n             "WIRELESS_WPA_PSK" => 1,\n             "WIRELESS_ESSID" => 1,\t\t\t\t# Mageia\n             "KEY" => 1,                        # RedHat -> /usr/share/doc/initscripts*/sysconfig.txt\n\t\t\t "WIRELESS_ENC_KEY" => 1,\t\t\t\n             "wpa-psk" => 1,                    # Debian -> /etc/network/interfaces\n             "wpa-ssid" => 1,                 \n             "wireless-key" => 1,\n                                                # Arch ->\n             "WLAN_KEY" => 1,                   # Slackware -> /etc/rc.d/rc.inet1.conf\n             "WPAPSK" => 1,\n        );\n\n\nwhile (<>) {\n        my ($key,$value) = /([A-Za-z0-9_\\-]+)[\\s=]+(.*)$/;\n        if ($value) {\n                if ( exists($keywords{$key})) {\n                        s/\\Q$value\\E/$mask/;      # just to allow ? in keys as starting character\n                }\n        }\n        print;\n}\' $1\n\n}\n#################################################################################\n#\n# NWCollect: List network configuration\n#\n##################################################################################\n\nfunction listNetworkConfigs () {\n\n   local cmd\n   local c\n\n   if (( ! $CONFIG_READABLE )); then\n   \t\twriteToEliza $MSG_NO_ANALYSIS_AS_USER "list_network_configuration_files"\n\t\treturn 0\n   fi\n\n   cmd=(\'/etc/sysconfig/network/ifcfg-[earwd]*\' # SUSE\n        \'/etc/sysconfig/network-scripts/ifcfg-[earwd]*\' #REDHAT\n        \'/etc/network/interfaces\' # DEBIAN\n        \'/etc/rc.conf\' # ARCH\n        \'/etc/rc.d/rc.inet1.conf\') # SLACKWARE\n\n   if [[ -z $1 ]]; then\n\t\n\t   c=$(ls ${cmd[$DISTRO]} 2>&1 1>/dev/null)\n\t   if [[ "$?" = "0" ]]; then\t# if there exists files\n\t      c="for f in \\$(ls "${cmd[$DISTRO]}"); do echo \\"--- \\$f\\"; cat \\$f | "$EGREP" -v \\"^#|^$\\" | "$EGREP" -v \\"=\'\'\\"; done"\n\t      eval $c | stripWLANKeys\n\telse\n\t\techo "No config files found"\n\tfi\n   else\n      echo "cat ${cmd[$DISTRO]} | grep -v \\"^#|^$\\" | grep -v \\"=\'\'\\""\n   fi\n\n}\n\n##################################################################################\n#\n# Open output file if possible\n#\n##################################################################################\n\nfunction openResultFile() {\n\n   if [[ $CND_INTERNATIONAL_POST == "0" && $CND_OPEN_RESULT_FILE == "1" && $UID -ne 0 && $GUI -eq 0 ]]; then\n      if [[ -n `which xdg-open 2>/dev/null` ]]; then\n         `xdg-open "$FINAL_RESULT" 2>/dev/null &`\n      fi\n   fi\n}\n\nfunction colorate () {  # message\n\n   local m\n   local sl\n   sl=${#SEPARATOR}\n   m="$CMD_PREFIX $1 $SEPARATOR"\n\n   echo ${m:0:$sl}\n\n}\n\n\n##################################################################################\n#\n#  --- Collect PD data\n#\n##################################################################################\n\n#\n# --- Commands executed collect valuable informations about the network and it\'s configuration\n#\nfunction collectNWData () {   #listOnly\n\n   debug ">>collectNWData"\n\n   # standard\n   i=0;FLAG[$i]="s";MSG[$i]="cat /etc/*[-_]release || cat /etc/*[-_]version";CMD[$i]="(ls /etc/*[-_]release 2>/dev/null && cat /etc/*[-_]release) || (ls /etc/*[-_]version && cat /etc/*[-_]version)"\n   i=$i+1;FLAG[$i]="s";MSG[$i]="uname -a";CMD[$i]="uname -a"\n   i=$i+1;FLAG[$i]="s";MSG[$i]="";CMD[$i]="listNetworkConfigs"\n#   i=$i+1;FLAG[$i]="s";MSG[$i]="";CMD[$i]="dhcpTests"\n   i=$i+1;FLAG[$i]="s";MSG[$i]="ping tests";CMD[$i]="pingTests"\n   i=$i+1;FLAG[$i]="s";MSG[$i]="cat /etc/resolv | grep -i \\"nameserver\\"";CMD[$i]="cat /etc/resolv.conf | $GREP -v \\"^#\\|^[ ]*$\\" | $GREP -i \\"nameserver\\""\n   i=$i+1;FLAG[$i]="s";MSG[$i]="cat /etc/hosts";CMD[$i]="cat /etc/hosts | $GREP -v \\"^#\\|^$\\" | $GREP -v \\"::\\""\n   i=$i+1;FLAG[$i]="s";MSG[$i]="(route -n && route -A inet6 -n) | egrep \\"(en|wl|eth|ath|ra|wlan|dsl|ppp)\\"";CMD[$i]="($ROUTE -n && $ROUTE -A inet6 -n) | $EGREP \\"(en|wl|eth|ath|wlan|ra|dsl|ppp)\\""\n   i=$i+1;FLAG[$i]="s";MSG[$i]="ifconfig (filtered for en|wl|eth|wlan|ra|ath|dsl|ppp)";CMD[$i]="$IFCONFIG | awk \'/^(en|wl|eth|eth|wlan|ra|ath|dsl|ppp)/ { ifc=\\$1 } !NF { ifc=\\"\\" } ifc { print }\'"\n   i=$i+1;FLAG[$i]="h";MSG[$i]="lspci";CMD[$i]="$PERL -e \'qx/uname -r/ =~/(\\d+)\\.(\\d+)/; exit  (\\$1 > 2 || ( \\$1 == 2 && \\$2 >= 6))\' || $LSPCI -nnk | $EGREP -i -A 2 \'(ethernet|network)\'; $PERL -e \'qx/uname -r/ =~/(\\d+)\\.(\\d+)/; exit  (\\$1 > 2 || ( \\$1 == 2 && \\$2 >= 6))\' && $LSPCI -nn | $EGREP -i \'(ethernet|network)\'"\n#   i=$i+1;FLAG[$i]="h";MSG[$i]="";CMD[$i]="listLSPCIModules"\n   i=$i+1;FLAG[$i]="h";MSG[$i]="lsusb | grep -v \\"root hub\\"";CMD[$i]="which lsusb 2>/dev/null 1>&2 && lsusb | $GREP -v \\"root hub\\";which lsusb 2>/dev/null 1>&2 || echo \\"lsusb not available. usbutils package needs to be installed\\""\n   i=$i+1;FLAG[$i]="h";MSG[$i]="";CMD[$i]="listHWInfo"\n   i=$i+1;FLAG[$i]="h";MSG[$i]="lsmod (filtered)";CMD[$i]="listLoadedModules"\n   i=$i+1;FLAG[$i]="w";MSG[$i]="iwconfig";CMD[$i]="$IWCONFIG 2>&1 | awk \'/^(en|wl|eth|wlan|ra|ath|dsl|ppp)/ { ifc=\\$1 } !NF { ifc=\\"\\" } ifc { print }\' | $SED \\"s/\\(Encryption key:\\)\\([^o][^f][^f][^ ]*\\)\\(.*\\)/\\1@@ @@@-@@@@-@@@@-@@@@-   @@@@-@@@@@@@\\3/\\"" \n   i=$i+1;FLAG[$i]="w";MSG[$i]="";CMD[$i]="listFirmware"\n   i=$i+1;FLAG[$i]="w";MSG[$i]="iwlist scanning (filtered)";CMD[$i]="detectAPs"\n   i=$i+1;FLAG[$i]="w";MSG[$i]="ndiswrapper -l";CMD[$i]="( $LSMOD | $GREP -i ndiswrapper > /dev/null ) && ndiswrapper -l; ( $LSMOD | $GREP -i ndiswrapper > /dev/null ) || echo \\"No ndiswrapper module loaded\\""\n   i=$i+1;FLAG[$i]="w";MSG[$i]="Active processes";CMD[$i]="listActiveProcesses"\n   i=$i+1;FLAG[$i]="w";MSG[$i]="";CMD[$i]="listWPAProcesses"\n   i=$i+1;FLAG[$i]="w";MSG[$i]="";CMD[$i]="listSuSEConfig"\n   i=$i+1;FLAG[$i]="w";MSG[$i]="";CMD[$i]="listrfkill"\n   i=$i+1;FLAG[$i]="w";MSG[$i]="Actual date for bias of following greps";CMD[$i]="echo \\"`date +\\"%T %F\\"`\\" 1>&2"\n   i=$i+1;FLAG[$i]="w";MSG[$i]="grep -i radio ${VAR_LOG_MESSAGE_FILE} | tail -n 5";CMD[$i]="[ $UID -eq 0 ] && ( $GREP -i radio ${VAR_LOG_MESSAGE_FILE} | $TAIL -n 5 ); [ $UID -ne 0 ] && echo \\"??? Unable to access ${VAR_LOG_MESSAGE_FILE} to check for WLAN errors as normal user\\""\n   i=$i+1;FLAG[$i]="w";MSG[$i]="dmesg | grep -i radio | tail -n 5";CMD[$i]="dmesg | $GREP -i radio | $TAIL -n 5"\n   i=$i+1;FLAG[$i]="w";MSG[$i]="tail -n $NUMBER_OF_LINES_TO_CHECK_IN_VAR_LOG_MESSAGES ${VAR_LOG_MESSAGE_FILE} | $GREP -i firmware | tail -n 10";CMD[$i]="[ $UID -eq 0 ] && (tail -n $NUMBER_OF_LINES_TO_CHECK_IN_VAR_LOG_MESSAGES ${VAR_LOG_MESSAGE_FILE} | $GREP -i firmware | $TAIL -n 10); [ $UID -ne 0 ] && echo \\"??? Unable to access ${VAR_LOG_MESSAGE_FILE} to check for firmware errors as normal user\\""\n   i=$i+1;FLAG[$i]="s";MSG[$i]="egrep \'en|wl|eth|ath|wlan|ra|ppp\' /etc/udev/rules.d/*net_persistent* /etc/udev/rules.d/*persistent-net*";CMD[$i]="$EGREP \'en|wl|eth|ath|wlan|ra|ppp\' /etc/udev/rules.d/*net_persistent* /etc/udev/rules.d/*persistent-net* 2>/dev/null | $GREP -v \\":#\\|:$\\" 2>/dev/null"\n   i=$i+1;FLAG[$i]="w";MSG[$i]="egrep -r \'(en.*|wl.*|eth|ath|wlan|ra)[0-9]+\' /etc/modprobe.*|egrep -v -i \'#|blacklist\'";CMD[$i]="$EGREP -r \'(en.*|wl.*|eth|ath|wlan|ra)[0-9]+\' /etc/modprobe.*|$EGREP -v -i \'#|blacklist\'"\n   i=$i+1;FLAG[$i]="f";MSG[$i]="arp -n";CMD[$i]="$ARP -n"\n   i=$i+1;FLAG[$i]="f";MSG[$i]="iptables -L -vn";CMD[$i]="$IPTABLES -L -vn"\n   i=$i+1;FLAG[$i]="f";MSG[$i]="cat /etc/sysconfig/SuSEfirewall2";CMD[$i]="cat /etc/sysconfig/SuSEfirewall2 | $GREP -v \\"^#\\|^$\\""\n   i=$i+1;FLAG[$i]="f";MSG[$i]="cat /proc/sys/net/ipv4/ip_forward";CMD[$i]="cat /proc/sys/net/ipv4/ip_forward"\n\n   # count number of eligible tests\n\n   NUMBER_OF_TESTS=0\n   i=0\n   while [ -n "${CMD[$i]}" ]; do\n      R=`echo $FLAGS | grep "${FLAG[$i]}"`\n      if [[ $? == 0 ]]; then\n         let NUMBER_OF_TESTS=NUMBER_OF_TESTS+1\n      fi\n      let i=i+1\n   done\n\n   i=0      # counter of all possible tests\n   pi=0      # counter of eligible tests\n\n   # process tests and print progress in percent\n\n   while [ -n "${CMD[$i]}" ]; do\n\n   #   echo $FLAGS ${FLAG[$i]}\n      R=`echo $FLAGS | grep "${FLAG[$i]}"`\n\n      if [[ $? == 0 ]]; then\n   #      fill log file with information\n         debug "*** ${CMD[$i]} "\n         if [[ -z ${MSG[$i]} ]]; then\n            msg=`eval ${CMD[$i]} m`\n            if [[ -z $msg ]]; then         # no report for this distro\n               let i=i+1\n               let pi=pi+1\n               continue\n            fi\n   #         echo $SEPARATOR >> $LOG\n   #         echo "*** $msg" >> $LOG\n            set -f\n            header=`colorate "$msg"`\n            echo $header >> $LOG\n            debug "-- $msg"\n            set +f\n         else\n   #         echo $SEPARATOR >> $LOG\n   #         echo "*** ${MSG[$i]}" >> $LOG\n            set -f\n            header=`colorate "${MSG[$i]}"`\n            echo $header >> $LOG\n            debug "-- ${MSG[$i]}"\n            set +f\n         fi\n         processingMessage $pi $NUMBER_OF_TESTS $msg\n         eval ${CMD[$i]} 2>> $LOG 1>> $LOG\n         let pi=pi+1\n      fi\n      let i=i+1\n\n   done\n   processingMessage $NUMBER_OF_TESTS $NUMBER_OF_TESTS   # display 100%\n   sleep 1\n   processingMessage -1               # clean output area now\n   debug "<<collectNWData"\n}\n\n# help text\n\nfunction usage () { # exitcode\n\n   echo -e $VERSION_STRING \n   echo $LICENSE\n   echo "Analyze system for common network configuration problems"\n   echo "and collect network problem determination information for futher problem determination"\n   echo "Invocation: $MYSELF"\n   echo "Parameters:"\n   echo "-c : Connection (1-2)"\n   echo "-d : Write debug messages"\n   echo "-e : ESSID used for WLAN"\n   echo "-f : Collect info for routers, i.e. firewall rules, firewall configurations etc"\n   echo "-g : script called by GUI wrapper"\n   echo "-h : Print this help message"\n   echo "-i : International posting"\n   echo "-m : Turn MAC masquerading off"\n   echo "-n : Turn NWEliza off"\n   echo "-o : Executionhost (1-2)"\n   echo "-p filename : Filename of result file (default: collectNWData.txt)"\n   echo "-r : Invoke script as root"\n   echo "-s : Don\'t open resultfile in editor"\n   echo "-t : Topology (1-4)"\n   echo "-u : Don\'t run script as root"\n   echo "-v : Print script version"    \n   echo "-x : Trace script flow. Creates huge output"\n\n   if [[ -z $1 ]]; then\n      exit 0\n   else\n      exit $1\n   fi\n}\n\n#################################################################################\n#################################################################################\n#################################################################################\n####\n####                                 main\n####\n#################################################################################\n#################################################################################\n#################################################################################\n\nqueryDistro\n\n# modules are not known right now - just use plain bash commands\n\n##################################################################################\n#\n# handle invocation options\n#\n##################################################################################\n\n# defaults\n\nDEBUG="off"\t\t\t\t# debug messages\nTRACE=0\t\t\t\t# detailed trace (-x -v)\nFLAGS="-shc"                \t# default flags\nopt="$@"\nNWELIZA_ENABLED=1             # enabled for all distros\nUSE_ROOT=1                    # default: Call script as root\nUSE_USER_AS_PARM=0\nCND_OPEN_RESULT_FILE=1\nMASQUERADE_MAC=1\nROOTOPTION=0\nCONNECTIONTYPEOPTION=0\nEXECUTIONHOSTOPTION=0\nESSIDOPTION=""\nINTERNATIONALOPTION=0\nGUI=0\nCLEANUP=0\nCLEANALL=0\n\n# parse args\nwhile getopts ":a :c: :d :e: :f :g :h :i :k :l :m :n :o: :p: :r :s :t: :u :v :x" opt\ndo \n   case "$opt" in\n   a) CLEANALL=1;;\n   c) CONNECTIONTYPEOPTION=$OPTARG\n      if [[ $OPTARG < 1 || $OPTARG > 2 ]]; then\n         echo "Argument for option -$opt should be 1 or 2"\n         exit 127\n      fi;;\n   d) DEBUG="on";;\n   e) ESSIDOPTION=$OPTARG;;\n   f) FLAGS="${FLAGS}f";;\n   g) GUI=1\n      VERSION_STRING="$VERSION_STRING -iGUI-";;\n   h) usage 127;;\n   i) INTERNATIONALOPTION=1;;\n   k) CLEANUP=1;;\n   m) MASQUERADE_MAC=0;;\n   n) NWELIZA_ENABLED=0;;\n   o) EXECUTIONHOSTOPTION=$OPTARG\n      if [[ $OPTARG < 1 || $OPTARG > 2 ]]; then\n         echo "Argument for option -$opt should be 1 or 2"\n         exit 127\n      fi;;\n   p) OUTPUT_FILE=$OPTARG;;\n   r) ROOTOPTION=1;;\n   s) CND_OPEN_RESULT_FILE=0;;\n   t) TOPOLOGYTYPEOPTION=$OPTARG\n      if [[ $OPTARG < 1 || $OPTARG > 4 ]]; then\n         echo "Argument for option -$opt should be 1,2,3 or 4"\n         exit 127\n      fi;;\n   u) USE_USER_AS_PARM=1;;\n   v) echo -e $VERSION_STRING;\n\t  echo $LICENSE\n      exit 0;;\n   \\?) echo "Unknown option \\"-$OPTARG\\"."\n         usage 1;;\n   :) echo "Option \\"-$OPTARG\\" requires an argument."\n         usage 127;;\n    esac\ndone\n\n#################################################################################\n# Cleanup function for GUI\n#################################################################################\n\nif [[ $GUI -ne 0 && $CLEANUP -ne 0 ]]; then\n   cleanupTempFiles\n   exit 0\nfi\n\nif [[ $GUI -ne 0 && $CLEANALL -ne 0 ]]; then\n   cleanupFiles\n   exit 0\nfi\n\n\n#################################################################################\n# Make sure script runs in a console\n#################################################################################\n\nif [[ $GUI -eq 0 ]]; then\n   tty -s;\n   if [ $? -ne 0 ]; then\n   #  konsole --noclose -T "collectNWData.sh" --vt_sz 132x25 -e "$0";\n     konsole -e "$0"\n     exit;\n   fi\nfi\n\nif [[ $CND_VERSION_STRING == "" ]]; then\n   echo\n   echo -e $VERSION_STRING\n   echo $LICENSE\n   echo\n   export CND_VERSION_STRING=$VERSION_STRING\n   isLanguageSupported\n   rc=$?\n   if (( ! $rc )); then\n      writeToConsole $MSG_ASK_FOR_XLATION\n      writeToConsole $MSG_EMPTY_LINE\n   fi\nfi\n\nif (( ! $USE_USER_AS_PARM )); then      # invocation not as normal user requested\n   if [ $UID -eq 0 -o $ROOTOPTION == "1" ]; then         # invoked by root already of root option selected\n      USE_ROOT=1\n   else\n      USE_ROOT=0\n      if [[ $GUI -eq 0 ]]; then      \n      \t yes=`getLocalizedMessage $MSG_ANSWER_CHARS_YES`\n      \t no=`getLocalizedMessage $MSG_ANSWER_CHARS_NO`\n      \t answer=""            # ask user for his choice\n      \t while [[ $answer == "" ]]; do\n\t        writeToConsoleNoNL $MSG_ASK_FOR_ROOT\n     \t    read a\n         \tif [[ $a == "" ]]; then\n            \tanswer=${yes:0:1}      # default\n         \telse\n            \tcase "$a" in\n               \t[$yes]) answer=${yes:0:1};;\n               \t[$no]) answer=${no:0:1};;\n            \tesac\n         \tfi\n      \tdone\n      \tif [[ $answer == ${yes:0:1} ]]; then\n        \t USE_ROOT=1\n      \tfi\n      fi\n   fi\nelse\n   USE_ROOT=0\nfi\n\nif [[ $CND_INTERNATIONAL_POST == "" ]]; then\n\n   CND_INTERNATIONAL_POST=0\n   if (( $INTERNATIONALOPTION )); then\n      CND_INTERNATIONAL_POST=1\n   else\n      if [[ $GUI -eq 0 ]]; then         \n      \t isLanguageSupportedAndNotEnglish\n         lsup=$?\n      \t if (( $lsup )); then\n         \tyes=`getLocalizedMessage $MSG_ANSWER_CHARS_YES`\n         \tno=`getLocalizedMessage $MSG_ANSWER_CHARS_NO`\n         \tanswer=""            # ask user for his choice\n         \twhile [[ $answer == "" ]]; do\n            \twriteToConsoleNoNL $MSG_ASK_LANG\n            \tread a\n            \tif [[ $a == "" ]]; then\n               \t\tanswer=${no:0:1}  # default\n            \telse\n               \t\tcase "$a" in\n                  \t\t[$yes]) answer=${yes:0:1};;\n                  \t\t[$no]) answer=${no:0:1};;\n             \t\tesac\n            \tfi\n         \tdone\n         \tif [[ $answer == ${yes:0:1} ]]; then\n            \tCND_INTERNATIONAL_POST=1\n         \tfi\n         fi\n      fi\n   fi\nfi\n\n#  invoke script as root if requested\n\nif (( $USE_ROOT )); then\n   if [ $UID -ne 0 ]; then\n      INVOCATION_DIR=`pwd`\n\n      export CND_USER=$USER\n      export CND_OPEN_RESULT_FILE=$CND_OPEN_RESULT_FILE\n      export CND_INTERNATIONAL_POST=$CND_INTERNATIONAL_POST\n\n      if which sudo &> /dev/null; then\n         debug "Starting sudo as $USER ..."\n     \t sudo -p "Enter password of user %p" -E "$0" $*            # try sudo first\n         if [ $? == 1 ]; then         # failure\n            writeToConsole $MSG_MAIN_BECOME_ROOT\n            debug "Starting su1 as $USER ..."\n            su -p -c "$0 $*"   # now use su, dont suppress &2 (pwd prompt)\n         fi\n      else\n         writeToConsole $MSG_MAIN_BECOME_ROOT\n         debug "Starting su2 as $USER ..."\n         su -p -c "$0 $*"   # now use su, dont suppress &2 (pwd prompt)\n      fi\n      openResultFile\n      exit $?\n   fi\nfi\n\nshift $(($OPTIND - 1))            # pop invocation parms\n\n# check whether all required progs are available and locate their path\n# set uppercase vars of command to fq path\n\nMODS="$MODS_ALL $MODS_OPT"\n\nMODS_MISSING_LIST=""\nMODS_MISSING=0\n\nfor mod in $MODS; do\n#   echo "--------- $mod"\n   # prog name in lower case\n   lwr=`echo $mod | perl -e "print lc(<>);"`\n   mod=`echo $mod | sed \'s/-/_/\'`\n   # store detected path\n   p=`find {/sbin,/usr/bin,/usr/sbin,/bin} -name $lwr | head -n 1`\n   eval "$mod=\\"${p}\\""\n   eval "c=\\${${mod}}"\n#   echo "------m $mod"\n#   echo "------c $c"\n   if [ ! -x "$c" ]; then\n#        echo "--???-- $mod"\n\tif [[ "$MODS_ALL" == *"$mod"* ]]; then\n#            echo "--!!!-- $mod"\n            if [ -z $MODS_MISSING_LIST ]; then\n               MODS_MISSING_LIST=$lwr\n            else\n               MODS_MISSING_LIST="$MODS_MISSING_LIST,$lwr"\n\t    fi\n            MODS_MISSING=1\n\t fi\n    fi\ndone\n\nif (($MODS_MISSING)); then\n      writeToConsole $MSG_MAIN_PROG_REQUIRED $MODS_MISSING_LIST\n      exit 127\nfi\n\nif [[ $TRACE != 0 ]]; then\n   set -o verbose\n   set -o xtrace\nfi\n\n#################################################################################\n# --- Now do your job\n#################################################################################\n\nif [[ -e "$FINAL_RESULT" ]]; then\n\n   rm "$FINAL_RESULT" 2>/dev/null\n\n   if [ $? != 0 ]; then\n      echo "Can\'t delete $FINAL_RESULT"\n      exit 255\n   fi\nfi\n\nrm -f "$CONSOLE_RESULT" 2>/dev/null\nrm -f "$ELIZA_RESULT" 2>/dev/null\nrm -f "$COLLECT_RESULT" 2>/dev/null\n\necho $CODE_BEGIN >> "$FINAL_RESULT"\n\necho "$VERSION_STRING" >> "$FINAL_RESULT"\necho "$COPYRIGHT" >> "$FINAL_RESULT"\n\nif [[ $DISTRO == $UNKNOWN_DISTRO ]]; then\n   echo $MSG_DISTRO_NOT_SUPPORTED\n   exit 127\nfi\n\nif [[ $DISTRO == $SUSE ]]; then\n   NWELIZA_ENABLED=1\nfi\n\nif (( ! $USE_ROOT && ! $GUI )); then\n   writeToEliza $MSG_EMPTY_LINE\n   writeToEliza $MSG_ANALYSIS_AS_USER\nfi\n\ngetConnection\ngetTopology\ngetExecutionHost\ngetESSID\n\n# check some environmental stuff\n\nPNINused\nconfigReadable\n\nwriteToEliza $MSG_EMPTY_LINE\nwriteToEliza $MSG_START_COLLECTING\n\ndetectInterfaces\ncollectNWData\nwriteToEliza $MSG_EMPTY_LINE\n\nif (( $NWELIZA_ENABLED )); then\n   writeToEliza $MSG_ELIZA_START_ANALYZE\n   NWEliza\nelse\n   writeToEliza $MSG_NWELIZA_UNAVAILABLE\nfi\n\nstate "GUI:$GUI"\nstate "UID:$UID"\n\n#################################################################################\n# --- Paperwork\n#################################################################################\n\nif [[ $CONNECTION == $CONNECTION_WRL ]]; then\n   writeToEliza $MSG_CHECK_KEYS $FINAL_RESULT_SHORT_NAME\nfi\n\nif (( $NWELIZA_ENABLED )); then\n\n   if [[ $askEliza_error == 0 && $askEliza_warning == 0 ]]; then\n      writeToEliza $MSG_EMPTY_LINE\n      writeToEliza $MSG_MAIN_NO_ERROR_DETECTED $FINAL_RESULT_SHORT_NAME\n   else\n      writeToEliza $MSG_EMPTY_LINE\n      writeToEliza $MSG_MAIN_GOTO_LINK\n   fi\nfi\n\nwriteToEliza $MSG_EMPTY_LINE\nwriteToEliza $MSG_MAIN_POST_FILE $FINAL_RESULT_SHORT_NAME\nwriteToEliza $MSG_EMPTY_LINE\n\nif (( $NWELIZA_ENABLED )); then\n   cat "$ELIZA_RESULT" >> "$FINAL_RESULT"\n   echo $SEPARATOR >> "$FINAL_RESULT"\nfi\n\ncat $LOG >> "$FINAL_RESULT"\n\nif (( $NWELIZA_ENABLED )); then\n   echo "$SEPARATOR" >> "$FINAL_RESULT"\n   echo "*** `NWElizaStates m`" >> "$FINAL_RESULT"\n   echo "`NWElizaStates`" >> "$FINAL_RESULT"\nfi\n\necho $CODE_END >> "$FINAL_RESULT"\n\n#\n# masquerade IPs and macs\n#\n\nif (( MASQUERADE_MAC )); then\n   masqueradeMacs\nfi\n\nmasqueradeIPs\nmasqueradeESSIDs\n\n#       give ownership of file back to user\n\nif [[ $UID -eq 0 && $CND_USER != "" ]]; then\n   if [ $CND_USER != "root" ]; then\n        chown $CND_USER.users "$FINAL_RESULT"                   # give created file back to owner\n   fi\nfi\n\n# delete all temporary files\n\nif [[ $GUI -eq 0 ]]; then\n   cleanupTempFiles\nfi\n\n#\n\nif [[ -n $OUTPUT_FILE ]]; then\n   OUTPUT_FILE="collectNWData_${OUTPUT_FILE}${FLAGS}.txt"\n   mv "$FINAL_RESULT" "$OUTPUT_FILE"\n   FINAL_RESULT="$OUTPUT_FILE"\nfi\n\nopenResultFile\n\nif [[ $UID -eq 0 ]]; then\n   export CND_INTERNATIONAL_POST=$CND_INTERNATIONAL_POST\nfi\n\n# vim: tabstop=4:softtabstop=4:shiftwidth=4:noexpandtab:syntax=sh \n'
glade_data='<?xml version="1.0" encoding="UTF-8"?>\n<interface>\n  <requires lib="gtk+" version="2.16"/>\n  <!-- interface-naming-policy project-wide -->\n  <object class="GtkAboutDialog" id="aboutWindow">\n    <property name="can_focus">False</property>\n    <property name="border_width">5</property>\n    <property name="resizable">False</property>\n    <property name="window_position">center</property>\n    <property name="destroy_with_parent">True</property>\n    <property name="type_hint">normal</property>\n    <property name="has_separator">True</property>\n    <property name="program_name">collectNWData</property>\n    <property name="copyright" translatable="yes">\t\ncollectNWDataGUI uses \nPexpect Copyright (c) 2008 Noah Spurrier\nhttp://pexpect.sourceforge.net/\nSee license details in pexpect.lic\n</property>\n    <property name="website">http://www.linux-tips-and-tricks.de/CND_GUI</property>\n    <property name="authors">Written by:\n\n- framp \n\nCredits:\n\n- robi (InstallScript)\n\n- Members of www.linux-club.de (Test)\n-   Feuervogel\n-   Ganymed\n-   Herz-von-Hessen\n-   josef-wien (+ I18N DE review)\n-   RME\n-   robi\n-   Sauerland\n-   SUSEDJAlex\n-   TomcatMJ\n-   tomm.fa\n-   Trekkie00\n\n- Members of minthouse.forumieren.com (Test)\n-   Blindenhund\n-   Coyote\n-   lupu\n-   tno\n</property>\n    <child internal-child="vbox">\n      <object class="GtkVBox" id="dialog-vbox1">\n        <property name="visible">True</property>\n        <property name="can_focus">False</property>\n        <property name="spacing">2</property>\n        <child internal-child="action_area">\n          <object class="GtkHButtonBox" id="aboutaction_area">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n            <property name="layout_style">end</property>\n            <signal name="button-press-event" handler="gtk_widget_destroy" swapped="no"/>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">True</property>\n            <property name="pack_type">end</property>\n            <property name="position">0</property>\n          </packing>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class="GtkMessageDialog" id="donemessagedialog">\n    <property name="can_focus">False</property>\n    <property name="border_width">5</property>\n    <property name="resizable">False</property>\n    <property name="modal">True</property>\n    <property name="window_position">center-on-parent</property>\n    <property name="type_hint">dialog</property>\n    <property name="skip_taskbar_hint">True</property>\n    <property name="buttons">ok</property>\n    <property name="text" translatable="yes">Network problem analysis complete</property>\n    <property name="secondary_text" translatable="yes">&lt;b&gt;1)&lt;/b&gt; Read the analysis result on the &lt;u&gt;Analysis Summary page&lt;/u&gt; and follow the instructions and try to solve the problem on your own first. \n\n&lt;b&gt;2)&lt;/b&gt; If you are unsuccessfull copy the analysis details from the &lt;u&gt;Analysis Details page&lt;/u&gt; into your favorite forum. \n\n&lt;b&gt;Note:&lt;/b&gt; The contents of the details page is already available in the clipboard.</property>\n    <property name="secondary_use_markup">True</property>\n    <child internal-child="vbox">\n      <object class="GtkVBox" id="dialog-vbox5">\n        <property name="visible">True</property>\n        <property name="can_focus">False</property>\n        <property name="spacing">2</property>\n        <child internal-child="action_area">\n          <object class="GtkHButtonBox" id="dialog-action_area5">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n            <property name="layout_style">end</property>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">True</property>\n            <property name="pack_type">end</property>\n            <property name="position">0</property>\n          </packing>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class="GtkImage" id="image1">\n    <property name="visible">True</property>\n    <property name="can_focus">False</property>\n    <property name="xalign">0.49000000953674316</property>\n    <property name="stock">gtk-dialog-warning</property>\n  </object>\n  <object class="GtkImage" id="image2">\n    <property name="visible">True</property>\n    <property name="can_focus">False</property>\n    <property name="stock">gtk-dialog-info</property>\n  </object>\n  <object class="GtkWindow" id="knownIssuesWindow">\n    <property name="can_focus">False</property>\n    <property name="title" translatable="yes">Known collectNWDataGUI beta issues</property>\n    <property name="window_position">center-on-parent</property>\n    <child>\n      <object class="GtkVBox" id="vbox4">\n        <property name="visible">True</property>\n        <property name="can_focus">False</property>\n        <child>\n          <object class="GtkTextView" id="knownIssuesView">\n            <property name="visible">True</property>\n            <property name="can_focus">True</property>\n            <property name="editable">False</property>\n          </object>\n          <packing>\n            <property name="expand">True</property>\n            <property name="fill">True</property>\n            <property name="position">1</property>\n          </packing>\n        </child>\n        <child>\n          <object class="GtkHSeparator" id="hseparator3">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">True</property>\n            <property name="position">2</property>\n          </packing>\n        </child>\n        <child>\n          <object class="GtkLinkButton" id="linkbutton1">\n            <property name="label" translatable="yes">Please report any problems of this beta by clicking this link and use the comment function</property>\n            <property name="visible">True</property>\n            <property name="can_focus">True</property>\n            <property name="receives_default">False</property>\n            <property name="has_tooltip">True</property>\n            <property name="use_action_appearance">False</property>\n            <property name="relief">none</property>\n            <property name="uri">http://www.linux-tips-and-tricks.de/CNDGUI_BETA</property>\n          </object>\n          <packing>\n            <property name="expand">True</property>\n            <property name="fill">True</property>\n            <property name="position">4</property>\n          </packing>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class="GtkMessageDialog" id="languageNotSupported">\n    <property name="can_focus">False</property>\n    <property name="border_width">5</property>\n    <property name="window_position">center-on-parent</property>\n    <property name="type_hint">dialog</property>\n    <property name="skip_taskbar_hint">True</property>\n    <property name="buttons">ok</property>\n    <property name="text" translatable="yes">Your native language is not supported. \nFalling back to English.</property>\n    <property name="secondary_text" translatable="yes">It\'s not supported because nobody volonteered to translate text into your native language. Usually it takes for a native speaker between &lt;b&gt;1-2 hours to translate&lt;/b&gt; the text.\n\nIf you are interested to help and want to see your native language to be used please contact the author at \n&lt;i&gt;nls@linux-tips-and-tricks.de&lt;/i&gt;\n\n</property>\n    <property name="secondary_use_markup">True</property>\n    <child internal-child="vbox">\n      <object class="GtkVBox" id="dialog-vbox3">\n        <property name="visible">True</property>\n        <property name="can_focus">False</property>\n        <property name="spacing">2</property>\n        <child internal-child="action_area">\n          <object class="GtkHButtonBox" id="dialog-action_area2">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n            <property name="layout_style">end</property>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">True</property>\n            <property name="pack_type">end</property>\n            <property name="position">0</property>\n          </packing>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class="GtkListStore" id="liststore1"/>\n  <object class="GtkListStore" id="liststore2"/>\n  <object class="GtkListStore" id="liststore3"/>\n  <object class="GtkWindow" id="mainWindow">\n    <property name="can_focus">False</property>\n    <property name="title" translatable="yes">collectNWDataGUI</property>\n    <property name="window_position">center-always</property>\n    <signal name="button-press-event" handler="gtk_widget_destroy" swapped="no"/>\n    <child>\n      <object class="GtkVBox" id="vbox1">\n        <property name="visible">True</property>\n        <property name="can_focus">False</property>\n        <property name="spacing">4</property>\n        <child>\n          <object class="GtkMenuBar" id="menubar">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n            <child>\n              <object class="GtkMenuItem" id="filemenuitem">\n                <property name="visible">True</property>\n                <property name="can_focus">False</property>\n                <property name="use_action_appearance">False</property>\n                <property name="label" translatable="yes">File</property>\n                <property name="use_underline">True</property>\n                <child type="submenu">\n                  <object class="GtkMenu" id="menu1">\n                    <property name="visible">True</property>\n                    <property name="can_focus">False</property>\n                    <child>\n                      <object class="GtkCheckMenuItem" id="debugMenuItemGUI">\n                        <property name="visible">True</property>\n                        <property name="can_focus">False</property>\n                        <property name="use_action_appearance">False</property>\n                        <property name="label">Enable GUI debug traces</property>\n                        <property name="use_underline">True</property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class="GtkCheckMenuItem" id="debugMenuItemScript">\n                        <property name="visible">True</property>\n                        <property name="can_focus">False</property>\n                        <property name="use_action_appearance">False</property>\n                        <property name="label">Enable Script debug traces</property>\n                        <property name="use_underline">True</property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class="GtkSeparatorMenuItem" id="sepMenuItem">\n                        <property name="visible">True</property>\n                        <property name="can_focus">False</property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class="GtkImageMenuItem" id="quitMenuItem">\n                        <property name="label">gtk-quit</property>\n                        <property name="visible">True</property>\n                        <property name="can_focus">False</property>\n                        <property name="use_action_appearance">False</property>\n                        <property name="use_underline">True</property>\n                        <property name="use_stock">True</property>\n                      </object>\n                    </child>\n                  </object>\n                </child>\n              </object>\n            </child>\n            <child>\n              <object class="GtkMenuItem" id="helpmenuitem">\n                <property name="visible">True</property>\n                <property name="can_focus">False</property>\n                <property name="use_action_appearance">False</property>\n                <property name="label" translatable="yes">Help</property>\n                <property name="use_underline">True</property>\n                <child type="submenu">\n                  <object class="GtkMenu" id="menu3">\n                    <property name="visible">True</property>\n                    <property name="can_focus">False</property>\n                    <child>\n                      <object class="GtkImageMenuItem" id="aboutmenuitem">\n                        <property name="label">gtk-about</property>\n                        <property name="visible">True</property>\n                        <property name="can_focus">False</property>\n                        <property name="use_action_appearance">False</property>\n                        <property name="use_underline">True</property>\n                        <property name="use_stock">True</property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class="GtkImageMenuItem" id="knownissuesmenuitem">\n                        <property name="label">Known open issues</property>\n                        <property name="visible">True</property>\n                        <property name="can_focus">False</property>\n                        <property name="use_action_appearance">False</property>\n                        <property name="image">image2</property>\n                        <property name="use_stock">False</property>\n                      </object>\n                    </child>\n                  </object>\n                </child>\n              </object>\n            </child>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">True</property>\n            <property name="position">0</property>\n          </packing>\n        </child>\n        <child>\n          <object class="GtkHSeparator" id="hseparator1">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">True</property>\n            <property name="position">1</property>\n          </packing>\n        </child>\n        <child>\n          <object class="GtkHBox" id="hbox1">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n            <property name="spacing">39</property>\n            <child>\n              <object class="GtkVBox" id="vbox2">\n                <property name="visible">True</property>\n                <property name="can_focus">False</property>\n                <property name="spacing">5</property>\n                <child>\n                  <object class="GtkCheckButton" id="rootButton">\n                    <property name="label" translatable="yes">Invoke script as root</property>\n                    <property name="visible">True</property>\n                    <property name="can_focus">True</property>\n                    <property name="receives_default">False</property>\n                    <property name="tooltip_text" translatable="yes">Innvokation of the script as root is strongly recommended because as root it\'s possible to collect and analyze as much information as possible. </property>\n                    <property name="use_action_appearance">False</property>\n                    <property name="use_underline">True</property>\n                    <property name="active">True</property>\n                    <property name="draw_indicator">True</property>\n                  </object>\n                  <packing>\n                    <property name="expand">False</property>\n                    <property name="fill">False</property>\n                    <property name="position">1</property>\n                  </packing>\n                </child>\n                <child>\n                  <object class="GtkCheckButton" id="internationalButton">\n                    <property name="label" translatable="yes">Localized messages</property>\n                    <property name="visible">True</property>\n                    <property name="can_focus">True</property>\n                    <property name="receives_default">False</property>\n                    <property name="tooltip_text">Deselect this option if the analysis result should be posted in an international forum. Then the generated messages will be in English. Otherwise they are in your local language if supported.</property>\n                    <property name="use_action_appearance">False</property>\n                    <property name="use_underline">True</property>\n                    <property name="active">True</property>\n                    <property name="draw_indicator">True</property>\n                  </object>\n                  <packing>\n                    <property name="expand">False</property>\n                    <property name="fill">False</property>\n                    <property name="position">2</property>\n                  </packing>\n                </child>\n                <child>\n                  <object class="GtkHSeparator" id="hseparator5">\n                    <property name="visible">True</property>\n                    <property name="can_focus">False</property>\n                  </object>\n                  <packing>\n                    <property name="expand">False</property>\n                    <property name="fill">True</property>\n                    <property name="position">3</property>\n                  </packing>\n                </child>\n                <child>\n                  <object class="GtkLabel" id="connectionTypeLabel">\n                    <property name="visible">True</property>\n                    <property name="can_focus">False</property>\n                    <property name="label" translatable="yes">Connection type</property>\n                  </object>\n                  <packing>\n                    <property name="expand">True</property>\n                    <property name="fill">True</property>\n                    <property name="position">4</property>\n                  </packing>\n                </child>\n                <child>\n                  <object class="GtkVBox" id="vbox">\n                    <property name="visible">True</property>\n                    <property name="can_focus">False</property>\n                    <child>\n                      <object class="GtkHBox" id="hbox2">\n                        <property name="visible">True</property>\n                        <property name="can_focus">False</property>\n                        <property name="border_width">3</property>\n                        <child>\n                          <object class="GtkRadioButton" id="wirelessButton">\n                            <property name="label" translatable="yes">Wireless </property>\n                            <property name="visible">True</property>\n                            <property name="can_focus">True</property>\n                            <property name="receives_default">False</property>\n                            <property name="use_action_appearance">False</property>\n                            <property name="use_underline">True</property>\n                            <property name="active">True</property>\n                            <property name="draw_indicator">True</property>\n                          </object>\n                          <packing>\n                            <property name="expand">False</property>\n                            <property name="fill">False</property>\n                            <property name="position">0</property>\n                          </packing>\n                        </child>\n                        <child>\n                          <object class="GtkLabel" id="label1">\n                            <property name="visible">True</property>\n                            <property name="can_focus">False</property>\n                          </object>\n                          <packing>\n                            <property name="expand">True</property>\n                            <property name="fill">True</property>\n                            <property name="position">1</property>\n                          </packing>\n                        </child>\n                        <child>\n                          <object class="GtkRadioButton" id="wiredButton">\n                            <property name="label" translatable="yes">Wired</property>\n                            <property name="visible">True</property>\n                            <property name="can_focus">True</property>\n                            <property name="receives_default">False</property>\n                            <property name="use_action_appearance">False</property>\n                            <property name="use_underline">True</property>\n                            <property name="draw_indicator">True</property>\n                            <property name="group">wirelessButton</property>\n                          </object>\n                          <packing>\n                            <property name="expand">False</property>\n                            <property name="fill">False</property>\n                            <property name="position">2</property>\n                          </packing>\n                        </child>\n                      </object>\n                      <packing>\n                        <property name="expand">False</property>\n                        <property name="fill">False</property>\n                        <property name="position">0</property>\n                      </packing>\n                    </child>\n                  </object>\n                  <packing>\n                    <property name="expand">False</property>\n                    <property name="fill">False</property>\n                    <property name="position">6</property>\n                  </packing>\n                </child>\n              </object>\n              <packing>\n                <property name="expand">False</property>\n                <property name="fill">True</property>\n                <property name="position">0</property>\n              </packing>\n            </child>\n            <child>\n              <object class="GtkVSeparator" id="vseparator1">\n                <property name="visible">True</property>\n                <property name="can_focus">False</property>\n              </object>\n              <packing>\n                <property name="expand">False</property>\n                <property name="fill">True</property>\n                <property name="position">1</property>\n              </packing>\n            </child>\n            <child>\n              <object class="GtkVBox" id="vbox3">\n                <property name="visible">True</property>\n                <property name="can_focus">False</property>\n                <property name="homogeneous">True</property>\n                <child>\n                  <object class="GtkHBox" id="ssidHbox">\n                    <property name="visible">True</property>\n                    <property name="can_focus">False</property>\n                    <property name="tooltip_text" translatable="yes">Name of your wireless accesspoint</property>\n                    <child>\n                      <object class="GtkLabel" id="ssidLabel">\n                        <property name="visible">True</property>\n                        <property name="can_focus">False</property>\n                        <property name="tooltip_text" translatable="yes">SSID of your accesspoint</property>\n                        <property name="xalign">0</property>\n                        <property name="label" translatable="yes">SSID</property>\n                        <property name="use_underline">True</property>\n                      </object>\n                      <packing>\n                        <property name="expand">False</property>\n                        <property name="fill">True</property>\n                        <property name="position">0</property>\n                      </packing>\n                    </child>\n                    <child>\n                      <object class="GtkEntry" id="ssidEntry">\n                        <property name="visible">True</property>\n                        <property name="can_focus">True</property>\n                        <property name="has_focus">True</property>\n                        <property name="invisible_char">\xe2\x97\x8f</property>\n                        <property name="width_chars">20</property>\n                        <property name="primary_icon_activatable">False</property>\n                        <property name="secondary_icon_activatable">False</property>\n                        <property name="primary_icon_sensitive">True</property>\n                        <property name="secondary_icon_sensitive">True</property>\n                      </object>\n                      <packing>\n                        <property name="expand">True</property>\n                        <property name="fill">True</property>\n                        <property name="pack_type">end</property>\n                        <property name="position">1</property>\n                      </packing>\n                    </child>\n                  </object>\n                  <packing>\n                    <property name="expand">True</property>\n                    <property name="fill">True</property>\n                    <property name="position">0</property>\n                  </packing>\n                </child>\n                <child>\n                  <object class="GtkHBox" id="topologyHbox">\n                    <property name="visible">True</property>\n                    <property name="can_focus">False</property>\n                    <property name="tooltip_text" translatable="yes">Topology the script runs in.</property>\n                    <child>\n                      <object class="GtkLabel" id="topologyLabel">\n                        <property name="visible">True</property>\n                        <property name="can_focus">False</property>\n                        <property name="tooltip_text" translatable="yes">Topology of your environment</property>\n                        <property name="xalign">0</property>\n                        <property name="label" translatable="yes">Topology</property>\n                        <property name="use_underline">True</property>\n                      </object>\n                      <packing>\n                        <property name="expand">False</property>\n                        <property name="fill">True</property>\n                        <property name="position">0</property>\n                      </packing>\n                    </child>\n                    <child>\n                      <object class="GtkComboBox" id="topologyComboBox">\n                        <property name="visible">True</property>\n                        <property name="can_focus">False</property>\n                      </object>\n                      <packing>\n                        <property name="expand">True</property>\n                        <property name="fill">True</property>\n                        <property name="position">1</property>\n                      </packing>\n                    </child>\n                  </object>\n                  <packing>\n                    <property name="expand">True</property>\n                    <property name="fill">True</property>\n                    <property name="position">1</property>\n                  </packing>\n                </child>\n                <child>\n                  <object class="GtkHBox" id="executionHbox">\n                    <property name="visible">True</property>\n                    <property name="can_focus">False</property>\n                    <property name="tooltip_text" translatable="yes">THe host the script is executed regarding the topology</property>\n                    <child>\n                      <object class="GtkLabel" id="executionLabel">\n                        <property name="visible">True</property>\n                        <property name="can_focus">False</property>\n                        <property name="tooltip_text" translatable="yes">Host you execute the script on</property>\n                        <property name="xalign">0</property>\n                        <property name="label" translatable="yes">Executionhost</property>\n                        <property name="use_underline">True</property>\n                      </object>\n                      <packing>\n                        <property name="expand">False</property>\n                        <property name="fill">False</property>\n                        <property name="position">0</property>\n                      </packing>\n                    </child>\n                    <child>\n                      <object class="GtkComboBox" id="executionComboBox">\n                        <property name="visible">True</property>\n                        <property name="can_focus">False</property>\n                      </object>\n                      <packing>\n                        <property name="expand">True</property>\n                        <property name="fill">True</property>\n                        <property name="position">1</property>\n                      </packing>\n                    </child>\n                  </object>\n                  <packing>\n                    <property name="expand">True</property>\n                    <property name="fill">True</property>\n                    <property name="position">2</property>\n                  </packing>\n                </child>\n              </object>\n              <packing>\n                <property name="expand">True</property>\n                <property name="fill">True</property>\n                <property name="position">2</property>\n              </packing>\n            </child>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">False</property>\n            <property name="position">2</property>\n          </packing>\n        </child>\n        <child>\n          <object class="GtkHSeparator" id="hseparator2">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">True</property>\n            <property name="position">3</property>\n          </packing>\n        </child>\n        <child>\n          <object class="GtkNotebook" id="notebook1">\n            <property name="visible">True</property>\n            <property name="can_focus">True</property>\n            <property name="scrollable">True</property>\n            <property name="enable_popup">True</property>\n            <property name="homogeneous">True</property>\n            <child>\n              <object class="GtkScrolledWindow" id="reportViewWindow">\n                <property name="visible">True</property>\n                <property name="can_focus">True</property>\n                <property name="hscrollbar_policy">automatic</property>\n                <property name="vscrollbar_policy">automatic</property>\n                <property name="shadow_type">etched-in</property>\n                <child>\n                  <object class="GtkTextView" id="reportView">\n                    <property name="visible">True</property>\n                    <property name="can_focus">True</property>\n                    <property name="editable">False</property>\n                    <property name="wrap_mode">word</property>\n                    <property name="cursor_visible">False</property>\n                  </object>\n                </child>\n              </object>\n              <packing>\n                <property name="position">1</property>\n              </packing>\n            </child>\n            <child type="tab">\n              <object class="GtkLabel" id="reportWindowLabel">\n                <property name="visible">True</property>\n                <property name="can_focus">False</property>\n                <property name="tooltip_text">Analysis results and links to websites which will give additional help</property>\n                <property name="label" translatable="yes">Analysis Summary</property>\n              </object>\n              <packing>\n                <property name="tab_fill">False</property>\n              </packing>\n            </child>\n            <child>\n              <object class="GtkScrolledWindow" id="detailsViewWindow">\n                <property name="visible">True</property>\n                <property name="can_focus">True</property>\n                <property name="hscrollbar_policy">automatic</property>\n                <property name="vscrollbar_policy">automatic</property>\n                <property name="shadow_type">etched-in</property>\n                <child>\n                  <object class="GtkTextView" id="detailsView">\n                    <property name="visible">True</property>\n                    <property name="can_focus">True</property>\n                    <property name="editable">False</property>\n                    <property name="cursor_visible">False</property>\n                  </object>\n                </child>\n              </object>\n              <packing>\n                <property name="position">2</property>\n              </packing>\n            </child>\n            <child type="tab">\n              <object class="GtkLabel" id="detailsWindowLabel">\n                <property name="visible">True</property>\n                <property name="can_focus">False</property>\n                <property name="tooltip_text" translatable="yes">Detailed information about the network configuration which can be pasted into a forum and helps other poeple to identify the network problem</property>\n                <property name="label" translatable="yes">Analysis Details</property>\n              </object>\n              <packing>\n                <property name="position">1</property>\n                <property name="tab_fill">False</property>\n              </packing>\n            </child>\n            <child>\n              <object class="GtkScrolledWindow" id="traceViewWindow">\n                <property name="visible">True</property>\n                <property name="can_focus">True</property>\n                <property name="hscrollbar_policy">automatic</property>\n                <property name="vscrollbar_policy">automatic</property>\n                <property name="shadow_type">etched-in</property>\n                <child>\n                  <object class="GtkTextView" id="debugView">\n                    <property name="visible">True</property>\n                    <property name="can_focus">True</property>\n                    <property name="editable">False</property>\n                    <property name="cursor_visible">False</property>\n                  </object>\n                </child>\n              </object>\n              <packing>\n                <property name="position">3</property>\n              </packing>\n            </child>\n            <child type="tab">\n              <object class="GtkLabel" id="traceWindowLabel">\n                <property name="visible">True</property>\n                <property name="can_focus">False</property>\n                <property name="tooltip_text" translatable="yes">Debugging info in case of program malfunction</property>\n                <property name="label" translatable="yes">Debug info</property>\n                <property name="angle">0.20000000000000001</property>\n              </object>\n              <packing>\n                <property name="position">2</property>\n                <property name="tab_fill">False</property>\n              </packing>\n            </child>\n          </object>\n          <packing>\n            <property name="expand">True</property>\n            <property name="fill">True</property>\n            <property name="position">6</property>\n          </packing>\n        </child>\n        <child>\n          <object class="GtkHButtonBox" id="hbuttonbox1">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n            <property name="layout_style">start</property>\n            <child>\n              <object class="GtkButton" id="okButton">\n                <property name="label">gtk-ok</property>\n                <property name="visible">True</property>\n                <property name="can_focus">False</property>\n                <property name="can_default">True</property>\n                <property name="has_default">True</property>\n                <property name="receives_default">True</property>\n                <property name="tooltip_text" translatable="yes">Execute collectNWData.sh</property>\n                <property name="use_action_appearance">False</property>\n                <property name="use_stock">True</property>\n              </object>\n              <packing>\n                <property name="expand">False</property>\n                <property name="fill">False</property>\n                <property name="position">0</property>\n              </packing>\n            </child>\n            <child>\n              <object class="GtkButton" id="cancelButton">\n                <property name="label">gtk-quit</property>\n                <property name="visible">True</property>\n                <property name="can_focus">True</property>\n                <property name="receives_default">False</property>\n                <property name="tooltip_text" translatable="yes">Quit the program</property>\n                <property name="use_action_appearance">False</property>\n                <property name="use_stock">True</property>\n                <property name="image_position">right</property>\n              </object>\n              <packing>\n                <property name="expand">False</property>\n                <property name="fill">False</property>\n                <property name="position">1</property>\n              </packing>\n            </child>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">True</property>\n            <property name="position">9</property>\n          </packing>\n        </child>\n        <child>\n          <object class="GtkStatusbar" id="statusbar">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n            <property name="spacing">2</property>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">False</property>\n            <property name="position">10</property>\n          </packing>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class="GtkMessageDialog" id="progressmessagedialog">\n    <property name="can_focus">False</property>\n    <property name="border_width">5</property>\n    <property name="window_position">center-on-parent</property>\n    <property name="type_hint">dialog</property>\n    <property name="skip_taskbar_hint">True</property>\n    <property name="buttons">cancel</property>\n    <property name="text" translatable="yes">Please wait</property>\n    <property name="secondary_text" translatable="yes">Collecting data and analyzing system</property>\n    <child internal-child="vbox">\n      <object class="GtkVBox" id="dialog-vbox">\n        <property name="visible">True</property>\n        <property name="can_focus">False</property>\n        <property name="spacing">2</property>\n        <child internal-child="action_area">\n          <object class="GtkHButtonBox" id="dialog-action_area">\n            <property name="can_focus">False</property>\n            <property name="layout_style">end</property>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">True</property>\n            <property name="pack_type">end</property>\n            <property name="position">0</property>\n          </packing>\n        </child>\n        <child>\n          <object class="GtkProgressBar" id="progressbar">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n            <property name="activity_mode">True</property>\n            <property name="pulse_step">0.01</property>\n            <property name="discrete_blocks">2</property>\n          </object>\n          <packing>\n            <property name="expand">True</property>\n            <property name="fill">True</property>\n            <property name="position">1</property>\n          </packing>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class="GtkMessageDialog" id="rootPasswordDialog">\n    <property name="can_focus">False</property>\n    <property name="border_width">5</property>\n    <property name="modal">True</property>\n    <property name="window_position">center-always</property>\n    <property name="destroy_with_parent">True</property>\n    <property name="type_hint">dialog</property>\n    <property name="skip_taskbar_hint">True</property>\n    <property name="message_type">question</property>\n    <property name="buttons">ok-cancel</property>\n    <property name="text" translatable="yes">Please enter your root password</property>\n    <property name="secondary_text" translatable="yes">The script should be executed as root because there is more detailed analysis possible. If you have any concerns to execute the script as root press cancel and disable root invocation.</property>\n    <property name="secondary_use_markup">True</property>\n    <child internal-child="vbox">\n      <object class="GtkVBox" id="dialog-vbox4">\n        <property name="visible">True</property>\n        <property name="can_focus">False</property>\n        <property name="spacing">2</property>\n        <child internal-child="action_area">\n          <object class="GtkHButtonBox" id="dialog-action_area3">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n            <property name="layout_style">start</property>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">True</property>\n            <property name="pack_type">end</property>\n            <property name="position">0</property>\n          </packing>\n        </child>\n        <child>\n          <object class="GtkEntry" id="passwordEntry">\n            <property name="visible">True</property>\n            <property name="can_focus">True</property>\n            <property name="visibility">False</property>\n            <property name="invisible_char">\xe2\x97\x8f</property>\n            <property name="primary_icon_activatable">False</property>\n            <property name="secondary_icon_activatable">False</property>\n            <property name="primary_icon_sensitive">True</property>\n            <property name="secondary_icon_sensitive">True</property>\n          </object>\n          <packing>\n            <property name="expand">True</property>\n            <property name="fill">True</property>\n            <property name="position">2</property>\n          </packing>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class="GtkMessageDialog" id="rootmessagedialog">\n    <property name="can_focus">False</property>\n    <property name="border_width">5</property>\n    <property name="window_position">center-on-parent</property>\n    <property name="type_hint">dialog</property>\n    <property name="skip_taskbar_hint">True</property>\n    <property name="message_type">warning</property>\n    <property name="buttons">yes-no</property>\n    <property name="text" translatable="yes">Are you shure you want to disable root invocation ?</property>\n    <property name="secondary_text" translatable="yes">This will reduce the analysis capabilities of collectNWData.sh. </property>\n    <property name="secondary_use_markup">True</property>\n    <child internal-child="vbox">\n      <object class="GtkVBox" id="dialog-vbox33">\n        <property name="visible">True</property>\n        <property name="can_focus">False</property>\n        <property name="spacing">2</property>\n        <child internal-child="action_area">\n          <object class="GtkHButtonBox" id="dialog-action_area22">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n            <property name="layout_style">end</property>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">True</property>\n            <property name="pack_type">end</property>\n            <property name="position">0</property>\n          </packing>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class="GtkMessageDialog" id="rootpasswordmessagedialog">\n    <property name="can_focus">False</property>\n    <property name="border_width">5</property>\n    <property name="window_position">center-on-parent</property>\n    <property name="type_hint">dialog</property>\n    <property name="skip_taskbar_hint">True</property>\n    <property name="message_type">error</property>\n    <property name="buttons">close</property>\n    <property name="text" translatable="yes">Invalid root password entered</property>\n    <property name="secondary_text" translatable="yes">Please enter correct root password</property>\n    <child internal-child="vbox">\n      <object class="GtkVBox" id="dialog-vbox6">\n        <property name="visible">True</property>\n        <property name="can_focus">False</property>\n        <property name="spacing">2</property>\n        <child internal-child="action_area">\n          <object class="GtkHButtonBox" id="dialog-action_area4">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n            <property name="layout_style">end</property>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">True</property>\n            <property name="pack_type">end</property>\n            <property name="position">0</property>\n          </packing>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class="GtkMessageDialog" id="shellerrordialog">\n    <property name="can_focus">False</property>\n    <property name="border_width">5</property>\n    <property name="window_position">center-on-parent</property>\n    <property name="type_hint">dialog</property>\n    <property name="skip_taskbar_hint">True</property>\n    <property name="message_type">error</property>\n    <property name="buttons">close</property>\n    <property name="text" translatable="yes">collectNWData.sh execution failed </property>\n    <property name="secondary_text" translatable="yes">Return code</property>\n    <child internal-child="vbox">\n      <object class="GtkVBox" id="dialog-vbox7">\n        <property name="visible">True</property>\n        <property name="can_focus">False</property>\n        <property name="spacing">2</property>\n        <child internal-child="action_area">\n          <object class="GtkHButtonBox" id="dialog-action_area6">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n            <property name="layout_style">end</property>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">True</property>\n            <property name="pack_type">end</property>\n            <property name="position">0</property>\n          </packing>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class="GtkMessageDialog" id="shellscriptmissingdialog">\n    <property name="can_focus">False</property>\n    <property name="border_width">5</property>\n    <property name="window_position">center-on-parent</property>\n    <property name="type_hint">dialog</property>\n    <property name="skip_taskbar_hint">True</property>\n    <property name="message_type">error</property>\n    <property name="buttons">close</property>\n    <property name="text" translatable="yes">collectNWData.sh missing </property>\n    <property name="secondary_text" translatable="yes">The script collectNWData.sh was not found in the current path. Please download the script from http://www.linux-tips-and-tricks.de</property>\n    <child internal-child="vbox">\n      <object class="GtkVBox" id="dialog-vbox8">\n        <property name="visible">True</property>\n        <property name="can_focus">False</property>\n        <property name="spacing">2</property>\n        <child internal-child="action_area">\n          <object class="GtkHButtonBox" id="dialog-action_area7">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n            <property name="layout_style">end</property>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">True</property>\n            <property name="pack_type">end</property>\n            <property name="position">0</property>\n          </packing>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class="GtkMessageDialog" id="ssidmessagedialog">\n    <property name="can_focus">False</property>\n    <property name="border_width">5</property>\n    <property name="window_position">center-on-parent</property>\n    <property name="type_hint">dialog</property>\n    <property name="skip_taskbar_hint">True</property>\n    <property name="buttons">ok</property>\n    <property name="text" translatable="yes">SSID missing</property>\n    <property name="secondary_text" translatable="yes">Please enter SSID of your accesspoint</property>\n    <child internal-child="vbox">\n      <object class="GtkVBox" id="dialog-vbox2">\n        <property name="visible">True</property>\n        <property name="can_focus">False</property>\n        <property name="spacing">2</property>\n        <child internal-child="action_area">\n          <object class="GtkHButtonBox" id="dialog-action_area1">\n            <property name="visible">True</property>\n            <property name="can_focus">False</property>\n            <property name="layout_style">end</property>\n          </object>\n          <packing>\n            <property name="expand">False</property>\n            <property name="fill">True</property>\n            <property name="pack_type">end</property>\n            <property name="position">0</property>\n          </packing>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class="GtkSizeGroup" id="sizegroup1">\n    <widgets>\n      <widget name="topologyLabel"/>\n      <widget name="ssidLabel"/>\n      <widget name="executionLabel"/>\n    </widgets>\n  </object>\n  <object class="GtkSizeGroup" id="sizegroup2">\n    <widgets>\n      <widget name="ssidEntry"/>\n      <widget name="topologyComboBox"/>\n      <widget name="executionComboBox"/>\n    </widgets>\n  </object>\n</interface>\n'
image_data='\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00\xff\xdb\x00C\x00\x05\x03\x04\x04\x04\x03\x05\x04\x04\x04\x05\x05\x05\x06\x07\x0c\x08\x07\x07\x07\x07\x0f\x0b\x0b\t\x0c\x11\x0f\x12\x12\x11\x0f\x11\x11\x13\x16\x1c\x17\x13\x14\x1a\x15\x11\x11\x18!\x18\x1a\x1d\x1d\x1f\x1f\x1f\x13\x17"$"\x1e$\x1c\x1e\x1f\x1e\xff\xdb\x00C\x01\x05\x05\x05\x07\x06\x07\x0e\x08\x08\x0e\x1e\x14\x11\x14\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\x1e\xff\xc0\x00\x11\x08\x00B\x00>\x03\x01"\x00\x02\x11\x01\x03\x11\x01\xff\xc4\x00\x1b\x00\x00\x02\x02\x03\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x05\x06\x03\x04\x00\x02\x07\x01\xff\xc4\x006\x10\x00\x02\x02\x01\x03\x02\x03\x06\x05\x01\t\x01\x00\x00\x00\x00\x01\x02\x03\x04\x11\x05\x12!\x00\x06\x13"1\x07\x142AQa\x15Bq\x81\x91#\x08\x16$%3Rbr\xa1\xf0\xff\xc4\x00\x19\x01\x00\x02\x03\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x03\x00\x01\x04\x05\xff\xc4\x00(\x11\x00\x02\x02\x01\x03\x03\x02\x07\x01\x00\x00\x00\x00\x00\x00\x00\x01\x02\x00\x11\x03\x04\x12!"1A\x132Baq\x81\x91\xa1\xf0\xe1\xff\xda\x00\x0c\x03\x01\x00\x02\x11\x03\x11\x00?\x00.\xdf\xe2\xad\xc2\xb34>\n:\x92\xd9\x05\x1fp\xc9\x18\xe3n\x0b|\\\x8c\xf1\x91\xd4\xe8\x15\xa40\xcbj8\xe2\x8a@\xb2\xc5\x1a1!UU[v\x14\xfa\x12\xc3\x07\x93\x81\xf7\xdd\xec\x93:C\xef\x96\xac\x16\x81\xe4\x92#\xe1"\xac\x87,G\xa3nV\xf3c\x00\x80W s\x81\x9a\xfa\xb0\x8a\xad\x91\xa7F\xcfi+\xc3\x1d\x88\xa9\xa3\xc6\x82L\xb4\x865\x0c\x00a\x92$S\x85\xcbg\x93\x8c\x8e\xb8\x8cB\x82I\xaa\x9d\xc1rm\x9e&\xa1\x0cV\xa5\xb5\\Y,\xcb?\x9a\x11,\xa5\x8e\xcc\x95\x1eS\xb4p\xa0\xe4\x82\xc1\x80\x19\xc7\x9a<\xdd\xbej\xc1{W\xbf\x15&\xb3*F\x01\xc2Iff\x8fbG\x13\x86\x1cg,\x06\x0eI<\xed\xf5\xda\xe4Z\x9e\xad`j\x16H\x8a\xbdy<q^\x00\xc5\x8be\xb7l\xc8,N\xe0\x0f\xa6\x0eq\xf0\xfa\xc3{\xb7u^\xe0-_Ryt-(\xee\x95\xa5\x12\xa4v\x15\\\xb6\x11\\n\xda|\xbe`6\x90\x1cy\xdb\x95\x06\x10\x90\x1a\xe8@g\nhrb\xaf\xb6-v\x87f\xe8\t\x1e\x99v\xbc\x17\xe2\x0b-x\xe5\xb0g\x91\xe5.\xa6A\x86\xc9\t\xb7z\xe78\xf9.\x00\x1d\x1c\xf6a~\xd5\xdd.\xde\xb7\xafO\xe2j\x96\xea\x8b\x8d\x14\nD0\xa4\x8b\xb5\x16,g\xce\x04*rA>b?7Co{\x17\xecG\xd3&\xfc>\xb2]\xb1\xb5\xa4W{,\xcf#`\xe3/\x92pOA\xfb\x1e\xae\xbd\xda\xd0G\xdb\xb3\xce\xb65\xca\xb4\xcc\xf1\xd6\x11\xb7\x82\xf0\x16\xe2/\x13\x1c\x95>\x879\x19>\xbd\x18ll\x94!\x14\xc8\x08&9\xd5x&\xd3\xa0\xb3`\xd9\xf7\xb9\x10I=V\x8c\x85\x04\xbb1\xdcv\xb2\x86\x05\xdc\x1c\x9f\xb1\xf8\xb3\xd1~\xddF\xfcM\xbc)\x9e\x7f\x0e\x0f\x0eIb\xdd"\xe7 \x80\x0f\xe6\x18\'$\xe4\x83\x90NA\x00\x06\x9d\xae\xdfi,=\x9d\x12z\xe6(|9mJ\xe2(\xe4]\xeb\x9d\xfb\xb6\x02\x02\x82\x07>\x9c\x13\xc9\xcbF\x84\xdf\xe6M&\xa3%i\xa3\xb3\x01\xb0\x93\xc2\xcb,s3Hwb@2v\xf01\x8cr\x07\x00(\xe8@\xa6\x02\xee\x0bn\xdbdT\x03\xdd\x0et\xebv.V\xa9V\x08\x9aZ\xdf\x89\x19\x06\xe5\xda\xce\xa2@\xa0\x1c\xe4\x80\x18n\x19\xf3\xe7\xd4\xe3\xa7\r\x13\xb5\xfbgLu\xd6\xdbK\xa3RhcwG\xf0\xd4x*\xca7\x16o\x9baq\x93\xe88\x1e\xa4\xb2M>\xdf\xbbz\xdd)\xb5\xa6\x84{\xae\xd0\x12\xbb\xb8Y6\xe0\xae\xec\x9c\xb0\x04\x027g\x1f\xb9\xcc}\xebn\xe7xw}~\xc3\xad7\x87\xa6\xc1\n\xdb\xd5\x8a>\x0c\x89\xbb\x0b\x17\xe8}OK\x1c\x9aRj?\xd1\xda\x96\xe3\x98\xc1\xdbz\xc5\xfe\xee\xbc\xfa\x96\x91\r];@Y\nA`\xc3\x9b7\x15x.\xb9\xe1\x10\x9fN\t#\x9e:m\x96\x9dd@\x04++\x01\x8d\xd2y\xdb\xf9<\xf5\x16\x9dZ\xbd*\xb1T\xaa\x828aP\xaa\xa3\xd0\x01\xe8:\x99\x1d\xc9;\xb1\xeb\xc6:\x1c\x8c.\x84\xdd\xa3\xd2\x85\xean\xf06\xb3\xa4V\xb3A\xe3DXf\\\x98\xdd<\xa5[\xf6\xe9C\xb1u\xcb\x9a\x94\xb7\xb4\xcdMc7h\xcacb\xa3\x82\x80\xf0O\xdc\xf5\xd0\xacr\xa7=q\xbff3\xb5\xdfh}\xeb0o\xe8\xc3e"\\|\xce\x0e\x7f\xfb\xef\xd5"\xf0Lf\xaff\xe0\x04t\xee_\x06\xb5\xcd/R\xb1b\xacPU\xb6\x1c\xa5\x87\xda\x8e\xee\n!\x07\x07\xcc\x19\x868\xf5\xfauc\xb7\xafC\xdd\xba\xb4\xd2it\xe4\xb1A\xa1\x12\x0b\n\x86\x15yA\x01\xb0[k\x1f)\x8f\x9c`\x9c\x8e\n\xf2\x8f\xdcZ\xbe\xa1\xa8\xf7l\xdaLvf\xab\xa7\xd55\xe1\x95\xe2\xc8f\x96g\xc0\xc1\x1e\xb8\x0b\xb4\x0f\x99q\xf4\x1d;\xe9b\xcbYT\xd3`\x96j\xf0Dc"70@_#v\xdc\xf2H#o\xd8\x86\r\xce:r\xa9\x0b\xb8\x7f~g/Q\x94\x13\xe9\xc1\xf5\xbb\x9bO}a4\x9b\x1e%;\xb2)h\xa2\x98m2\x01\xeb\xb7\xeb\x8e\xa8v5\t*\xfb]\xee\xbb3\x02E\x8a\xf5^\x06?\xec\xc1S\x8f\xddz\x93\xb8\xb4\xcaZ\xe5\x9b\ng\x10Y\x82\xe0\x11\xb9\x91\xde%+\xb4\xa1U\xce\x15\xb2W\xe1*rN\t\xc1\xean\xcb\xd4\'\xb5\xdc\xfa\x85k\x8a\x91\xeb\x14\x94\xaaE#mk5\xcf9^\x00\xc2>\xe5\xdd\x93\xc89#\xaad\xd8\t^c\xb0\xea\x17#\x0fS\x8a\x9d\x0f\x07a s\xd7\xab\xfe\x9eH!\x8f\xd7\xadR\xcdhc-now\xc6r&\xf2c\x1f\xaf\x1f\xc7K]\xcd\xed\x07\xb4\xf4jMfmn\x9c\xa4\x1d\xab\x1c3\x07w?@\xa3$\x9e\x92\xb8\xc93v}^%\x1d&\x14\xee=J\xae\x93\xa4Mr\xf4\xa1"D$\xb7\xed\xe9\xd7.\xfe\xcf\xb5=\xe7\xb7\xf5]\\\xac\x9e%\xfb\xf2K\x97\x18$|\x8fU,\xe9\xbd\xef\xedZ\xca{\xc5;\x1a\'mx\x84\x8f\x1cl\x9ae\xff\x00\xaf\xa8\x1dv>\xde\xd0*\xe8Z<\x1amD\xdb\x14\n\x15F>]=\xc0QS\x00\xc8]\x83Nk\xa8\\\x9fC\xee\xe9\xa0\x9eH4\xfa\xf7\x08\x95.\xcb\x03H\xa6E\xf8T\x0f\x84\x1f\x9f\'\xe5\xc7\xd7\xa7\x1e\xd2\xeeH\xb5\x13`\xd0H\xaeX\x85\xda9\x95/m\x8d\x089\xc6vgw \xfc#\x86\xf58\xe8\xe6\xab&\x89R\x8b\xcf\xac\xc9V:\xc0\x80\xcd>6\xe4\x9c\x01\xcf\xa9\'\xd3\xa0\xb3GZ\xde\xbbRjS\xc1oG4\xe4\xf8&m\xe6]\xf1\xed\xdc\x00\xceTo\x19\'>l\x11\x91\x92(M\xad\xf6\x11Z\x80\xb6Y{\x98\n\xc4p\x8d.\xbaC\xa3\xd7\x8da\x91e\x0e\x90\xe07\x86\xeb\xb9\x9cF2\n\x95\x0cI\x00\x0e6\xee\xfc\xbb\xf7Ej:\xfe\xa7Vi\xa8\xad\xd9j\xc12M&H\x8a\x18\xd8\x9c\xb9\x0eC.QH*\xac\t\x0f\xe8\xcb\x82 \xb3^-\xf8\xfe\x9cM+\x952\xa4m\x82I#\x04yv\x8c\xba\x8e9a\x18\xc6|\xdbe\x94\xcb4\x16\xeb/\x8a\xc9b\x04\x1e\xef\x1cJ\xa8\x03\x10\x08\xdf\x9c\x05\xc2\x0c\x8e\t\xc7\x03\x1e\x92\xa8\xd8\xe0\xfc\xbf\xbe\xd0\x0f"\x8c\xdb\xb7uZt\xe5\x96\xa5;\x1a\xaa@@D\x85\xe1C\x1b\xc8\xcc\xec\xd2\xaf\x00\x92G\x9c\xa8#<\xf9rzh\xedx;sT\xb05X\xf4\xad3\xf1\x10\x00y\xc5e\x12d\x80~cp\xe0\x83\x83\xcf#\xa5\xc6\x9bQ\xd4*6\x9d%m?P\x92XB\xd9\x13#\xedp\x8aI\x08\x00\xc1\xf3\xe4\x1d\xbb\xb0[\xd4\x85\xe5w\xb949\xaevz\xc9\n\xd6J\xd4\xa1\x8et\xafjY$i\x1d\x06c\x8d\x9a\x16Wpv\xb7\x99\x8b`\xfeS\xc9\xea\xd8\xbb0"\xab\xcf\xf9\x07`\x02\x94\x1f\xd4\xee{\x068\xff\x00\xce\x80wF\xaf\x16\x93NF\xc3\xd9\xb2\xa8Y \x8f\x97p>\x7fa\xf7\xe9y\x06\xa9n\x85-WE\xb1sO\xb7ojI\xa7K6\xf8\x87\x07\x95\x04\x9d\x9c\x0c\xf0q\xf6\xcfUu\x9b\xf0T\xed\xf1\xa6jU\xee\xa6\xb1\xa9x\xd0J \x8c\xc92\x95\x00\x19\x06\x01\xf2\x80\xe8C\x1f(\xdc3\xc9\xc1OQ}\xb3B0\n\t\x81\xe4\xd4{\x8b[\xd3\xa2\xb3cN\xa4\x15^\x0b\x95\xf6Z*\xd0\x12\xd9RX\xa9\x19\x03\x04\x8c`\x86 \xf1\xcfG4\x99\xdfZ\xb1#_\xb1V2\xc8\n\xc4\x82B\xacT\x0c\xb8u\xc0~\x1d\x06T\xb0\x1e\x84\xe4t7\xb7\xe3m+I\x82-\x1e\x9cmS\xc3\x8a\n\xf3K!I\x93b\x80\x17\x05N@A\x8f7\xe6\x19\xe3\xe3\x05\xbbf\'iH\x99\x9a\xd0Q"\xae\xdeB\xe1\x94\x9c\x81\xc09by\xc99\xcf\x1c\x8e\x9e\x86\xbcQ\x89\xc8\xcc\xe3\xa8\xf1\xf4\x86\x8e\x9d\xa7\xb5x7P\xaa~\x14\xe6\x15\xf8p\x9czzp?\x81\xd5g\x82\x0f\x00?\x83\x1e\xf16\x03m\x19\x03al\x7f<\xfe\xbc\xf5\x9dgM\xf1\x13#\xb7R\xa8\xd7\xa5\x84V\x84E\x12\x97\x8d6\r\xa8\xc1P\x82\x07\xc8\x83\xcez\xbdoO\xa0\xd5\xd6\x16\xa3X\xc4-*\x841.\xd0\n\xe4\x8cc\xe7\x81\xd6u\x9d\x02\xfb\xa5\x99SC\x82\x18\xfb\xc9Z8cB\xe6M\xc5T\r\xd82\x01\x9f\xae\x00\x03\xf4\x1d\x18\xd7(Q\xfe\xf3\xd5\xbf\xeeU\xbd\xed\xa3X\x9a\x7f\t|B\x80\xb1\x0b\xbb\x19\xdb\x92N=2z\xce\xb3\xa2>\xe3\'\xc2\xb2\xae\xaf\xa7i\xea-H\xb4*\xab\x94\x00\xb0\x85A#a\xf9\xe3\xfe+\xfc\x0f\xa7[\xd0\xaf]uY\x15`\x88\x01\x19\x00\x04\x1c\x0c\x8e\xb3\xac\xea\x0f\x12\x9b\xb1\x9f\xff\xd9'
i18n_data='PK\x03\x04\n\x00\x00\x00\x00\x00\xf5\xb6zH\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\n\x00\x1c\x00locale/de/UT\t\x00\x03^\x05\xf7V\xa5\x13fSux\x0b\x00\x01\x04\xe8\x03\x00\x00\x04\xe8\x03\x00\x00PK\x03\x04\n\x00\x00\x00\x00\x00\xf7\xb6zH\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x16\x00\x1c\x00locale/de/LC_MESSAGES/UT\t\x00\x03a\x05\xf7V\xa5\x13fSux\x0b\x00\x01\x04\xe8\x03\x00\x00\x04\xe8\x03\x00\x00PK\x03\x04\x14\x00\x00\x00\x08\x00\x8akdA/\x11\xc0\xb1+\x0e\x00\x00\x80!\x00\x00)\x00\x1c\x00locale/de/LC_MESSAGES/collectNWDataGUI.moUT\t\x00\x03c_\x96P\xa3\x13fSux\x0b\x00\x01\x04\xe8\x03\x00\x00\x04\xe8\x03\x00\x00\xa5X]l\x1cW\x15\x1e\xfaC\x93\xb5\xdd\xc4i\xea\xa6i\x9b\xdc\xb4\x04\xe2\xd6\xbb\xf1\xba\t-N\xe2\xc6\xb57\x89\x89\x93\xb8\xb6\xd3H-?\x9a\xdd\xb9\xde\x9d\xee\xec\xcct\xee\x8c\xd7\xb6T\x89R\x88P%*\xa4B\x05\xa2\x08D+\x01/\x08\x81\x94\xa7 \x1e\x8c@\xbc!\xd4\x82\x00\xa9\xb4<"UB\xe5\t\x81\x10\xdf\xb9\xe7\xce\xec\xac\xbd\x9bF\xea\xca\xebo\xe6\xfe\x9c{\xee9\xdf9\xf7\xdc}g\xcfm\xdf\xb2\xf0y\n\xdf\xfb\xf1}\xf3\x16\xcbj\x01\xc7n\xb7\xf4\xe7\xdd\x8f[\xd6n\xe0{\xc0\xbd\xc0\x0f\x80#\xc0;\xee\xe0\xf6\x03\x06\x8f\x02\xc7\x81\xa7\x81\x18b=\x0f|\x10\xb8\x06\x1c\x02~\x17x7\xf0\'\xc0\xfb\x80\xbf\x02~\x02\xf8W\xe0.Zh\x07d\x00v\xef`y\xa7\x81\x0f\x90^\xc0"0\xd8\xc1\xeb\x7fo\x07\xcf\xfb9\xb0\x00\xfc\x93\x19\xffw\xe0\x9d\xc0\x7f\xed`\xf9\xb7\xec\xb4\xac\xbbH?\xe0\xc3\xc0\t \xfe\xac\xcf\xefd=\xea;y\xde\x0b\xc0{\x81\xaf\xec\xe4y?\xde\xc9\xeb\xfc\x1a\xf8\x08\xf0\xcff\xfc\xed\x05\xc6\xfb\x80\x83\xc0\xb2\xc1)\xe0\x1e\xe0y\xe0!\xe0\x17\x800\xa1\xf5\xa5\x02\xaf\xf7\x12\xf00\xf0\xeb\xc0\x03\xc0_\x00\x07\x80\x7f(\xb0~\xef\x14\xd8\x9e\x1f\x00\xf7\x01w\x0e\xf0\xba\x0f\x0e\xb0\xdd.\x0e\xf0\xf8\xcf\rp\x7f\x03x\x1b\xf0\xc5\x01^\xff\xea\x00\xef\xfbU3\xee\x87\x03\xac\xc7O\x07x\xdf\xbf\x1f\xd0\xa6\xb5\xfe3\xc0\xfb\xbam\x90\xed}/p?p\x14\xf8\x10pv\x90\xed\xdd\x18d?\\5\xef\xd7\x06\xd9.o\r\xb2^\xff\x1c\xe4}\xdc\x0f\xe5J\xc0\x13@\xa2\xcasC\xacO8\xc4\xeb\xbd0\xc4\xeb\\5\xfd\xaf\r1/^\x1fb{\xbfa\xc6\xfdr\x88\xf5\xfe\r\xf0\x93d\x97!\xde\xdf\xbf\r\xfe\x0f\xf8\xf2\xc7,\xeb\xd6;y\xff\xaf\xec\xe2\xfd\xfdh\x17\xeb\xfd\xbb]\xbc\xff\xf7\x81\xc3\xc0\xff\x02/\x02\xef\x84s\xef \x7f\x03\x1f\x05\xca\xddl\xe7\xef\xecf\xfe\xfc\x0cx\x0f\xf0\xed\xdd\xec\x9f\xf7w\xb3\x9c\xbb \xe4q\xb2\xff0\xdb\xeb\xd9a\xe6q8\xccr^\x1df\xfd\x7f;\xcc\xf6}o\x98\xed3\xb8\x87\xc7\x1f\x01\xbe\x01<\x05\x1c\xa5\xfe=<o\x00\xce~\x12\xf8\xc4]\xcc\xbb/\x03_"y\xc0\xc7\x80\xf7\xec\xe5\xf8\xbb\xb4\x97\xe5y\xc0]\xd8\xf7\xd7\xf6\xb2\xbe\xdf\x06\xf9f\xc9^w3\x0fo\x19\xe1\xfd\xee\x1ba\xbb?<\xc2\xf3\x1f\x1b\xe18\\\x1e\xe1\xf8\xf8\xea\x08\xfb\xed\x1b#\x1cG\xd7\x81\xafA\xee?F\xd8\x8f/\xee\xe3\xfd\xfd`\x1f\xcf\xdf\xdc\xc7~\x7f\x17\xf8i\xb2?p\x1ax\x1c\x9b\xfe\n\xb0\r<Hv\xbe\x97\xd7\xbd\x7f?\xeb?\xba\x9f\xfdb\xefg^\xbc\x04\x0c)N\x81\'\x80\x0f\xdd\xc7|\xfe"\xf0\xabX\xbf\x05|\x8d\xe2\x15\x8b~\x16\xf8\xf2\x03\xbc\xce\xdb\xc0g\xc9\x1eP\xee\x1cP\x1d`}\xae\x03\x05\xf0/\xc02\xf1\xf9\x00\xfb\xbf\x08e\x8e\x01\x9f:\xc8\xf2\xaf\x1ed9\xdf<\xc8\xfc\xfa#p\x0e\xf8\xb7\x83\xcc\xc3Q\xc1\xbc8*\x8c\xbd\x04\xcbY\x16\xcc\xbf5\xe0[\xc0\xef\x0b\x1e\x1f\x1fb\xdc\x00B\xed\xecC{"~\x9e\xb78\xce/\x98v\xb2\xe5\x88y&\xf9\xc7-\xde\xdf\xe3\xb9\xb9\xb7\xe7\x9e\xc9\xc6\xe4\x9f[\xf1\xad\xe0{\xc6b>\xd2\x9e&-\x8e\x19\xf2\xf7\x11\xe2\x94\xc5{!>\x10\x87(~\x17,\xe6\x19\xe5\xefOY\xcc\x9d\x83F\xf6\x13\xf8\x9e\xc5w\xccb.P^\xa2\xd8\xbed1w\xc9>\x07\xccX\xb2\x01\xf1\x7f\xafy\xa7\xd8}\xcc<\x13\x9f\xc8\xa6\xe7\xcc\xfb\xacA\x8aG\xca}d7\x8a\xb9\t\x8b9F\xf1<eq|\x91\xadO\xe3{\xd2b\xff\xd0\x87\xe2\x81b\xa8du\x7f>c\xb1o\xd3\x0f\xf1k\xd8<\x13\x07(_\xce\x9b\xf7\x99\xdc8\x8a\xabC[d\x89\xf4\xe1\xb0\x12~\x10\x0b\xd7W\xb1\xedy\xd2\xa1\x86\xb6\xeby\xa2*{7&~\xa7y\xda\xb7\xbdu\xe5*\xe1\xc8\xd8v=\xd5iPI\xabeG\xeb\xd6t$\xc5z\x90\xe0\xdd<\xb4m?\x16q \x1cW\xd9UO\x8a(\xd0\xab\xaf\x065;v\x03\xdf\x9a\xb1\xfd\x9a\xf4\x0c\x88H>\x9fH\x15KG8I\xe4\xfau\x11FAM*\x85G3d9\x08\xbce7\xb4f<i\xfb4"H\xe20\x89\xc5\x8a\xebI\xd5i\xd5\xcb,\\\x99\xc5R$\xa3\x15\xc6\xd6L\x80=\xd4b\xeau\xec\xd8\x16\xb6\xef\xe0\x0b\xfd7\xa8I\xadc\xd9\x16\x06\xf9>\r\n|\x11\xaf\x87\x12\xef\xe1\xba\x9e\xa17,\xcd\x0c\xdaq$U\xe2\xd1V\xb0\xb9\x9a\xe7\x86\xd5\xc0\x8e\x1ck&\x92\xb6^\x82\xf4\x11\x87\x955\xbb4/\xce\xa1\xa7mG2\x82\xae2\x12\'\x8bSb\xc6s\xa5\x1f\xf7\xeb\x9dw\xfddm\xb1\xe7\xe8\x0b\x81#[\xfd\x1b\xfb\xcd\x94\xd5\xa4\x0e]W\x02<z\xb2[C\xf6ej\xd8\x8aOskA\x14\xc1\x0el\xc7\xd0V\xaa\x1d`w\xdc\xb7\xa5-\x8a\x02\xb4%\xbe\xb6{\x8d\x8d|\xf1\xca,L\\R\rQYs\xe3\x19\xa8G+U\xd6d-\xd1^\xcf\x9ef\x82V5\xc8\x96N[\xd3\x863\xae\xef\xaa\x06\xac\xaej\x91\x1b\xc6Bf\x02\xe6\x98\x93\x9aC"X\x81t\xec\x87\x07\xa3\x0fZ\xfa\xba\xcb\xce\xf82\xe7\xaf\xda\x9e\xebdz\x0bI\xa3 \xba\xc30\xd1\x02\xdau\x99\x8d\xed\xde(Z\x83\xa6LU\xb1\x95\xee\xb6\xb4\xc1S3\xf3\x0b\x9b\xdf\x9a\x07\xc5=w\x03K\x18\xb9\xca\xba(c\x88j\xd2\x9a\x88\x85V\x87L50\x14n\x91\xd6\xa5\xf3\xf8Ku^\x00\x9b\x95dM\xc5\xd2\xd2\xdc,\xed\x14A\x15\t\xbbF:\x87\x01\xd8\x97\x8d\xd2\xb6\x91b\x05\x1e\x08\xda\x9a\xd2\xb1\x0cU\xda\xdd\xb6]\x0c\xed\xec\xb5\xa6\xa3\t\xd6Z\xd0\xd1\xa1\t\x11\xa4\xbem;\xd6\xa2\xb4\x1dj\xb4\xb7\x86|\xda\x01;H\xe9g\xe1\x07)\xdb\x9c\x8f\xb1a\x10\xc5\xe9v\x16!;{\xee\xc3\x17\x8b\xb6\xa9\xff\x89\x96\xcbqO/ ^\xb4~\xc6\x95\x9e\xa3_S)K\xec\x0b\xd5\x08\x12\xcf\xa1de\x8c\xe0d\xeeYn\xb8&\x95\xc1\xd7IM\x8a\xb8!sf\xb7C\xbb\xeazn\xec\xc29\xcbA\x18xA}={\xe8\xe2f\xda\x98\xbe_\xf6u:\xa3\xe0\xb7\xbdZ\x02&J\xd1r\x8e#\x0f\xe6\xbb(\x1bH\x98N5\xe3 \x84C\xec\x08\x19\xa3\x06\xfev\xc682rW;cB;n\xe4z#\x19G\xae\\\xd5\xb2E\xad!kM\xac\xc0\xd6>\xacJ"\xaaMR`]Nst\xcfx\xb82?}QLw\x18\x93O\x0c=\xfb\xfa$\x11=\xb6\x7f.\xeb\xd7\xddO\x9a\x1b\x91n\xf4?\xb5)\xbd \x8b\xab\xec!\xed\xb0\xab\x98n1e\xadm)&\xdb\xa8CY\xee\xec\xe59~`rX\x8e\xbb\xb2\x82@\xc7\xd6\xd8=%qEV\x95\x1b\xcbI6\x92\xa7\x1f,z\xb0\x1a\xd2\x0b) \x9e\x83\xfc\xe2\x9cS|ZF\n\x06\x9d\x14\x0b\xd33\xe7\xa7\xcfV\xc4\xd3\x95\xc5\xa5\xb9K\x17\x0bL\xec\xe2\x05Uw\x9d\xe2\x93I]\x15\x97\x83IQX\xb8\xb4\\\xe4\x13 \xf0\x8bP\x0f\xa2\'\xc6\xcb\x13\xc5r\xb98~L\x94\x1f\x9d,\x97\x1f\x99\xa9,c\\qQ\xae\xbaj\xeb\xb0\xf1b\xf9\x98\x98\x98\x98\x9c(?2^\x1e\x1f/\xcc\xdb*..G\xb6\xaf\xe0\xd9 \x9a\x84\xe3\xedV(Nj8\xed\x91a\x8b\xb1\x1b\xaa"\xce\xb2"\x88\x02v\x94\x1c9\x85y~=A\xc6).K\xbb5)\xce\xca\xa8e\xfbY\xeb$\xc8V\xb80w\xa1\xd2\xd9_\xb94^\xc0\xd1\x17\xc3L\xc5e\x9c{\x93"\x96k\xf1\xd1\xd0\xb3]\xff\x04xgGJ\xc6\xa7./\x9f)>\xde\x19Gz\xc1\xb4\xc5\x8a_\x0b(%L\x8a\xc7\xabn\\8+}\x19aS0\xcc\xfa\xa4\x08\xd7\xeb2&a\xa5p\x1d\xcb\x1c/,xId{\xc53A\xd4R\x93\xc2\x0f\xf5\xab:5qB\xf0\xe3\xa9#\xbe8tJ\x94GO\x14\xa8\x0cqU,|\xb7\xd6\xc8J\x16WFqw\xfa_\xc5\x17#\x91`)\xbed,J\xa5\x12N5\xf7C\xc7p\xf5"\xbb\x8b\x19)\xa3\xba\xac\x82QJZ\'\xabn}\xeaduj\t\x94C\x05#\xc5t\xa2V6\xaf7p\xda!3z\x9cc\x90^\xa2\xa6\x07\x15\x85\x9d(,\x00ky\xb4B[F\x8e\xf4\x9f8y\xb4:\x85/\x04YO"a\xa2\xc9\xcaK!\xc5\xb61\xba\x9d`**/\x84L\x15)\xbb\x819f.\xe5\t\x01\x86\xd6\xc1\x00\x1c+\xd6,\x94\xaa\x18\x85Q\xd5H\x84\x96Y\x18{\xf56\xafA\x9bX\'^q^\xfa>\x0e\x9f8\xd7N\xd4\xcb\rW$\x12%M\xe2ge\x0e\xd9\x1a$\xa9\xba\xbe\x03e\x15J"\xbd"[\x8cz1\xb1\x92\xd9+\x15\x05\xcbS\x94sI$\x9aA\xa8\xe5\x08|*\xd1\x86L\xeaR\xd0\xca\xee\r\xca\xa3g\x90\xeaQ\x7f4\xc0\xa4\x1b\xd6Hb\xb1\xff\x9cNQ\xd4\xbf\xe7\x86B\x16\xf8\x94fSH*\x9e\x10F\xc4&\xb8\x8363\xaf\xcd\x98\xdf\x8c6\x0b\xdbE\xcc\xe5\xc7\x8b\xcd\xebU\xac@\x14B\r\xb0\x01;5\x03\x7f\xc5\xad\x83\xf04`\x0c\x96\xf3H\x14\xaaU,\x04\xe5\x10\x1e\xc8\xf3u\xa4\x19\xd5\xe1\x92hn^\xf3I\x1a{\xc8\xa1\xb4&\xe6eB^h\xb8\xdeJ<&\x88\xf6\x9d5L\x9d!\xc5F"\xc8\xe9\xc4#7\xa6\x13\x89\xceG\x8a*\xb7nJ\xf2\x8c\x1e\x10\x00\x7fb$x\xaf\xf9\x9f\x9b\xd1s`\x89\xd9M<\xb7*\x1c\xb0\xe8\x12gd\xc3\xc3\x96\xdd\x1e\xf4\xb6\x93\x15$\x05\x1cm\x98\x9c\xd1\'-\x12s\xc1\x81s]\xc5\xd4\xd0\xb6\x1b\x9ef\xfe"\xbbF\x8d\x91\x0cA^$\xbdL\x19\xa0\xc3O\xcf\xd51\xe9\x94\xe0\x19\xa3\x8f\x1f\xb7\x11\xe6\x11\x1d\xb6y\x17\x8b mt\xec\x8d\xb6K\xde\xf4\xe1\xbe:\x85\x1as\x83\t\x87\xd4P\xb7\xab\x92WeW\xb5R]n\xa4\xc1\xf6\xb3\xaaaS\x00\x92\xfc\xdeI\xacj\xfa\x10e\x88\xa7K\xa1\xeek%J\xf5L.c\x02$\xd1yik\xea\xea0\xc9\xcdW\xc3 \n3\x0b\x84\xd0\xd4\xf2\xc9H\xbe/Pi\x81RPV\\@\x91\x05\xdb\xeb0\x16\x15\xbf\xee\x91YJXA\xd3m\x05cTJG\xe4\x07\x1aD\xf6\xf3\x82\xa6\x96\xbe\x14F6\x11Yk\xab\xe91&T\x80S\xc2\'=\x95Ij*\xde\xbc\x1eo\xc4\xda7\xc4eE\xd9\x93H\xb3\xf9:\xc2\x04G\xcd\x06D\xc2\x92\x89Ny\xb0\x19*\x9c\xfa\xe6u\x8f\xe8\xda\x93\x86\xdd\x8c\x05\x0b9\x83\x92\xc8\xe4&f\xe6)\xcc\xae\x84\xa3#\xf8:\xcd\xf1\xa6\xb2\xcfg\x87\xaeZ\xbf\xcbhl\x8b(\xb5E\xa6\xd6\x96\xa84y%uyN\x854\x04\xb0\xa5%}\\q\xda7N\xe6\x0b\x88\xda^:\x9b@\x85St)\xa6\x8bh=\xafS\xde\xa9\xae\xf0.\x8f\xd2r :\x06\xf5f\x11G\x19Rc2\xb5\xad\x13%\xd4\xc9\xa3\xc9\xd4\x18\xdd8\xeat&\xf8\x10\xe0\xa1\x99\rA~]\x853\x13\xa2\x03\xb9|LG\x8aI\xaaBI\xaf\n\xefg\x89\xa9$\xa0P\xa10\xc1*]\x81\x8f\xc4l"\x9a\xc4a:bh\r\x10\x81\xa4\xf0y"\xf3\x1a\x9b\x13\\\x07Q\xb7\xba\xa6\'\xd3\x96\xfcC9\x12V_\r\xa2\x8d\xa4\x1ec\xef:$\x8c\x02\xe7\\\xbf-]5\xa9\xd5\x98\x85\xac9\x9fBN\x8b\xe5\xfc\xdee\x01\xc8A\xf9\x89U\x98\xc3\x08\x95\xc0Oc\xe2\x19\x93QP\xcb\xa3\xea\xd2\x06i\xeaX\x0bZnLC}\x89\xb2\xc2\x1c\x8f&\xa6\xb6d\xdd\xb3\xb8\xb4xN\x8e\x1a}J\x05\xbb\n\x9dL\xa5\xd0}\xdaS\x1a\xd2\xdd\xa8\x19\xeb\xf1\x96\x92\'W*H>\x1c<\x07z\xb98\xb7\x10\xbf\xc8x~\x9f\xfa\xa4{\xdav\xde\xd0^\x11 ME\x0e\xa6z\x9bl\x85T@>k\xd33\xfcw\x0e\'\x96\x14LF2\xf44\x87\x1c1v\xc9P<+\xb1(Q(\xd9\x88H\x9cl\x85+t\xb6\x908\x1b\x7f>g:\xc8\x85.\xb1.\xc4\x9c\xdcA\x8c\x95\xba\x0frl\t\x8a\xfa\x01\x8a\x9d\xac\xf8!\xbf\xf4\xb0-\xd9.+\x19\xf9\x82C\x86\x05\xc13?\xcdv\x85\x1b{\x83\xeb\xd5\xde\xe9\xa5\xe2\xea\xa3D\x13\xa4g\x84\xea\x02K\xf7\xd0\xa6\xb3h6\xeb\xea\xe1\x12\xc9\x8c\xc2\x82:\xac\xd9\xce\xf1\xa3\xb0\x01\x90&\xb3Z\xd7qd\x0e\x0c\x98L\x058xtl\xc2\xd5\xa0\x82\x9f\xc5Qk\xf3Z\x9d\x0c\xd8\xd4\xee\xca\x8e\x1c/\x80OS[aA\xa2\xaf1\\k\xf3MSE\xdc\x8c\x08\xfa\x01d#\xe6\x9b\xb4+s\'{$\x96\xd3V\xfd\x96\xa6\xca\xa4\x05\x03b\xdb\x85ByTG#\xfc\xcf\'\x08\xa5\x15:\xa5\xf3\xa79\x1b,\x92Ml\x9dI\xc16\xea\xba\xe0\xe2\x12\xd4Q\x08\xf9\xe6#\x885uc\x97\xc41\xad\xbf\x9d\xf0\x81F91\xb7v\x15M|\x80\x17\x1e\x1d\x15W\xb0\xd9\xf2\x98\xf0\x13]C\xd0\xef\xb2\xe6\x14\xccU\x1e\xb9\xc2\xa4{\x1d\xd2\xaap\x8c\x85L|\x14!\x9ao\x1d\xebW\xa97\x92n\x95\xb9\xd7)\xfe1:\x13B\x9e\xaf\xa2|\xc3\x1d\xa0N^N\xdd\xd5\x0cZ!\x95\xbb\xba\xae\xb8b\xe2\xdc\xfc\xbe\x08\x1b\xe7\xbd\xac\xd9\xc7\x16r[\xc20\x01\x11\x99\x082\xbb\t\x83\x85h\xf3\xfa\n\xfd\xb4,\xb7\xe7!\xdc\xf3)FuF\xe5\x80C\xe9\xa0=\x96\x92\xb3$\x16g\xf4\xdd\x1e\xf5\x80\x1eF\xa7\x89\xd0\'*\xfd\x06\xa3\xd7\x8d\xe0\x92X\xe1\x9e\x1bo  6$\x04!\x83\xe9\xf3\n\xc99\xeep^\xf5\x1d\x9b\xd3\x00\xf7lJ\xdb^G\x835\xa7^L\x14.\xc9 P\x9f\xbbl\x8f\x8d\x1e\xee\x92\x8a\x18\xd2\xa5.\xff\xae)i\xa3\x1bA=\x0b\xc8l\x9b\xbd\xaf\xbciE\xd9\xf3\x97\x9e|A\xd3\xff\xa7\xa0~\x17\xa4~\xbf\xf8\xdc\xcc\x98\x1b\n>\x8f\x0c\xe9\xe9\xc87\xd7\xe5\xf6\xe6\x9b\x9c\xf1\xdb\x92\xd3=\xec\x93\x1b\x02\x11i5\xbe\xed\xeaC\xd5\xe3ld7bP\xbe\xb7(\xdb\x84sWh|\x98H]\xa9f7\xfa\x1b\xd6\xf9`\xaa\xb9\r9\xae]\xf7\x03\xa5\x0b\xd3\xe2Q\xf8\xd5\xd4\xf3~\xfaK\xe6\x87\r\xbb\xc9\xa08rX\x8d\n\x15\xbb\xadVJ8J\xd9\x94\x98\xd2\n)=\x93y\xa8\xbe\x9db\xb1R\xa1\x92\xde\x94\xe4\x1a\xd8\xaa\x0b\x13\xaei\xf4\x11\xeb\xcb\x84"\xda\xfcl\xd4wy\xbeU\xb9\xe9\xcd\xb8\xd7\x10\n\x85f\x10EI\xc8?C\xb8\x96.\x07\xac\xff\x03PK\x03\x04\n\x00\x00\x00\x00\x00\xf9\xb6zH\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\n\x00\x1c\x00locale/en/UT\t\x00\x03f\x05\xf7V\xa5\x13fSux\x0b\x00\x01\x04\xe8\x03\x00\x00\x04\xe8\x03\x00\x00PK\x03\x04\n\x00\x00\x00\x00\x00\xfb\xb6zH\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x16\x00\x1c\x00locale/en/LC_MESSAGES/UT\t\x00\x03i\x05\xf7V\xa5\x13fSux\x0b\x00\x01\x04\xe8\x03\x00\x00\x04\xe8\x03\x00\x00PK\x03\x04\x14\x00\x00\x00\x08\x00\x8akdA\x0c\x10\xcdR\xac\x0b\x00\x006\x1e\x00\x00)\x00\x1c\x00locale/en/LC_MESSAGES/collectNWDataGUI.moUT\t\x00\x03c_\x96P\xa3\x13fSux\x0b\x00\x01\x04\xe8\x03\x00\x00\x04\xe8\x03\x00\x00\xd5X]l\x1cW\x15\x1e\x9a\x96&k\xbb\xb1\x137u\x89\x93\xde\xb6\x84\xc6mw\xebuZ\x126\x8e\x89k;\x89I\xe2\xb8\xf6&y\xe1ov\xe7zw\x9a\xd9\xb9\xd3\xb93^o\xa5\x02\x15R_\xa0y\x00\x81D\x01!AE\x81\x07\x1e@\xf4\t(\x0f\x80\x80\x17\x10B\xe2W\x15E\xe2\x89\x17\xd4"\xa1\n\t\xf8\xce=wvg\x1d\xbbi\xfa\x80\xca*\xe3o\xe6\xfe\x9c{\xee9\xdf9\xf7\xdc\xbc\xbc\xe7\xe6\xcf9\xf8=\x86g\x1c\xcf\xf379N\x0b\xf8\xe0-\x8e\xf9\xfd\xf9\x9d\x8e3\x0c|\x058\n|\x15\xb8\x0fx\xeb\xad\xdc~\xd0\xe2C\xc0I\xe0I \x868O\x00\xef\x01n\x00\x87\x80_\x04\xde\x0e\xfc&p?\xf0%\xe0\xbb\x81\x7f\x04\xee\xa6\x85vB\x06`x\'\xcb;\t<@z\x01\x8b@\xb5\x93\xd7\xff\xf2N\x9e\xf7\x1d`\x01\xf8[;\xfe/\xc0\xdb\x80\xaf\xedd\xf97\xedr\x9c\xbd\xa4\x1f\xf0~\xe0\x14\x10\xff\x9c\x0f\xedb=\x1a\xbbx\xdeS\xc0;\x81Ww\xf1\xbco\xec\xe2u~\x0c|\x00\xf8{;\xfe\x96\x02\xe3~\xe0 \xb0lq\x06\xb8\x07x\x16x7\xf0\xc3@\x98\xd0\xf9D\x81\xd7\xfb$\xf0\x10\xf0Y\xe0A\xe0w\x81\x03\xc0_\x17X\xbf\x97\x0bl\xcfW\x81c\xc0]\x03\xbc\xee=\x03l\xb7\xa5\x01\x1e\xff\xc1\x01\xeeo\x02o\x06>=\xc0\xeb?3\xc0\xfb\xfe\xac\x1d\xf7\xd5\x01\xd6\xe3\xdb\x03\xbc\xef_\r\x18\xd3:\xff\x1a\xe0}\xdd<\xc8\xf6\xbe\x13\xf8.\xe0\x04\xf0^\xe0\xfc \xdb\xbb9\xc8~x\xc6~\xbf8\xc8v\xf9\xcd \xeb\xf5\xf7A\xde\xc78\x94+\x01\x8f\x03\x89*\x8f\x0f\xb1>\xd1\x10\xaf\xf7\xd4\x10\xaf\xf3\x8c\xed\xff\xfc\x10\xf3\xe2KCl\xef\xaf\xd9q?\x18b\xbd\x7f\n|\x0f\xd9e\x88\xf7\xf7\xba\xc5\x7f\x03\xaf\xbe\xc3qv\xdc\xc6\xfe\xfa\x0c\x84\x8e\xd0\xfc\xddl\xbf\xef\xed\xe6\xf6\x9f[\xfc\x03\xf0Q\xe0\xdfv\xf3\xfc\xd20\xf3\xf0\xc80\xcf\xbb4\xcc~l\x0e\xf3\xbe>6\xcc|zn\x98\xf5}i\x98\xf7\xff\xcba\xb6\xd7\x7f\x86\xd9\x0e\xa3#\xcc\xc3\xa9\x11n\xff\xe8\x08\xcfKGx\xdf\xcf\xd9\xf6\x17\x80\x9f\x06~\x7f\x84\xe5/\xeea\xff\xcb=\xec\x8fO\xeda\x7f\xbd\x08\xfc\x00\xf0\'{\xd8\xae\xc3{\xd9.\xd3{y\xde%\xe0\x0f\x81\xf1^^\xbf\x0c\xe1\xf7\x01/\x8c\xb2\xfe\xedQ^\xf7Y\x8b\xcf\x8d2?^\x00\x1e\x01\xfeh\x94y\xf8\x8fQ\xb6\xeb?GY\x8f\x83\x98,a\xcf\xf9\xdbY\xee\xb7\xf6\xb1\x1d\x7f\xb6\x8fy\xf8\xa7},\xe7\xb5}\xac\xd7\xe0\x1d\x8es\nx\x0cx\x15\xf8\xf1;\xb8\xff\xb61\xb6\xd7}c\xcc\x87\xa3cV\xef1^?\x06\xae\x00\xbf>\xc6y\xe1\xf51\xf6\xf7\xfd\xd8\xe4y\xac\x7f\x04\xf84\xf1\x18$\x9c\x06\xee\xd8\xcfz\x9e\xdc\xcf\xdf\r\xe0I\xe0\xf3\xfbY\xcf\xbf\xeeg\xf9;\xc6Y\xaf\xbb\xc6y\xdd\xb3\xe3\xcc\xc3\xc7\xc7\x99g_\x00\x1e\x03~e\x9c\xd7\xfb\x1d\xf08\xf0\x15\xdb\x7f\xe0\x00\xf3\xe2\xde\x03l\xef\xc3\x078\xce\x1e=\xc0\xfcY\x06\xfe\x02\xe8\xdaq\x0f\x1ed,\x03\xa1v\xf7G2\xa9\xfd\xac\xc3q~\xde\xb6\x13\xd7\xf6\xd9w\xca\xa7\x8f8\xec\xe7c\xb9\xb9\xb7\xe4\xde\xdf\xeb\xf0~v\xe0Yp\xd8\xd6\xe4\xa7\x87\xf1T\x1c\x8e\x19\xf2\xf7a<\'\x88O\x0e\xf3\x8et\xa5\xf8]\xc63\xe1p\xfe&~\x90\x8d\xee\xb2\xb2\xdf\x8f\xe74\xed\xc1\xe1\\I| n_p\x98\x8bd\x9f\x83v,\xe5\x00\xe2\xe5\xa8\xfd&\xdf\x1e\xb5\xef\xe4\xbfY<g\xec\xf7\xbcE\xe2\x01\xe5>\xf2\xdb\x12\x9e)\x87c\x84\xe2y\x06\x0f\xa8\xe2 \xbd\x1b?\x92O\x87\xec<\xe2\x07\xd9\xbe\xe4\xf4\xff\xde\x87\xa7\x9c\xfb&^\x8f\xd8w\xe2\x00\xf1\xf4\x9c\xfd\x9e\xcb\x8d\xa3x\xbf{\x93,\x91\xbd\x1c\xd2"T\x89\xf0C\x9d\xb8A =jh\xfbA jr\xeb\xc64\xec5\xcf\x86n\xd0\xd1\xbe\x16\x9eL\\?\xd0\xbd\x06\x9d\xb6Zn\xdcqfc):*\xc5\xb7}i\xbba"\x12%<_\xbb\xb5@\x8aX\x99\xd5\xd7U\xddM|\x15:snX\x97\x81\x05\x11\xcb\'R\xa9\x13\xe9\t/\x8d\xfd\xb0!\xa2X\xd5\xa5\xd6x\xb5C\xaaJ\x05U?r\xe6\x02\xe9\x864B\xa5I\x94&b\xcd\x0f\xa4\xee\xb5\x9ae\x96/\xcfc)\x92\xd1\x8a\x12gNa\x0f\xf5\x84z=7q\x85\x1bzx\xa0\xff\x93\xd4\xa4;X\xb6\x85AaH\x83T(\x92N$\xf1\x1du\xcc\x0c\xb3aig\xd0\x8ec\xa9\xd3\x80\xb6\x82\xcd\xd5\x03?\xaa)7\xf6\x9c\xb9X\xbaf\t\xd2G\x1c\xd2\xce\xfc\xea9q\x06=m7\x961t\x95\xb1\x98.\xce\x88\xb9\xc0\x97a\xb2]\xef9?L7V\xb6\x1c}^y\xb2\xb5}\xe3v3e-m@\xd75\x85\xd7@\xf6k\xc8\xbe\xcc\x0c\xbb\x10\xd2\xdc\xba\x8ac\xd8\x81\xed\x18\xb9Z\xb7\x15v\xc7}\x9b\xda\xe2X\xa1-\r\x8d\xdd\xebl\xe4\xa5\xcb\xf30qI7\xc5\xc2\x86\x9f\xccA=ZiaC\xd6S\xe3\xf5\xee\xdb\x9cj\xd5Tw\xe9\xac5k8\xe5\x87\xben\xc2\xea\xba\x1e\xfbQ"dW\xc0"s\xd2pH\xa85H\xc7~x0\xfa\xa0eh\xba\xdc._\x16\xc3u7\xf0\xbd\xae\xdeB\xd2(\x88\xee1L\xb4\x80nCv\xc7\xf6o\x14\xad\xea\x8a\xccTq\xb5\xe9v\x8c\xc133\xf3\x07\x9b\xdf9\x07\x8a\x07\xfe\x93X\xc2\xca\xd5\xce\x92L \xea\n\xad\x89Xh\xf5\xc8T\x07C\xe1\x16\xe9\\8\x8b\x7f\x99\xce\xcb`\xb3\x96\xac\xa9X]]\x9c\xa7\x9d"\xa8b\xe1\xd6I\xe7H\x81}\xddQ\xc66R\xac\xc1\x03\xaam(\x9d\xc8Hg\xddm\xd7\xc7\xd0\xde^\xeb&\x9a`\xade\x13\x1d\x86\x10*\xf3m\xdbsV\xa4\xebQ\xa3\xbb9\xe4\xb3\x0e\xd8A\xca\xb0\x1b~\x90r\x8d\xf316Rq\x92mg\x05\xb2\xbb\xef\xdb\xf0\xc5\xa1m\x9a?\xa2\xe5s\xdc\xd3\x07\x88\x17wN\xf92\xf0\xccg&e\x95}\xa1\x9b*\r<JV\xd6\x08^\xd7=\xd5\xa6oS\x19|\x9d\xd6\xa5H\x9a2gv7rk~\xe0\'>\x9cSU\x91\nT\xa3\xd3}\xe9\xe3f\xd6\x98}_\x0cM:\xa3\xe0w\x83z\n&J\xd1\xf2\x1eA\x1e\xccwQ6\x900\x9d\xbe\x92\xa8\x08\x0eqcd\x8c:\xf8\xdb\x1b\xe3\xc9\xd8_\xef\x8d\x89\xdc\xa4\x99\xeb\x8de\x12\xfbr\xdd\xc8\x16\xf5\xa6\xac_\xc1\nl\xedC\xba$\xe2z\x85\x02\xebb\x96\xa3\xb7\x8c\x87\xcb\xe7f\x97\xc4l\x8f1\xf9\xc4\xb0e\xdf6I\xc4\x8c\xdd>\x97m\xd7\xbd\x9d4?&\xdd\xe8ofS\xfa@\x16\xd7\xdd\x97\xac\xc3\xada\xba\xc3\x94u\xaeI1\xdd\x8dz\x94\xe5N_\\\xe4\x17&\x87\xe3\xf9kk\x08tl\x8d\xddS\x12\x97eM\xfb\x89\xac\xb0\x91\x02\xf3\xe2\xd0\x8b\xd3\x94AD\x01\xf18\xe4\x17\x17\xbd\xe2%\x19k\x18\xb4"\x96g\xe7\xce\xce\x9e^\x10\x97\x16VV\x17/,\x15\x98\xd8\xc5\xf3\xba\xe1{\xc5G\xd3\x86.VUE\x14\x96/T\x8b|\x02\xa8\xb0\x08\xf5 zj\xb2<U,\x97\x8b\x93\x0f\x8b\xf2\x91J\xb9\xfc\xc0\xdcB\x15\xe3\x8a+r\xdd\xd7\x9b\x87M\x16\xcb\x18v\xb4R>\xfa\xc0dyr\xb2p\xce\xd5I\xb1\x1a\xbb\xa1\x86gU\\\x81\xe3\xddV$\xa6\r\x9c\x0c\xc8\xb0\xc5\xc4\x8ft\x11gY\x11D\x01;J\x9e\x9c\xc1\xbc\xb0\x91"\xe3\x14\xab\xd2mU\xc4B\xd8\x08`\xa1ns\x05)\xe5#\x17W\x0b\xe7\x17\xcf/\xf4\xf6X.M\x16p\xfc%0U\xb1\x8a\xb3\xaf"\x12\xb9\x91<\x14\x05\xae\x1f\x1e\x07\xf7\xdcX\xcb\xe4\xc4\xec\xea\xdc\xe2bo\x1c\xe9\x06\xf3\x16\x17\xc2\xba\xa2\xb4P\x11\xc7j~R8-C\x19cc0N\xa7"\xa2NC&$\xac\x14u\xb0\xcc#\x85\xe5 \x8d\xdd\xa0xJ\xc5-]\x11ad>\xf5\x89\xa9\xe3\x82_O\x1c\x0e\xc5\xdd\'Dy\xe2x\xe1\xda\x82\xc5\xa6~\xca\x1e\xe8+\x95J=\xfa\xe7\xda\xae_\xaaL\xd7f\xa6k~c\xe6FK\x96\xe9\x87h\x16\xfe\xce8\x8f\xa5H\xaao\xa2t\xa9\xca\xb8\xe5\x87\x94\n\xd0\xd8\x80\xf3\xde\xae\xe5\x8b\xc0\xefm]\xc2\xb0\xb9\x8c\x9e\xdb\x142\xd8$\xd59q\x8bs\xa1I\x1d&\xeb\x87\xf6\xf0E\xfa]\xf3\x1b\xa0\x99\xe9o7\xfdz\x93NC:>p\xd6\'f>\x8c\xe2\xd2y\x98\xb6\x8c\x9d)/h\xa1 %\x16\x91T\x11\xe7f\xdf\x83^\xfeZ\xa7O\xba=\xda\xdf\xb0\x8c\xca\x98\xb7E9\x95#\xd7[)\xacDS\xe9\xc49\x83?\x86\xc9YM@\n\xda\xbaE\x85%\xb1\x98\xdc\xa7\x85\xf4\xcdv\xa8\xabn,,\x14\x7f\x99\xb4"\xd8\x95\xb0)\xb2\xab\xb4Vj\xbe\xa1\xdc\xb7X\xad\xcdK-ig\x10\x06Z\xaa\xc8\x8c\xf1\xd7\xfa\x0fj\xcb\xd6\xdeA\x1f)\xeb)\x8c!\x7f\xf5\n>v[IT\x9b\xa8NHH#\xcbE\xdd:,w\xe1\xc9rcI\\ s\xb4}mv\xd5\x11`3u\x9bj+\xa0JN\x046{\x92r:\x8d\xe8\x000\xd9h\x8bZ1+.\xbb\x9e\xderT\xce\xd77Z[^\x8eq\x80\xb1^\xfd\x15f\xb6\xe0u+\xcd\xdc\xe2\xa89WMe\xd2\x1dd\xf5\xb8\xa68{s\x05)t(O\x90dA\xb5\xe2\x96\x8eT\xec\x9a\xe9t\xa6\x9b\x96W9-\xc3:\r(\x97\xce\x98\xc0\xe3b\xd6\x8c\xa5\x14\x1f\xa7&\xb7i\xd3\x87\x8a\x90\xa2P\xab`\x9d\x99\x98\xedUY\xb7\xa9v\x08\x9a\xc5:)\x15\n\xd0i\x8auZ4\x1a\x1b\xff\xa6\xa1N\x8d\xdek)\xf8PG\xae\xecW\xd6\x1e\x1d\\nm\xd6\xd7^\x9bz\xfa\x9a\xaca\x16^s\xd7\x95q\x10S\xd1\xac\xbe\xa4p\xcc\x1b\x05\xaa\x14q|~j\xb2\x1f\t\xf6r\xc2\x04\x84\xbb\x01\x92\xb0\x07\x16\xae\xa3\xd9\x1cB~\x98\x85\xaaM\xd5\x99\xa7s\xf5}\xce\xa7\xff\xebJ\x7f\xb6\xdf\xc1\xec!d\x92+\x9a|\xd4\xe6\x8aK\xdb<b\xc2\xafAU\xaf\xeby\xbe\r[S{-\x86\xddc63M\x7fL\x90q\xc0\x03\x85\xa8\xed`-\xb0\xb9%CORN\xa8\xbb)\xec\xd0\x1dG9\x0eYB\xfbY-\xce*\xe7\xceM3\xb8\x95B\xa1\xbe\x03\xa37m\xfb[\x8a\xa9um\xfe\xf7\x11\x8f\x993\xf2\x17\x97|*7\x01C\xbb\xe9\x0b\x1a\x92\xe2T7\xb7\xe6B\x89vK\xb36/w\xdd{\xcf\xa6t\xb6\xf5\x8d\xc7\xc4\x00_\x8b\xbc\xdcE)+{\\\xe4\x97\x84\xb4\xba\xdeu\xa9I\xf6\xe5\x0f\xba\xc6@\xb7\x9ad\xbd\xeb\xddrDC\xcb\xa4M42{\xb4\xa7%\xdb\xb6\x15\xa9\x90\x82\xa1P\x9e\xb0\xc9\xce\xf8\x8b.;\xc2d,#\x04\x9b3\xa7\xf2\xe6\x1bKa\xeaM\xcf\xe23\x8d9\x18(\x98\xaa\x89\xc7\xf6\xe5\xac^82!V\xdd\x96\xa1G\xf9AQ\xe3\xfa!\xe6\xc0\xe4\xf2\xc4\x16:\xbdE\xfc0\xdb`\xe1\xe1\xde\xec\xa9\x1b\x9e\x9d\xb7\xa6/s\xe6lv\xd3\xe0:%</W\xced\xf63\xfe\xec\n-\t\x94\xd7b-\x8d\xcd1\x9f%\x18-\x99\x10^\xac"<\xc8\x905\xb5A&\xa2\xc6\xd8o4\x93-o\xb6\xbd\x9b\xa7\x8a\xfb\xa3\x01\xd7\xad\x12\x1d\x9f+s\xf6&\xba\xe9\xee\xdb\xbb\xf3R^\xb6\xb7\xdc7\xbe\xfe\x96\xc4\x86\xd7("\x98\xe3\xa2\xe7\xc7d\xb7\xfe\x0b\xc0\x16\xb7cC\xb6\xbc\x8e\x87rY\x9b\xcb\x03\x99\xe4\x94\xfc\x7f\xbd.\xaf\xe6J%\x7f\xad\xef\xb6\x92\xe54\x13_m\x1a\x9d\x0b\xbf\xde\xd5\xfaF$\xd0\x84\xbc\x90Ys\r7\x97\x9e\xed/\xe1 \x840\xf7\xef\x86\xf9\xcf\x1b\xceT\xbd\x86\xb9\xccK\xb0\xfa\x16D\x12\x87\x0f\xe9\t\xe1)\xc9NGNF\xac\x92\x13A\xf1\xacj\xb0\xa7\x89\x19Z*T\x9bn\xae\x9c\xcd\x8e\x81^\xc8e\')\x02\xa6-\xd6\xf9\xb2\xbb\xdd\xe2\xbd\xe3vk\x9asb\x89\xe34\xa2\xd2\xef\x14\xfd\x97\xc1\x19:\xb6\xfe\x0bPK\x01\x02\x1e\x03\n\x00\x00\x00\x00\x00\xf5\xb6zH\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\n\x00\x18\x00\x00\x00\x00\x00\x00\x00\x10\x00\xedA\x00\x00\x00\x00locale/de/UT\x05\x00\x03^\x05\xf7Vux\x0b\x00\x01\x04\xe8\x03\x00\x00\x04\xe8\x03\x00\x00PK\x01\x02\x1e\x03\n\x00\x00\x00\x00\x00\xf7\xb6zH\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x16\x00\x18\x00\x00\x00\x00\x00\x00\x00\x10\x00\xedAD\x00\x00\x00locale/de/LC_MESSAGES/UT\x05\x00\x03a\x05\xf7Vux\x0b\x00\x01\x04\xe8\x03\x00\x00\x04\xe8\x03\x00\x00PK\x01\x02\x1e\x03\x14\x00\x00\x00\x08\x00\x8akdA/\x11\xc0\xb1+\x0e\x00\x00\x80!\x00\x00)\x00\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\x94\x00\x00\x00locale/de/LC_MESSAGES/collectNWDataGUI.moUT\x05\x00\x03c_\x96Pux\x0b\x00\x01\x04\xe8\x03\x00\x00\x04\xe8\x03\x00\x00PK\x01\x02\x1e\x03\n\x00\x00\x00\x00\x00\xf9\xb6zH\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\n\x00\x18\x00\x00\x00\x00\x00\x00\x00\x10\x00\xedA"\x0f\x00\x00locale/en/UT\x05\x00\x03f\x05\xf7Vux\x0b\x00\x01\x04\xe8\x03\x00\x00\x04\xe8\x03\x00\x00PK\x01\x02\x1e\x03\n\x00\x00\x00\x00\x00\xfb\xb6zH\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x16\x00\x18\x00\x00\x00\x00\x00\x00\x00\x10\x00\xedAf\x0f\x00\x00locale/en/LC_MESSAGES/UT\x05\x00\x03i\x05\xf7Vux\x0b\x00\x01\x04\xe8\x03\x00\x00\x04\xe8\x03\x00\x00PK\x01\x02\x1e\x03\x14\x00\x00\x00\x08\x00\x8akdA\x0c\x10\xcdR\xac\x0b\x00\x006\x1e\x00\x00)\x00\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\xb6\x0f\x00\x00locale/en/LC_MESSAGES/collectNWDataGUI.moUT\x05\x00\x03c_\x96Pux\x0b\x00\x01\x04\xe8\x03\x00\x00\x04\xe8\x03\x00\x00PK\x05\x06\x00\x00\x00\x00\x06\x00\x06\x006\x02\x00\x00\xc5\x1b\x00\x00\x00\x00'
